declare namespace CS {
    namespace AOT {
        class MonoPInvokeCallbackAttribute extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor($type: System.Type);
        }

    }
    namespace JetBrains {
        namespace Annotations {
            class CanBeNullAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class NotNullAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class ItemNotNullAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class ItemCanBeNullAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class StringFormatMethodAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get FormatParameterName(): string;
                constructor($formatParameterName: string);
            }

            class ValueProviderAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get Name(): string;
                constructor($name: string);
            }

            class InvokerParameterNameAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class NotifyPropertyChangedInvocatorAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get ParameterName(): string;
                constructor();
                constructor($parameterName: string);
            }

            class ContractAnnotationAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get Contract(): string;
                public get ForceFullStates(): boolean;
                constructor($contract: string);
                constructor($contract: string, $forceFullStates: boolean);
            }

            class LocalizationRequiredAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get Required(): boolean;
                constructor();
                constructor($required: boolean);
            }

            class CannotApplyEqualityOperatorAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class BaseTypeRequiredAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get BaseType(): System.Type;
                constructor($baseType: System.Type);
            }

            class UsedImplicitlyAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get UseKindFlags(): JetBrains.Annotations.ImplicitUseKindFlags;
                public get TargetFlags(): JetBrains.Annotations.ImplicitUseTargetFlags;
                constructor();
                constructor($useKindFlags: JetBrains.Annotations.ImplicitUseKindFlags);
                constructor($targetFlags: JetBrains.Annotations.ImplicitUseTargetFlags);
                constructor($useKindFlags: JetBrains.Annotations.ImplicitUseKindFlags, $targetFlags: JetBrains.Annotations.ImplicitUseTargetFlags);
            }

            class MeansImplicitUseAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get UseKindFlags(): JetBrains.Annotations.ImplicitUseKindFlags;
                public get TargetFlags(): JetBrains.Annotations.ImplicitUseTargetFlags;
                constructor();
                constructor($useKindFlags: JetBrains.Annotations.ImplicitUseKindFlags);
                constructor($targetFlags: JetBrains.Annotations.ImplicitUseTargetFlags);
                constructor($useKindFlags: JetBrains.Annotations.ImplicitUseKindFlags, $targetFlags: JetBrains.Annotations.ImplicitUseTargetFlags);
            }

            enum ImplicitUseKindFlags {
                Access = 1,
                Assign = 2,
                InstantiatedWithFixedConstructorSignature = 4,
                Default = 7,
                InstantiatedNoFixedConstructorSignature = 8
            }

            enum ImplicitUseTargetFlags {
                Default = 1,
                Itself = 1,
                Members = 2,
                WithMembers = 3
            }

            class PublicAPIAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get Comment(): string;
                constructor();
                constructor($comment: string);
            }

            class InstantHandleAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class PureAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class MustUseReturnValueAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get Justification(): string;
                constructor();
                constructor($justification: string);
            }

            class MustDisposeResourceAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get Value(): boolean;
                constructor();
                constructor($value: boolean);
            }

            class ProvidesContextAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class PathReferenceAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get BasePath(): string;
                constructor();
                constructor($basePath: string);
            }

            class SourceTemplateAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class MacroAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public Expression: string;
                public Editable: number;
                public Target: string;
                constructor();
            }

            class CollectionAccessAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get CollectionAccessType(): JetBrains.Annotations.CollectionAccessType;
                constructor($collectionAccessType: JetBrains.Annotations.CollectionAccessType);
            }

            enum CollectionAccessType {
                None = 0,
                Read = 1,
                ModifyExistingContent = 2,
                UpdatedContent = 6
            }

            class AssertionMethodAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class AssertionConditionAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get ConditionType(): JetBrains.Annotations.AssertionConditionType;
                constructor($conditionType: JetBrains.Annotations.AssertionConditionType);
            }

            enum AssertionConditionType {
                IS_TRUE = 0,
                IS_FALSE = 1,
                IS_NULL = 2,
                IS_NOT_NULL = 3
            }

            class TerminatesProgramAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class LinqTunnelAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class NoEnumerationAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class RegexPatternAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class NoReorderAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

        }
    }
    namespace Unity {
        namespace Burst {
            class BurstAuthorizedExternalMethodAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class BurstDiscardAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

        }
    }
    namespace Unity {
        namespace Collections {
            class MemoryLabel {
                protected [__keep_incompatibility]: never;
                public get IsCreated(): boolean;
                constructor($areaName: string, $objectName: string, $allocator?: Unity.Collections.Allocator);
                public static SupportsAllocator($allocator: Unity.Collections.Allocator): boolean;
            }

            class ReadOnlyAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class WriteOnlyAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class DeallocateOnJobCompletionAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class NativeFixedLengthAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public FixedLength: number;
                constructor($fixedLength: number);
            }

            class NativeMatchesParallelForLengthAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class NativeDisableParallelForRestrictionAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            enum Allocator {
                Invalid = 0,
                None = 1,
                Temp = 2,
                TempJob = 3,
                Persistent = 4,
                AudioKernel = 5,
                Domain = 6,
                FirstUserIndex = 64
            }

            enum NativeLeakDetectionMode {
                Disabled = 1,
                Enabled = 2,
                EnabledWithStackTrace = 3
            }

            class NativeLeakDetection {
                protected [__keep_incompatibility]: never;
                public static Mode: Unity.Collections.NativeLeakDetectionMode;
            }

            enum NativeArrayOptions {
                UninitializedMemory = 0,
                ClearMemory = 1
            }

            class NativeArray<T> implements System.IEquatable$1<Unity.Collections.NativeArray$1<T>>, System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable, System.IDisposable {
                protected [__keep_incompatibility]: never;
                public get Length(): number;
                public get IsCreated(): boolean;
                constructor($length: number, $allocator: Unity.Collections.Allocator, $options?: Unity.Collections.NativeArrayOptions);
                constructor($length: number, $label: Unity.Collections.MemoryLabel, $options?: Unity.Collections.NativeArrayOptions);
                constructor($array: System.Array$1<T>, $allocator: Unity.Collections.Allocator);
                constructor($array: System.Array$1<T>, $label: Unity.Collections.MemoryLabel);
                constructor($array: Unity.Collections.NativeArray$1<T>, $allocator: Unity.Collections.Allocator);
                constructor($array: Unity.Collections.NativeArray$1<T>, $label: Unity.Collections.MemoryLabel);
                public Dispose(): void;
                public Dispose($inputDeps: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public CopyFrom($array: System.Array$1<T>): void;
                public CopyFrom($array: Unity.Collections.NativeArray$1<T>): void;
                public CopyTo($array: System.Array$1<T>): void;
                public CopyTo($array: Unity.Collections.NativeArray$1<T>): void;
                public ToArray(): System.Array$1<T>;
                public GetEnumerator(): Unity.Collections.NativeArray$1.Enumerator$1<T>;
                public Equals($other: Unity.Collections.NativeArray$1<T>): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
                public static Copy($src: Unity.Collections.NativeArray$1<T>, $dst: Unity.Collections.NativeArray$1<T>): void;
                public static Copy($src: Unity.Collections.NativeArray$1.ReadOnly$1<T>, $dst: Unity.Collections.NativeArray$1<T>): void;
                public static Copy($src: System.Array$1<T>, $dst: Unity.Collections.NativeArray$1<T>): void;
                public static Copy($src: Unity.Collections.NativeArray$1<T>, $dst: System.Array$1<T>): void;
                public static Copy($src: Unity.Collections.NativeArray$1.ReadOnly$1<T>, $dst: System.Array$1<T>): void;
                public static Copy($src: Unity.Collections.NativeArray$1<T>, $dst: Unity.Collections.NativeArray$1<T>, $length: number): void;
                public static Copy($src: Unity.Collections.NativeArray$1.ReadOnly$1<T>, $dst: Unity.Collections.NativeArray$1<T>, $length: number): void;
                public static Copy($src: System.Array$1<T>, $dst: Unity.Collections.NativeArray$1<T>, $length: number): void;
                public static Copy($src: Unity.Collections.NativeArray$1<T>, $dst: System.Array$1<T>, $length: number): void;
                public static Copy($src: Unity.Collections.NativeArray$1.ReadOnly$1<T>, $dst: System.Array$1<T>, $length: number): void;
                public static Copy($src: Unity.Collections.NativeArray$1<T>, $srcIndex: number, $dst: Unity.Collections.NativeArray$1<T>, $dstIndex: number, $length: number): void;
                public static Copy($src: Unity.Collections.NativeArray$1.ReadOnly$1<T>, $srcIndex: number, $dst: Unity.Collections.NativeArray$1<T>, $dstIndex: number, $length: number): void;
                public static Copy($src: System.Array$1<T>, $srcIndex: number, $dst: Unity.Collections.NativeArray$1<T>, $dstIndex: number, $length: number): void;
                public static Copy($src: Unity.Collections.NativeArray$1<T>, $srcIndex: number, $dst: System.Array$1<T>, $dstIndex: number, $length: number): void;
                public static Copy($src: Unity.Collections.NativeArray$1.ReadOnly$1<T>, $srcIndex: number, $dst: System.Array$1<T>, $dstIndex: number, $length: number): void;
                public ReinterpretLoad<U>($sourceIndex: number): U;
                public ReinterpretStore<U>($destIndex: number, $data: U): void;
                public Reinterpret<U>(): Unity.Collections.NativeArray$1<U>;
                public Reinterpret<U>($expectedTypeSize: number): Unity.Collections.NativeArray$1<U>;
                public GetSubArray($start: number, $length: number): Unity.Collections.NativeArray$1<T>;
                public AsReadOnly(): Unity.Collections.NativeArray$1.ReadOnly$1<T>;
                public AsSpan(): System.Span$1<T>;
                public AsReadOnlySpan(): System.ReadOnlySpan$1<T>;
                public get_Item($index: number): T;
                public set_Item($index: number, value: T): void;
            }
            namespace NativeArray {
                class Enumerator<T> implements System.Collections.Generic.IEnumerator$1<T>, System.Collections.IEnumerator, System.IDisposable {
                    protected [__keep_incompatibility]: never;
                    public get Current(): T;
                    constructor($array: $Ref<Unity.Collections.NativeArray$1<T>>);
                    public Dispose(): void;
                    public MoveNext(): boolean;
                    public Reset(): void;
                }

                class ReadOnly<T> implements System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable {
                    protected [__keep_incompatibility]: never;
                    public get Length(): number;
                    public get IsCreated(): boolean;
                    public CopyTo($array: System.Array$1<T>): void;
                    public CopyTo($array: Unity.Collections.NativeArray$1<T>): void;
                    public ToArray(): System.Array$1<T>;
                    public Reinterpret<U>(): Unity.Collections.NativeArray$1.ReadOnly$1<U>;
                    public UnsafeElementAt($index: number): $Ref<T>;
                    public GetEnumerator(): Unity.Collections.NativeArray$1.ReadOnly.Enumerator$1<T>;
                    public AsReadOnlySpan(): System.ReadOnlySpan$1<T>;
                    public get_Item($index: number): T;
                }
                namespace ReadOnly {
                    class Enumerator<T> implements System.Collections.Generic.IEnumerator$1<T>, System.Collections.IEnumerator, System.IDisposable {
                        protected [__keep_incompatibility]: never;
                        public get Current(): T;
                        constructor($array: $Ref<Unity.Collections.NativeArray$1.ReadOnly$1<T>>);
                        public Dispose(): void;
                        public MoveNext(): boolean;
                        public Reset(): void;
                    }

                }

            }

            class NativeSliceExtensions {
                protected [__keep_incompatibility]: never;
                public static Slice<T>(): Unity.Collections.NativeSlice$1<T>;
                public static Slice<T>($start: number): Unity.Collections.NativeSlice$1<T>;
                public static Slice<T>($start: number, $length: number): Unity.Collections.NativeSlice$1<T>;
                public static Slice<T>(): Unity.Collections.NativeSlice$1<T>;
                public static Slice<T>($start: number): Unity.Collections.NativeSlice$1<T>;
                public static Slice<T>($start: number, $length: number): Unity.Collections.NativeSlice$1<T>;
            }

            class NativeSlice<T> implements System.IEquatable$1<Unity.Collections.NativeSlice$1<T>>, System.Collections.Generic.IEnumerable$1<T>, System.Collections.IEnumerable {
                protected [__keep_incompatibility]: never;
                public get Stride(): number;
                public get Length(): number;
                constructor($slice: Unity.Collections.NativeSlice$1<T>, $start: number);
                constructor($slice: Unity.Collections.NativeSlice$1<T>, $start: number, $length: number);
                constructor($array: Unity.Collections.NativeArray$1<T>);
                constructor($array: Unity.Collections.NativeArray$1<T>, $start: number);
                constructor($array: Unity.Collections.NativeArray$1<T>, $start: number, $length: number);
                public SliceConvert<U>(): Unity.Collections.NativeSlice$1<U>;
                public SliceWithStride<U>($offset: number): Unity.Collections.NativeSlice$1<U>;
                public SliceWithStride<U>(): Unity.Collections.NativeSlice$1<U>;
                public CopyFrom($slice: Unity.Collections.NativeSlice$1<T>): void;
                public CopyFrom($array: System.Array$1<T>): void;
                public CopyTo($array: Unity.Collections.NativeArray$1<T>): void;
                public CopyTo($array: System.Array$1<T>): void;
                public ToArray(): System.Array$1<T>;
                public GetEnumerator(): Unity.Collections.NativeSlice$1.Enumerator$1<T>;
                public Equals($other: Unity.Collections.NativeSlice$1<T>): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
                public get_Item($index: number): T;
                public set_Item($index: number, value: T): void;
            }
            namespace NativeSlice {
                class Enumerator<T> implements System.Collections.Generic.IEnumerator$1<T>, System.Collections.IEnumerator, System.IDisposable {
                    protected [__keep_incompatibility]: never;
                    public get Current(): T;
                    constructor($array: $Ref<Unity.Collections.NativeSlice$1<T>>);
                    public Dispose(): void;
                    public MoveNext(): boolean;
                    public Reset(): void;
                }

            }

        }
    }
    namespace Unity {
        namespace Collections {
            namespace LowLevel {
                namespace Unsafe {
                    class NativeContainerAttribute extends System.Attribute {
                        protected [__keep_incompatibility]: never;
                        constructor();
                    }

                    class NativeContainerIsReadOnlyAttribute extends System.Attribute {
                        protected [__keep_incompatibility]: never;
                        constructor();
                    }

                    class NativeContainerIsAtomicWriteOnlyAttribute extends System.Attribute {
                        protected [__keep_incompatibility]: never;
                        constructor();
                    }

                    class NativeContainerSupportsMinMaxWriteRestrictionAttribute extends System.Attribute {
                        protected [__keep_incompatibility]: never;
                        constructor();
                    }

                    class NativeContainerSupportsDeallocateOnJobCompletionAttribute extends System.Attribute {
                        protected [__keep_incompatibility]: never;
                        constructor();
                    }

                    class NativeContainerSupportsDeferredConvertListToArray extends System.Attribute {
                        protected [__keep_incompatibility]: never;
                        constructor();
                    }

                    class NativeSetThreadIndexAttribute extends System.Attribute {
                        protected [__keep_incompatibility]: never;
                        constructor();
                    }

                    class NativeContainerNeedsThreadIndexAttribute extends System.Attribute {
                        protected [__keep_incompatibility]: never;
                        constructor();
                    }

                    class WriteAccessRequiredAttribute extends System.Attribute {
                        protected [__keep_incompatibility]: never;
                        constructor();
                    }

                    class NativeDisableUnsafePtrRestrictionAttribute extends System.Attribute {
                        protected [__keep_incompatibility]: never;
                        constructor();
                    }

                    class NativeDisableContainerSafetyRestrictionAttribute extends System.Attribute {
                        protected [__keep_incompatibility]: never;
                        constructor();
                    }

                    class NativeSetClassTypeToNullOnScheduleAttribute extends System.Attribute {
                        protected [__keep_incompatibility]: never;
                        constructor();
                    }

                    enum EnforceJobResult {
                        AllJobsAlreadySynced = 0,
                        DidSyncRunningJobs = 1,
                        HandleWasAlreadyDeallocated = 2
                    }

                    enum AtomicSafetyErrorType {
                        Deallocated = 0,
                        DeallocatedFromJob = 1,
                        NotAllocatedFromJob = 2
                    }

                    class AtomicSafetyHandle {
                        protected [__keep_incompatibility]: never;
                        public static Create(): Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle;
                        public static GetTempUnsafePtrSliceHandle(): Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle;
                        public static GetTempMemoryHandle(): Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle;
                        public static IsTempMemoryHandle($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): boolean;
                        public static Release($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): void;
                        public static IsDefaultValue($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>): boolean;
                        public static PrepareUndisposable($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>): void;
                        public static UseSecondaryVersion($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>): void;
                        public static SetAllowSecondaryVersionWriting($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, $allowWriting: boolean): void;
                        public static SetBumpSecondaryVersionOnScheduleWrite($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, $value: boolean): void;
                        public static SetAllowReadOrWriteAccess($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, $allowReadWriteAccess: boolean): void;
                        public static GetAllowReadOrWriteAccess($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): boolean;
                        public static SetNestedContainer($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, $isNestedContainer: boolean): void;
                        public static GetNestedContainer($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): boolean;
                        public static CheckWriteAndBumpSecondaryVersion($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): void;
                        public static EnforceAllBufferJobsHaveCompleted($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): Unity.Collections.LowLevel.Unsafe.EnforceJobResult;
                        public static EnforceAllBufferJobsHaveCompletedAndRelease($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): Unity.Collections.LowLevel.Unsafe.EnforceJobResult;
                        public static EnforceAllBufferJobsHaveCompletedAndDisableReadWrite($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): Unity.Collections.LowLevel.Unsafe.EnforceJobResult;
                        public static CheckDeallocateAndThrow($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): void;
                        public static CheckGetSecondaryDataPointerAndThrow($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): void;
                        public static GetReaderArray($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, $maxCount: number, $output: number): number;
                        public static GetWriter($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): Unity.Jobs.JobHandle;
                        public static CheckReadAndThrow($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): void;
                        public static CheckWriteAndThrow($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): void;
                        public static ValidateNonDefaultHandle($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>): void;
                        public static IsValidNonDefaultHandle($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>): boolean;
                        public static CheckExistsAndThrow($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>): void;
                        public static IsHandleValid($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>): boolean;
                        public static GetReaderName($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle, $readerIndex: number): string;
                        public static GetWriterName($handle: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): string;
                        public static NewStaticSafetyId<T>(): number;
                        public static SetStaticSafetyId($handle: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>, $staticSafetyId: number): void;
                    }

                    class DisposeSentinel {
                        protected [__keep_incompatibility]: never;
                        public static Dispose($safety: $Ref<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>, $sentinel: $Ref<Unity.Collections.LowLevel.Unsafe.DisposeSentinel>): void;
                        public static Create($safety: $Out<Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle>, $sentinel: $Out<Unity.Collections.LowLevel.Unsafe.DisposeSentinel>, $callSiteStackDepth: number, $allocator: Unity.Collections.Allocator): void;
                        public static Clear($sentinel: $Ref<Unity.Collections.LowLevel.Unsafe.DisposeSentinel>): void;
                    }

                    class NativeArrayUnsafeUtility {
                        protected [__keep_incompatibility]: never;
                        public static GetAtomicSafetyHandle<T>($array: Unity.Collections.NativeArray$1<T>): Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle;
                        public static SetAtomicSafetyHandle<T>($array: $Ref<Unity.Collections.NativeArray$1<T>>, $safety: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): void;
                        public static ConvertExistingDataToNativeArray<T>($data: System.Span$1<T>, $allocator: Unity.Collections.Allocator): Unity.Collections.NativeArray$1<T>;
                    }

                    class NativeSliceUnsafeUtility {
                        protected [__keep_incompatibility]: never;
                        public static GetAtomicSafetyHandle<T>($slice: Unity.Collections.NativeSlice$1<T>): Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle;
                        public static SetAtomicSafetyHandle<T>($slice: $Ref<Unity.Collections.NativeSlice$1<T>>, $safety: Unity.Collections.LowLevel.Unsafe.AtomicSafetyHandle): void;
                    }

                    class UnsafeUtility {
                        protected [__keep_incompatibility]: never;
                        public static GetFieldOffset($field: System.Reflection.FieldInfo): number;
                        public static ReleaseGCObject($gcHandle: bigint): void;
                        public static IsBlittable<T>(): boolean;
                        public static CheckForLeaks(): number;
                        public static ForgiveLeaks(): number;
                        public static GetLeakDetectionMode(): Unity.Collections.NativeLeakDetectionMode;
                        public static SetLeakDetectionMode($value: Unity.Collections.NativeLeakDetectionMode): void;
                        public static IsValidAllocator($allocator: Unity.Collections.Allocator): boolean;
                        public static SizeOf($type: System.Type): number;
                        public static IsBlittable($type: System.Type): boolean;
                        public static IsUnmanaged($type: System.Type): boolean;
                        public static IsValidNativeContainerElementType($type: System.Type): boolean;
                        public static IsUnmanaged<T>(): boolean;
                        public static IsNativeContainerType<T>(): boolean;
                        public static IsValidNativeContainerElementType<T>(): boolean;
                        public static AlignOf<T>(): number;
                        public static SizeOf<T>(): number;
                        public static As<U, T>($from: $Ref<U>): $Ref<T>;
                        public static EnumToInt<T extends System.IConvertible>($enumValue: T): number;
                        public static EnumEquals<T extends System.IConvertible>($lhs: T, $rhs: T): boolean;
                    }

                }
            }
        }
    }
    namespace Unity {
        namespace Content {
            class ContentNamespace {
                protected [__keep_incompatibility]: never;
                public get IsValid(): boolean;
                public static get Default(): Unity.Content.ContentNamespace;
                public GetName(): string;
                public Delete(): void;
                public static GetOrCreateNamespace($name: string): Unity.Content.ContentNamespace;
                public static GetAll(): System.Array$1<Unity.Content.ContentNamespace>;
            }

        }
    }
    namespace Unity {
        namespace IntegerTime {
            class DiscreteTime implements System.IEquatable$1<Unity.IntegerTime.DiscreteTime>, System.IFormattable, System.IComparable$1<Unity.IntegerTime.DiscreteTime> {
                protected [__keep_incompatibility]: never;
                public Value: bigint;
                public static readonly Zero: Unity.IntegerTime.DiscreteTime;
                public static readonly MinValue: Unity.IntegerTime.DiscreteTime;
                public static readonly MaxValue: Unity.IntegerTime.DiscreteTime;
                public static readonly TicksPerSecond: number;
                public static readonly Tick: number;
                public static readonly MaxValueSeconds: bigint;
                public static readonly MinValueSeconds: bigint;
                public static readonly Tick5Fps: number;
                public static readonly Tick10Fps: number;
                public static readonly Tick12Fps: number;
                public static readonly Tick15Fps: number;
                public static readonly Tick2397Fps: number;
                public static readonly Tick24Fps: number;
                public static readonly Tick25Fps: number;
                public static readonly Tick2997Fps: number;
                public static readonly Tick30Fps: number;
                public static readonly Tick48Fps: number;
                public static readonly Tick50Fps: number;
                public static readonly Tick5995Fps: number;
                public static readonly Tick60Fps: number;
                public static readonly Tick90Fps: number;
                public static readonly Tick11988Fps: number;
                public static readonly Tick120Fps: number;
                public static readonly Tick240Fps: number;
                public static readonly Tick1000Fps: number;
                public static readonly Tick8Khz: number;
                public static readonly Tick16Khz: number;
                public static readonly Tick22Khz: number;
                public static readonly Tick44Khz: number;
                public static readonly Tick48Khz: number;
                public static readonly Tick88Khz: number;
                public static readonly Tick96Khz: number;
                public static readonly Tick192Khz: number;
                constructor($x: Unity.IntegerTime.DiscreteTime);
                constructor($v: number);
                constructor($v: number);
                constructor($v: bigint);
                constructor($v: number);
                public static FromTicks($v: bigint): Unity.IntegerTime.DiscreteTime;
                public Equals($rhs: Unity.IntegerTime.DiscreteTime): boolean;
                public Equals($o: any): boolean;
                public GetHashCode(): number;
                public ToString(): string;
                public ToString($format: string, $formatProvider: System.IFormatProvider): string;
                public CompareTo($other: Unity.IntegerTime.DiscreteTime): number;
            }

            class DiscreteTimeTimeExtensions {
                protected [__keep_incompatibility]: never;
                public static Abs(): Unity.IntegerTime.DiscreteTime;
                public static Min($rhs: Unity.IntegerTime.DiscreteTime): Unity.IntegerTime.DiscreteTime;
                public static Max($rhs: Unity.IntegerTime.DiscreteTime): Unity.IntegerTime.DiscreteTime;
                public static Clamp($a: Unity.IntegerTime.DiscreteTime, $b: Unity.IntegerTime.DiscreteTime): Unity.IntegerTime.DiscreteTime;
                public static Floor(): Unity.IntegerTime.DiscreteTime;
                public static Select($b: Unity.IntegerTime.DiscreteTime, $c: boolean): Unity.IntegerTime.DiscreteTime;
            }

            class RationalTime {
                protected [__keep_incompatibility]: never;
                public get Count(): bigint;
                public get Ticks(): Unity.IntegerTime.RationalTime.TicksPerSecond;
                constructor($count: bigint, $ticks: Unity.IntegerTime.RationalTime.TicksPerSecond);
                public static FromDouble($t: number, $ticksPerSecond: Unity.IntegerTime.RationalTime.TicksPerSecond): Unity.IntegerTime.RationalTime;
            }
            namespace RationalTime {
                class TicksPerSecond implements System.IEquatable$1<Unity.IntegerTime.RationalTime.TicksPerSecond> {
                    protected [__keep_incompatibility]: never;
                    public static readonly DefaultTicksPerSecond: Unity.IntegerTime.RationalTime.TicksPerSecond;
                    public static readonly TicksPerSecond24: Unity.IntegerTime.RationalTime.TicksPerSecond;
                    public static readonly TicksPerSecond25: Unity.IntegerTime.RationalTime.TicksPerSecond;
                    public static readonly TicksPerSecond30: Unity.IntegerTime.RationalTime.TicksPerSecond;
                    public static readonly TicksPerSecond50: Unity.IntegerTime.RationalTime.TicksPerSecond;
                    public static readonly TicksPerSecond60: Unity.IntegerTime.RationalTime.TicksPerSecond;
                    public static readonly TicksPerSecond120: Unity.IntegerTime.RationalTime.TicksPerSecond;
                    public static readonly TicksPerSecond2397: Unity.IntegerTime.RationalTime.TicksPerSecond;
                    public static readonly TicksPerSecond2425: Unity.IntegerTime.RationalTime.TicksPerSecond;
                    public static readonly TicksPerSecond2997: Unity.IntegerTime.RationalTime.TicksPerSecond;
                    public static readonly TicksPerSecond5994: Unity.IntegerTime.RationalTime.TicksPerSecond;
                    public static readonly TicksPerSecond11988: Unity.IntegerTime.RationalTime.TicksPerSecond;
                    public get Numerator(): number;
                    public get Denominator(): number;
                    public get Valid(): boolean;
                    constructor($num: number, $den?: number);
                    public Equals($rhs: Unity.IntegerTime.RationalTime.TicksPerSecond): boolean;
                    public Equals($rhs: any): boolean;
                    public GetHashCode(): number;
                }

            }

            class RationalTimeExtensions {
                protected [__keep_incompatibility]: never;
                public static ToDouble(): number;
                public static IsValid(): boolean;
                public static Convert($rate: Unity.IntegerTime.RationalTime.TicksPerSecond): Unity.IntegerTime.RationalTime;
                public static Add($rhs: Unity.IntegerTime.RationalTime): Unity.IntegerTime.RationalTime;
                public static Subtract($rhs: Unity.IntegerTime.RationalTime): Unity.IntegerTime.RationalTime;
                public static Multiply($rhs: Unity.IntegerTime.RationalTime): Unity.IntegerTime.RationalTime;
                public static Divide($rhs: Unity.IntegerTime.RationalTime): Unity.IntegerTime.RationalTime;
            }

        }
    }
    namespace Unity {
        namespace IO {
            namespace Archive {
                enum ArchiveStatus {
                    InProgress = 0,
                    Complete = 1,
                    Failed = 2
                }

                class ArchiveFileInfo {
                    protected [__keep_incompatibility]: never;
                    public Filename: string;
                    public FileSize: bigint;
                }

                class ArchiveHandle {
                    protected [__keep_incompatibility]: never;
                    public get Status(): Unity.IO.Archive.ArchiveStatus;
                    public get JobHandle(): Unity.Jobs.JobHandle;
                    public get Compression(): UnityEngine.CompressionType;
                    public get IsStreamed(): boolean;
                    public Unmount(): Unity.Jobs.JobHandle;
                    public GetMountPath(): string;
                    public GetFileInfo(): System.Array$1<Unity.IO.Archive.ArchiveFileInfo>;
                }

                class ArchiveFileInterface {
                    protected [__keep_incompatibility]: never;
                    public static MountAsync($namespaceId: Unity.Content.ContentNamespace, $filePath: string, $prefix: string): Unity.IO.Archive.ArchiveHandle;
                    public static GetMountedArchives($namespaceId: Unity.Content.ContentNamespace): System.Array$1<Unity.IO.Archive.ArchiveHandle>;
                }

            }
        }
    }
    namespace Unity {
        namespace IO {
            namespace LowLevel {
                namespace Unsafe {
                    class ReadCommand {
                        protected [__keep_incompatibility]: never;
                        public Offset: bigint;
                        public Size: bigint;
                    }

                    class ReadCommandArray {
                        protected [__keep_incompatibility]: never;
                        public CommandCount: number;
                    }

                    enum FileState {
                        Absent = 0,
                        Exists = 1
                    }

                    enum FileStatus {
                        Closed = 0,
                        Pending = 1,
                        Open = 2,
                        OpenFailed = 3
                    }

                    class FileInfoResult {
                        protected [__keep_incompatibility]: never;
                        public FileSize: bigint;
                        public FileState: Unity.IO.LowLevel.Unsafe.FileState;
                    }

                    enum AssetLoadingSubsystem {
                        Other = 0,
                        Texture = 1,
                        VirtualTexture = 2,
                        Mesh = 3,
                        Audio = 4,
                        Scripts = 5,
                        EntitiesScene = 6,
                        EntitiesStreamBinaryReader = 7,
                        FileInfo = 8,
                        ContentLoading = 9
                    }

                    enum ReadStatus {
                        Complete = 0,
                        InProgress = 1,
                        Failed = 2,
                        Truncated = 4,
                        Canceled = 5
                    }

                    enum Priority {
                        PriorityLow = 0,
                        PriorityHigh = 1
                    }

                    class FileHandle {
                        protected [__keep_incompatibility]: never;
                        public get Status(): Unity.IO.LowLevel.Unsafe.FileStatus;
                        public get JobHandle(): Unity.Jobs.JobHandle;
                        public IsValid(): boolean;
                        public Close($dependency?: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                    }

                    class ReadHandle implements System.IDisposable {
                        protected [__keep_incompatibility]: never;
                        public get JobHandle(): Unity.Jobs.JobHandle;
                        public get Status(): Unity.IO.LowLevel.Unsafe.ReadStatus;
                        public get ReadCount(): bigint;
                        public IsValid(): boolean;
                        public Dispose(): void;
                        public Cancel(): void;
                        public GetBytesRead(): bigint;
                        public GetBytesRead($readCommandIndex: number): bigint;
                    }

                    class AsyncReadManager {
                        protected [__keep_incompatibility]: never;
                        public static Read($fileHandle: $Ref<Unity.IO.LowLevel.Unsafe.FileHandle>, $readCmdArray: Unity.IO.LowLevel.Unsafe.ReadCommandArray): Unity.IO.LowLevel.Unsafe.ReadHandle;
                        public static OpenFileAsync($fileName: string): Unity.IO.LowLevel.Unsafe.FileHandle;
                        public static CloseCachedFileAsync($fileName: string, $dependency?: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                    }

                    enum ProcessingState {
                        Unknown = 0,
                        InQueue = 1,
                        Reading = 2,
                        Completed = 3,
                        Failed = 4,
                        Canceled = 5
                    }

                    enum FileReadType {
                        Sync = 0,
                        Async = 1
                    }

                    class AsyncReadManagerRequestMetric {
                        protected [__keep_incompatibility]: never;
                        public get AssetName(): string;
                        public get FileName(): string;
                        public get OffsetBytes(): bigint;
                        public get SizeBytes(): bigint;
                        public get AssetTypeId(): bigint;
                        public get CurrentBytesRead(): bigint;
                        public get BatchReadCount(): number;
                        public get IsBatchRead(): boolean;
                        public get State(): Unity.IO.LowLevel.Unsafe.ProcessingState;
                        public get ReadType(): Unity.IO.LowLevel.Unsafe.FileReadType;
                        public get PriorityLevel(): Unity.IO.LowLevel.Unsafe.Priority;
                        public get Subsystem(): Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem;
                        public get RequestTimeMicroseconds(): number;
                        public get TimeInQueueMicroseconds(): number;
                        public get TotalTimeMicroseconds(): number;
                    }

                    class AsyncReadManagerMetrics {
                        protected [__keep_incompatibility]: never;
                        public static IsEnabled(): boolean;
                        public static ClearCompletedMetrics(): void;
                        public static GetMetrics($filters: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetricsFilters, $flags: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics.Flags): System.Array$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>;
                        public static GetMetrics($outMetrics: System.Collections.Generic.List$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>, $filters: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetricsFilters, $flags: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics.Flags): void;
                        public static GetMetrics($flags: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics.Flags): System.Array$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>;
                        public static GetMetrics($outMetrics: System.Collections.Generic.List$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>, $flags: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics.Flags): void;
                        public static StartCollectingMetrics(): void;
                        public static StopCollectingMetrics(): void;
                        public static GetCurrentSummaryMetrics($flags: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics.Flags): Unity.IO.LowLevel.Unsafe.AsyncReadManagerSummaryMetrics;
                        public static GetCurrentSummaryMetrics($metricsFilters: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetricsFilters, $flags: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetrics.Flags): Unity.IO.LowLevel.Unsafe.AsyncReadManagerSummaryMetrics;
                        public static GetSummaryOfMetrics($metrics: System.Array$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>): Unity.IO.LowLevel.Unsafe.AsyncReadManagerSummaryMetrics;
                        public static GetSummaryOfMetrics($metrics: System.Collections.Generic.List$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>): Unity.IO.LowLevel.Unsafe.AsyncReadManagerSummaryMetrics;
                        public static GetSummaryOfMetrics($metrics: System.Array$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>, $metricsFilters: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetricsFilters): Unity.IO.LowLevel.Unsafe.AsyncReadManagerSummaryMetrics;
                        public static GetSummaryOfMetrics($metrics: System.Collections.Generic.List$1<Unity.IO.LowLevel.Unsafe.AsyncReadManagerRequestMetric>, $metricsFilters: Unity.IO.LowLevel.Unsafe.AsyncReadManagerMetricsFilters): Unity.IO.LowLevel.Unsafe.AsyncReadManagerSummaryMetrics;
                        public static GetTotalSizeOfNonASRMReadsBytes($emptyAfterRead: boolean): bigint;
                    }
                    namespace AsyncReadManagerMetrics {
                        enum Flags {
                            None = 0,
                            ClearOnRead = 1
                        }

                    }

                    class AsyncReadManagerSummaryMetrics {
                        protected [__keep_incompatibility]: never;
                        public get TotalBytesRead(): bigint;
                        public get AverageBandwidthMBPerSecond(): number;
                        public get AverageReadSizeInBytes(): number;
                        public get AverageWaitTimeMicroseconds(): number;
                        public get AverageReadTimeMicroseconds(): number;
                        public get AverageTotalRequestTimeMicroseconds(): number;
                        public get AverageThroughputMBPerSecond(): number;
                        public get LongestWaitTimeMicroseconds(): number;
                        public get LongestReadTimeMicroseconds(): number;
                        public get LongestReadAssetType(): bigint;
                        public get LongestWaitAssetType(): bigint;
                        public get LongestReadSubsystem(): Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem;
                        public get LongestWaitSubsystem(): Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem;
                        public get NumberOfInProgressRequests(): number;
                        public get NumberOfCompletedRequests(): number;
                        public get NumberOfFailedRequests(): number;
                        public get NumberOfWaitingRequests(): number;
                        public get NumberOfCanceledRequests(): number;
                        public get TotalNumberOfRequests(): number;
                        public get NumberOfCachedReads(): number;
                        public get NumberOfAsyncReads(): number;
                        public get NumberOfSyncReads(): number;
                        constructor();
                    }

                    class AsyncReadManagerMetricsFilters {
                        protected [__keep_incompatibility]: never;
                        constructor();
                        constructor($typeID: bigint);
                        constructor($state: Unity.IO.LowLevel.Unsafe.ProcessingState);
                        constructor($readType: Unity.IO.LowLevel.Unsafe.FileReadType);
                        constructor($priorityLevel: Unity.IO.LowLevel.Unsafe.Priority);
                        constructor($subsystem: Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem);
                        constructor($typeIDs: System.Array$1<bigint>);
                        constructor($states: System.Array$1<Unity.IO.LowLevel.Unsafe.ProcessingState>);
                        constructor($readTypes: System.Array$1<Unity.IO.LowLevel.Unsafe.FileReadType>);
                        constructor($priorityLevels: System.Array$1<Unity.IO.LowLevel.Unsafe.Priority>);
                        constructor($subsystems: System.Array$1<Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem>);
                        constructor($typeIDs: System.Array$1<bigint>, $states: System.Array$1<Unity.IO.LowLevel.Unsafe.ProcessingState>, $readTypes: System.Array$1<Unity.IO.LowLevel.Unsafe.FileReadType>, $priorityLevels: System.Array$1<Unity.IO.LowLevel.Unsafe.Priority>, $subsystems: System.Array$1<Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem>);
                        public SetTypeIDFilter($_typeIDs: System.Array$1<bigint>): void;
                        public SetStateFilter($_states: System.Array$1<Unity.IO.LowLevel.Unsafe.ProcessingState>): void;
                        public SetReadTypeFilter($_readTypes: System.Array$1<Unity.IO.LowLevel.Unsafe.FileReadType>): void;
                        public SetPriorityFilter($_priorityLevels: System.Array$1<Unity.IO.LowLevel.Unsafe.Priority>): void;
                        public SetSubsystemFilter($_subsystems: System.Array$1<Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem>): void;
                        public SetTypeIDFilter($_typeID: bigint): void;
                        public SetStateFilter($_state: Unity.IO.LowLevel.Unsafe.ProcessingState): void;
                        public SetReadTypeFilter($_readType: Unity.IO.LowLevel.Unsafe.FileReadType): void;
                        public SetPriorityFilter($_priorityLevel: Unity.IO.LowLevel.Unsafe.Priority): void;
                        public SetSubsystemFilter($_subsystem: Unity.IO.LowLevel.Unsafe.AssetLoadingSubsystem): void;
                        public RemoveTypeIDFilter(): void;
                        public RemoveStateFilter(): void;
                        public RemoveReadTypeFilter(): void;
                        public RemovePriorityFilter(): void;
                        public RemoveSubsystemFilter(): void;
                        public ClearFilters(): void;
                    }

                    class VirtualFileSystem {
                        protected [__keep_incompatibility]: never;
                        public static GetLocalFileSystemName($vfsFileName: string, $localFileName: $Out<string>, $localFileOffset: $Out<bigint>, $localFileSize: $Out<bigint>): boolean;
                    }

                }
            }
        }
    }
    namespace Unity {
        namespace Jobs {
            interface IJob {
                Execute(): void;
            }

            class IJobExtensions {
                protected [__keep_incompatibility]: never;
                public static EarlyJobInit<T extends Unity.Jobs.IJob>(): void;
                public static Schedule<T extends Unity.Jobs.IJob>($dependsOn?: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public static Run<T extends Unity.Jobs.IJob>(): void;
                public static ScheduleByRef<T extends Unity.Jobs.IJob>($dependsOn?: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public static RunByRef<T extends Unity.Jobs.IJob>(): void;
            }

            interface IJobFor {
                Execute($index: number): void;
            }

            class IJobForExtensions {
                protected [__keep_incompatibility]: never;
                public static EarlyJobInit<T extends Unity.Jobs.IJobFor>(): void;
                public static Schedule<T extends Unity.Jobs.IJobFor>($arrayLength: number, $dependency: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public static ScheduleParallel<T extends Unity.Jobs.IJobFor>($arrayLength: number, $innerloopBatchCount: number, $dependency: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public static Run<T extends Unity.Jobs.IJobFor>($arrayLength: number): void;
                public static ScheduleByRef<T extends Unity.Jobs.IJobFor>($arrayLength: number, $dependency: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public static ScheduleParallelByRef<T extends Unity.Jobs.IJobFor>($arrayLength: number, $innerloopBatchCount: number, $dependency: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public static RunByRef<T extends Unity.Jobs.IJobFor>($arrayLength: number): void;
            }

            interface IJobParallelFor {
                Execute($index: number): void;
            }

            class IJobParallelForExtensions {
                protected [__keep_incompatibility]: never;
                public static EarlyJobInit<T extends Unity.Jobs.IJobParallelFor>(): void;
                public static Schedule<T extends Unity.Jobs.IJobParallelFor>($arrayLength: number, $innerloopBatchCount: number, $dependsOn?: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public static Run<T extends Unity.Jobs.IJobParallelFor>($arrayLength: number): void;
                public static ScheduleByRef<T extends Unity.Jobs.IJobParallelFor>($arrayLength: number, $innerloopBatchCount: number, $dependsOn?: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public static RunByRef<T extends Unity.Jobs.IJobParallelFor>($arrayLength: number): void;
            }

            class JobHandle implements System.IEquatable$1<Unity.Jobs.JobHandle> {
                protected [__keep_incompatibility]: never;
                public get IsCompleted(): boolean;
                public Complete(): void;
                public static CompleteAll($job0: $Ref<Unity.Jobs.JobHandle>, $job1: $Ref<Unity.Jobs.JobHandle>): void;
                public static CompleteAll($job0: $Ref<Unity.Jobs.JobHandle>, $job1: $Ref<Unity.Jobs.JobHandle>, $job2: $Ref<Unity.Jobs.JobHandle>): void;
                public static CompleteAll($jobs: Unity.Collections.NativeArray$1<Unity.Jobs.JobHandle>): void;
                public static ScheduleBatchedJobs(): void;
                public static CombineDependencies($job0: Unity.Jobs.JobHandle, $job1: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public static CombineDependencies($job0: Unity.Jobs.JobHandle, $job1: Unity.Jobs.JobHandle, $job2: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public static CombineDependencies($jobs: Unity.Collections.NativeArray$1<Unity.Jobs.JobHandle>): Unity.Jobs.JobHandle;
                public static CombineDependencies($jobs: Unity.Collections.NativeSlice$1<Unity.Jobs.JobHandle>): Unity.Jobs.JobHandle;
                public static CheckFenceIsDependencyOrDidSyncFence($jobHandle: Unity.Jobs.JobHandle, $dependsOn: Unity.Jobs.JobHandle): boolean;
                public Equals($other: Unity.Jobs.JobHandle): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

        }
    }
    namespace Unity {
        namespace Jobs {
            namespace LowLevel {
                namespace Unsafe {
                    class BatchQueryJob<CommandT, ResultT> {
                        protected [__keep_incompatibility]: never;
                        constructor($commands: Unity.Collections.NativeArray$1<CommandT>, $results: Unity.Collections.NativeArray$1<ResultT>);
                    }

                    class BatchQueryJobStruct<T> {
                        protected [__keep_incompatibility]: never;
                        public static Initialize(): number;
                    }

                    class JobHandleUnsafeUtility {
                        protected [__keep_incompatibility]: never;
                    }

                    class JobProducerTypeAttribute extends System.Attribute {
                        protected [__keep_incompatibility]: never;
                        public get ProducerType(): System.Type;
                        constructor($producerType: System.Type);
                    }

                    class JobRanges {
                        protected [__keep_incompatibility]: never;
                        public TotalIterationCount: number;
                    }

                    enum ScheduleMode {
                        Run = 0,
                        Batched = 1,
                        Parallel = 1,
                        Single = 2
                    }

                    enum JobType {
                        Single = 0,
                        ParallelFor = 1
                    }

                    class JobsUtility {
                        protected [__keep_incompatibility]: never;
                        public static readonly MaxJobThreadCount: number;
                        public static readonly CacheLineSize: number;
                        public static get IsExecutingJob(): boolean;
                        public static JobDebuggerEnabled: boolean;
                        public static JobCompilerEnabled: boolean;
                        public static get JobWorkerMaximumCount(): number;
                        public static JobWorkerCount: number;
                        public static get ThreadIndex(): number;
                        public static get ThreadIndexCount(): number;
                        public static GetJobRange($ranges: $Ref<Unity.Jobs.LowLevel.Unsafe.JobRanges>, $jobIndex: number, $beginIndex: $Out<number>, $endIndex: $Out<number>): void;
                        public static GetWorkStealingRange($ranges: $Ref<Unity.Jobs.LowLevel.Unsafe.JobRanges>, $jobIndex: number, $beginIndex: $Out<number>, $endIndex: $Out<number>): boolean;
                        public static Schedule($parameters: $Ref<Unity.Jobs.LowLevel.Unsafe.JobsUtility.JobScheduleParameters>): Unity.Jobs.JobHandle;
                        public static ScheduleParallelFor($parameters: $Ref<Unity.Jobs.LowLevel.Unsafe.JobsUtility.JobScheduleParameters>, $arrayLength: number, $innerloopBatchCount: number): Unity.Jobs.JobHandle;
                        public static ScheduleParallelForTransform($parameters: $Ref<Unity.Jobs.LowLevel.Unsafe.JobsUtility.JobScheduleParameters>, $transfromAccesssArray: number): Unity.Jobs.JobHandle;
                        public static ScheduleParallelForTransformReadOnly($parameters: $Ref<Unity.Jobs.LowLevel.Unsafe.JobsUtility.JobScheduleParameters>, $transfromAccesssArray: number, $innerloopBatchCount: number): Unity.Jobs.JobHandle;
                        public static CreateJobReflectionData($type: System.Type, $jobType: Unity.Jobs.LowLevel.Unsafe.JobType, $managedJobFunction0: any, $managedJobFunction1?: any, $managedJobFunction2?: any): number;
                        public static CreateJobReflectionData($type: System.Type, $managedJobFunction0: any, $managedJobFunction1?: any, $managedJobFunction2?: any): number;
                        public static CreateJobReflectionData($wrapperJobType: System.Type, $userJobType: System.Type, $jobType: Unity.Jobs.LowLevel.Unsafe.JobType, $managedJobFunction0: any): number;
                        public static CreateJobReflectionData($wrapperJobType: System.Type, $userJobType: System.Type, $managedJobFunction0: any): number;
                        public static ResetJobWorkerCount(): void;
                    }
                    namespace JobsUtility {
                        class JobScheduleParameters {
                            protected [__keep_incompatibility]: never;
                            public Dependency: Unity.Jobs.JobHandle;
                            public ScheduleMode: number;
                            public ReflectionData: number;
                            public JobDataPtr: number;
                        }

                    }

                }
            }
        }
    }
    namespace Unity {
        namespace Profiling {
            class IgnoredByDeepProfilerAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class ProfilerCategory {
                protected [__keep_incompatibility]: never;
                public get Name(): string;
                public get Color(): UnityEngine.Color32;
                public static get Render(): Unity.Profiling.ProfilerCategory;
                public static get Scripts(): Unity.Profiling.ProfilerCategory;
                public static get Gui(): Unity.Profiling.ProfilerCategory;
                public static get Physics(): Unity.Profiling.ProfilerCategory;
                public static get Physics2D(): Unity.Profiling.ProfilerCategory;
                public static get Animation(): Unity.Profiling.ProfilerCategory;
                public static get Ai(): Unity.Profiling.ProfilerCategory;
                public static get Audio(): Unity.Profiling.ProfilerCategory;
                public static get Video(): Unity.Profiling.ProfilerCategory;
                public static get Particles(): Unity.Profiling.ProfilerCategory;
                public static get Lighting(): Unity.Profiling.ProfilerCategory;
                public static get Network(): Unity.Profiling.ProfilerCategory;
                public static get Loading(): Unity.Profiling.ProfilerCategory;
                public static get Vr(): Unity.Profiling.ProfilerCategory;
                public static get Input(): Unity.Profiling.ProfilerCategory;
                public static get Memory(): Unity.Profiling.ProfilerCategory;
                public static get VirtualTexturing(): Unity.Profiling.ProfilerCategory;
                public static get FileIO(): Unity.Profiling.ProfilerCategory;
                public static get Internal(): Unity.Profiling.ProfilerCategory;
                constructor($categoryName: string);
                constructor($categoryName: string, $color: Unity.Profiling.ProfilerCategoryColor);
                public ToString(): string;
            }

            enum ProfilerCategoryFlags {
                None = 0,
                Builtin = 1
            }

            enum ProfilerCategoryColor {
                Render = 0,
                Scripts = 1,
                BurstJobs = 2,
                Other = 3,
                Physics = 4,
                Animation = 5,
                Audio = 6,
                AudioJob = 7,
                AudioUpdateJob = 8,
                Lighting = 9,
                GC = 10,
                VSync = 11,
                Memory = 12,
                Internal = 13,
                UI = 14,
                Build = 15,
                Input = 16
            }

            class ProfilerMarker {
                protected [__keep_incompatibility]: never;
                public get Handle(): number;
                constructor($name: string);
                constructor($category: Unity.Profiling.ProfilerCategory, $name: string);
                constructor($name: string, $flags: Unity.Profiling.LowLevel.MarkerFlags);
                constructor($category: Unity.Profiling.ProfilerCategory, $name: string, $flags: Unity.Profiling.LowLevel.MarkerFlags);
                public Begin(): void;
                public Begin($contextUnityObject: UnityEngine.Object): void;
                public End(): void;
                public Auto(): Unity.Profiling.ProfilerMarker.AutoScope;
            }
            namespace ProfilerMarker {
                class AutoScope implements System.IDisposable {
                    protected [__keep_incompatibility]: never;
                    public Dispose(): void;
                }

            }

            enum ProfilerFlowEventType {
                Begin = 0,
                ParallelNext = 1,
                End = 2,
                Next = 3
            }

            enum ProfilerMarkerDataUnit {
                Undefined = 0,
                TimeNanoseconds = 1,
                Bytes = 2,
                Count = 3,
                Percent = 4,
                FrequencyHz = 5
            }

            enum ProfilerCounterOptions {
                None = 0,
                FlushOnEndOfFrame = 2,
                ResetToZeroOnFlush = 4
            }

            enum ProfilerRecorderOptions {
                None = 0,
                StartImmediately = 1,
                KeepAliveDuringDomainReload = 2,
                CollectOnlyOnCurrentThread = 4,
                WrapAroundWhenCapacityReached = 8,
                SumAllSamplesInFrame = 16,
                Default = 24,
                GpuRecorder = 64
            }

            class ProfilerRecorderSample {
                protected [__keep_incompatibility]: never;
                public get Value(): bigint;
                public get Count(): bigint;
            }

            class ProfilerRecorder implements System.IDisposable {
                protected [__keep_incompatibility]: never;
                public get Valid(): boolean;
                public get DataType(): Unity.Profiling.LowLevel.ProfilerMarkerDataType;
                public get UnitType(): Unity.Profiling.ProfilerMarkerDataUnit;
                public get CurrentValue(): bigint;
                public get CurrentValueAsDouble(): number;
                public get LastValue(): bigint;
                public get LastValueAsDouble(): number;
                public get Capacity(): number;
                public get Count(): number;
                public get IsRunning(): boolean;
                public get WrappedAround(): boolean;
                constructor($statName: string, $capacity?: number, $options?: Unity.Profiling.ProfilerRecorderOptions);
                constructor($categoryName: string, $statName: string, $capacity?: number, $options?: Unity.Profiling.ProfilerRecorderOptions);
                constructor($category: Unity.Profiling.ProfilerCategory, $statName: string, $capacity?: number, $options?: Unity.Profiling.ProfilerRecorderOptions);
                constructor($marker: Unity.Profiling.ProfilerMarker, $capacity?: number, $options?: Unity.Profiling.ProfilerRecorderOptions);
                constructor($statHandle: Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderHandle, $capacity?: number, $options?: Unity.Profiling.ProfilerRecorderOptions);
                public static StartNew($category: Unity.Profiling.ProfilerCategory, $statName: string, $capacity?: number, $options?: Unity.Profiling.ProfilerRecorderOptions): Unity.Profiling.ProfilerRecorder;
                public static StartNew($marker: Unity.Profiling.ProfilerMarker, $capacity?: number, $options?: Unity.Profiling.ProfilerRecorderOptions): Unity.Profiling.ProfilerRecorder;
                public Start(): void;
                public Stop(): void;
                public Reset(): void;
                public GetSample($index: number): Unity.Profiling.ProfilerRecorderSample;
                public CopyTo($outSamples: System.Collections.Generic.List$1<Unity.Profiling.ProfilerRecorderSample>, $reset?: boolean): void;
                public ToArray(): System.Array$1<Unity.Profiling.ProfilerRecorderSample>;
                public Dispose(): void;
            }

            class DebugScreenCapture {
                protected [__keep_incompatibility]: never;
                public RawImageDataReference: Unity.Collections.NativeArray$1<number>;
                public ImageFormat: UnityEngine.TextureFormat;
                public Width: number;
                public Height: number;
            }

        }
    }
    namespace Unity {
        namespace Profiling {
            namespace LowLevel {
                enum MarkerFlags {
                    Default = 0,
                    Script = 2,
                    AvailabilityEditor = 4,
                    AvailabilityNonDevelopment = 8,
                    Warning = 16,
                    ScriptInvoke = 32,
                    ScriptDeepProfiler = 64,
                    Counter = 128,
                    SampleGPU = 256,
                    VerbosityDebug = 1024,
                    VerbosityInternal = 2048,
                    VerbosityExternal = 3072,
                    VerbosityAdvanced = 4096
                }

                enum ProfilerMarkerDataType {
                    InstanceId = 1,
                    Int32 = 2,
                    UInt32 = 3,
                    Int64 = 4,
                    UInt64 = 5,
                    Float = 6,
                    Double = 7,
                    String16 = 9,
                    Blob8 = 11,
                    GfxResourceId = 12
                }

            }
        }
    }
    namespace Unity {
        namespace Profiling {
            namespace LowLevel {
                namespace Unsafe {
                    class ProfilerRecorderDescription {
                        protected [__keep_incompatibility]: never;
                        public get Category(): Unity.Profiling.ProfilerCategory;
                        public get Flags(): Unity.Profiling.LowLevel.MarkerFlags;
                        public get DataType(): Unity.Profiling.LowLevel.ProfilerMarkerDataType;
                        public get UnitType(): Unity.Profiling.ProfilerMarkerDataUnit;
                        public get NameUtf8Len(): number;
                        public get Name(): string;
                    }

                    class ProfilerRecorderHandle {
                        protected [__keep_incompatibility]: never;
                        public get Valid(): boolean;
                        public static GetDescription($handle: Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderHandle): Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderDescription;
                        public static GetAvailable($outRecorderHandleList: System.Collections.Generic.List$1<Unity.Profiling.LowLevel.Unsafe.ProfilerRecorderHandle>): void;
                    }

                    class ProfilerMarkerData {
                        protected [__keep_incompatibility]: never;
                        public Type: number;
                        public Size: number;
                    }

                    class ProfilerCategoryDescription {
                        protected [__keep_incompatibility]: never;
                        public readonly Id: number;
                        public readonly Flags: number;
                        public readonly Color: UnityEngine.Color32;
                        public readonly NameUtf8Len: number;
                        public get Name(): string;
                    }

                    class ProfilerUnsafeUtility {
                        protected [__keep_incompatibility]: never;
                        public static readonly CategoryRender: number;
                        public static readonly CategoryScripts: number;
                        public static readonly CategoryGUI: number;
                        public static readonly CategoryPhysics: number;
                        public static readonly CategoryAnimation: number;
                        public static readonly CategoryAi: number;
                        public static readonly CategoryAudio: number;
                        public static readonly CategoryVideo: number;
                        public static readonly CategoryParticles: number;
                        public static readonly CategoryLighting: number;
                        public static readonly CategoryLightning: number;
                        public static readonly CategoryNetwork: number;
                        public static readonly CategoryLoading: number;
                        public static readonly CategoryOther: number;
                        public static readonly CategoryVr: number;
                        public static readonly CategoryAllocation: number;
                        public static readonly CategoryInternal: number;
                        public static readonly CategoryFileIO: number;
                        public static readonly CategoryInput: number;
                        public static readonly CategoryVirtualTexturing: number;
                        public static readonly CategoryPhysics2D: number;
                        public static get Timestamp(): bigint;
                        public static get TimestampToNanosecondsConversionRatio(): Unity.Profiling.LowLevel.Unsafe.ProfilerUnsafeUtility.TimestampConversionRatio;
                        public static GetCategoryDescription($categoryId: number): Unity.Profiling.LowLevel.Unsafe.ProfilerCategoryDescription;
                        public static CreateMarker($name: string, $categoryId: number, $flags: Unity.Profiling.LowLevel.MarkerFlags, $metadataCount: number): number;
                        public static SetMarkerMetadata($markerPtr: number, $index: number, $name: string, $type: number, $unit: number): void;
                        public static BeginSample($markerPtr: number): void;
                        public static EndSample($markerPtr: number): void;
                        public static CreateFlow($categoryId: number): number;
                        public static FlowEvent($flowId: number, $flowEventType: Unity.Profiling.ProfilerFlowEventType): void;
                    }
                    namespace ProfilerUnsafeUtility {
                        class TimestampConversionRatio {
                            protected [__keep_incompatibility]: never;
                            public Numerator: bigint;
                            public Denominator: bigint;
                        }

                    }

                }
            }
        }
    }
    namespace Unity {
        namespace Profiling {
            namespace Memory {
                enum CaptureFlags {
                    ManagedObjects = 1,
                    NativeObjects = 2,
                    NativeAllocations = 4,
                    NativeAllocationSites = 8,
                    NativeStackTraces = 16
                }

                class MemorySnapshotMetadata {
                    protected [__keep_incompatibility]: never;
                    public Description: string;
                    constructor();
                }

                class MemoryProfiler {
                    protected [__keep_incompatibility]: never;
                    public static TakeSnapshot($path: string, $finishCallback: System.Action$2<string, boolean>, $captureFlags?: Unity.Profiling.Memory.CaptureFlags): void;
                    public static TakeSnapshot($path: string, $finishCallback: System.Action$2<string, boolean>, $screenshotCallback: System.Action$3<string, boolean, Unity.Profiling.DebugScreenCapture>, $captureFlags?: Unity.Profiling.Memory.CaptureFlags): void;
                    public static TakeTempSnapshot($finishCallback: System.Action$2<string, boolean>, $captureFlags?: Unity.Profiling.Memory.CaptureFlags): void;
                    public static add_CreatingMetadata(handler: System.Action$1<Unity.Profiling.Memory.MemorySnapshotMetadata>): void;
                    public static remove_CreatingMetadata(handler: System.Action$1<Unity.Profiling.Memory.MemorySnapshotMetadata>): void;
                }

            }
        }
    }
    namespace UnityEditor {
        namespace Experimental {
            class RenderSettings {
                protected [__keep_incompatibility]: never;
                constructor();
            }

        }
    }
    namespace UnityEngine {
        enum SpriteDrawMode {
            Simple = 0,
            Sliced = 1,
            Tiled = 2
        }

        enum SpriteTileMode {
            Continuous = 0,
            Adaptive = 1
        }

        enum SpriteMaskInteraction {
            None = 0,
            VisibleInsideMask = 1,
            VisibleOutsideMask = 2
        }

        class SpriteRenderer extends UnityEngine.Renderer {
            protected [__keep_incompatibility]: never;
            public sprite: UnityEngine.Sprite;
            public drawMode: UnityEngine.SpriteDrawMode;
            public size: UnityEngine.Vector2;
            public adaptiveModeThreshold: number;
            public tileMode: UnityEngine.SpriteTileMode;
            public color: UnityEngine.Color;
            public maskInteraction: UnityEngine.SpriteMaskInteraction;
            public flipX: boolean;
            public flipY: boolean;
            public spriteSortPoint: UnityEngine.SpriteSortPoint;
            constructor();
            public RegisterSpriteChangeCallback($callback: UnityEngine.Events.UnityAction$1<UnityEngine.SpriteRenderer>): void;
            public UnregisterSpriteChangeCallback($callback: UnityEngine.Events.UnityAction$1<UnityEngine.SpriteRenderer>): void;
        }

        enum SpriteMeshType {
            FullRect = 0,
            Tight = 1
        }

        enum SpriteAlignment {
            Center = 0,
            TopLeft = 1,
            TopCenter = 2,
            TopRight = 3,
            LeftCenter = 4,
            RightCenter = 5,
            BottomLeft = 6,
            BottomCenter = 7,
            BottomRight = 8,
            Custom = 9
        }

        enum SpritePackingMode {
            Tight = 0,
            Rectangle = 1
        }

        enum SpritePackingRotation {
            None = 0,
            FlipHorizontal = 1,
            FlipVertical = 2,
            Rotate180 = 3,
            Any = 15
        }

        enum SpriteSortPoint {
            Center = 0,
            Pivot = 1
        }

        class SecondarySpriteTexture implements System.IEquatable$1<UnityEngine.SecondarySpriteTexture> {
            protected [__keep_incompatibility]: never;
            public name: string;
            public texture: UnityEngine.Texture2D;
            public Equals($other: UnityEngine.SecondarySpriteTexture): boolean;
            public Equals($obj: any): boolean;
            public GetHashCode(): number;
        }

        class Sprite extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public get bounds(): UnityEngine.Bounds;
            public get rect(): UnityEngine.Rect;
            public get border(): UnityEngine.Vector4;
            public get texture(): UnityEngine.Texture2D;
            public get pixelsPerUnit(): number;
            public get spriteAtlasTextureScale(): number;
            public get associatedAlphaSplitTexture(): UnityEngine.Texture2D;
            public get pivot(): UnityEngine.Vector2;
            public get packed(): boolean;
            public get packingMode(): UnityEngine.SpritePackingMode;
            public get packingRotation(): UnityEngine.SpritePackingRotation;
            public get textureRect(): UnityEngine.Rect;
            public get textureRectOffset(): UnityEngine.Vector2;
            public get vertices(): System.Array$1<UnityEngine.Vector2>;
            public get triangles(): System.Array$1<number>;
            public get uv(): System.Array$1<UnityEngine.Vector2>;
            public GetSecondaryTextureCount(): number;
            public GetSecondaryTextures($secondaryTexture: System.Array$1<UnityEngine.SecondarySpriteTexture>): number;
            public GetPhysicsShapeCount(): number;
            public GetScriptableObjectsCount(): number;
            public GetScriptableObjects($scriptableObjects: System.Array$1<UnityEngine.ScriptableObject>): number;
            public AddScriptableObject($obj: UnityEngine.ScriptableObject): boolean;
            public RemoveScriptableObjectAt($i: number): boolean;
            public SetScriptableObjectAt($obj: UnityEngine.ScriptableObject, $i: number): boolean;
            public GetPhysicsShapePointCount($shapeIdx: number): number;
            public GetPhysicsShape($shapeIdx: number, $physicsShape: System.Collections.Generic.List$1<UnityEngine.Vector2>): number;
            public GetPhysicsShape($shapeIdx: number): System.ReadOnlySpan$1<UnityEngine.Vector2>;
            public OverridePhysicsShape($physicsShapes: System.Collections.Generic.IList$1<System.Array$1<UnityEngine.Vector2>>): void;
            public OverrideGeometry($vertices: System.Array$1<UnityEngine.Vector2>, $triangles: System.Array$1<number>): void;
            public static Create($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: UnityEngine.SpriteMeshType, $border: UnityEngine.Vector4, $generateFallbackPhysicsShape: boolean): UnityEngine.Sprite;
            public static Create($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: UnityEngine.SpriteMeshType, $border: UnityEngine.Vector4, $generateFallbackPhysicsShape: boolean, $secondaryTextures: System.Array$1<UnityEngine.SecondarySpriteTexture>): UnityEngine.Sprite;
            public static Create($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: UnityEngine.SpriteMeshType, $border: UnityEngine.Vector4): UnityEngine.Sprite;
            public static Create($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number, $meshType: UnityEngine.SpriteMeshType): UnityEngine.Sprite;
            public static Create($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number, $extrude: number): UnityEngine.Sprite;
            public static Create($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2, $pixelsPerUnit: number): UnityEngine.Sprite;
            public static Create($texture: UnityEngine.Texture2D, $rect: UnityEngine.Rect, $pivot: UnityEngine.Vector2): UnityEngine.Sprite;
        }

        class SortingLayer {
            protected [__keep_incompatibility]: never;
            public static onLayerAdded: UnityEngine.SortingLayer.LayerCallback;
            public static onLayerRemoved: UnityEngine.SortingLayer.LayerCallback;
            public get id(): number;
            public get name(): string;
            public get value(): number;
            public static get layers(): System.Array$1<UnityEngine.SortingLayer>;
            public static GetLayerValueFromID($id: number): number;
            public static GetLayerValueFromName($name: string): number;
            public static NameToID($name: string): number;
            public static IDToName($id: number): string;
            public static IsValid($id: number): boolean;
        }
        namespace SortingLayer {
            interface LayerCallback {
                ($layer: UnityEngine.SortingLayer): void;
                Invoke?: ($layer: UnityEngine.SortingLayer) => void;
            }
            var LayerCallback: { new (func: ($layer: UnityEngine.SortingLayer) => void): LayerCallback; };

        }

        enum WeightedMode {
            None = 0,
            In = 1,
            Out = 2,
            Both = 3
        }

        class Keyframe {
            protected [__keep_incompatibility]: never;
            public time: number;
            public value: number;
            public inTangent: number;
            public outTangent: number;
            public inWeight: number;
            public outWeight: number;
            public weightedMode: UnityEngine.WeightedMode;
            public tangentMode: number;
            constructor($time: number, $value: number);
            constructor($time: number, $value: number, $inTangent: number, $outTangent: number);
            constructor($time: number, $value: number, $inTangent: number, $outTangent: number, $inWeight: number, $outWeight: number);
        }

        enum WrapMode {
            Default = 0,
            Once = 1,
            Clamp = 1,
            Loop = 2,
            PingPong = 4,
            ClampForever = 8
        }

        class AnimationCurve implements System.IEquatable$1<UnityEngine.AnimationCurve> {
            protected [__keep_incompatibility]: never;
            public keys: System.Array$1<UnityEngine.Keyframe>;
            public get length(): number;
            public preWrapMode: UnityEngine.WrapMode;
            public postWrapMode: UnityEngine.WrapMode;
            constructor(...keys: UnityEngine.Keyframe[]);
            constructor();
            public Evaluate($time: number): number;
            public AddKey($time: number, $value: number): number;
            public AddKey($key: UnityEngine.Keyframe): number;
            public MoveKey($index: number, $key: UnityEngine.Keyframe): number;
            public ClearKeys(): void;
            public RemoveKey($index: number): void;
            public GetKeys($keys: System.Span$1<UnityEngine.Keyframe>): void;
            public SetKeys($keys: System.ReadOnlySpan$1<UnityEngine.Keyframe>): void;
            public GetHashCode(): number;
            public SmoothTangents($index: number, $weight: number): void;
            public static Constant($timeStart: number, $timeEnd: number, $value: number): UnityEngine.AnimationCurve;
            public static Linear($timeStart: number, $valueStart: number, $timeEnd: number, $valueEnd: number): UnityEngine.AnimationCurve;
            public static EaseInOut($timeStart: number, $valueStart: number, $timeEnd: number, $valueEnd: number): UnityEngine.AnimationCurve;
            public Equals($o: any): boolean;
            public Equals($other: UnityEngine.AnimationCurve): boolean;
            public CopyFrom($other: UnityEngine.AnimationCurve): void;
            public get_Item($index: number): UnityEngine.Keyframe;
        }

        class Application {
            protected [__keep_incompatibility]: never;
            public static get isLoadingLevel(): boolean;
            public static get streamedBytes(): number;
            public static get isPlaying(): boolean;
            public static get isFocused(): boolean;
            public static get buildGUID(): string;
            public static runInBackground: boolean;
            public static get isBatchMode(): boolean;
            public static get dataPath(): string;
            public static get streamingAssetsPath(): string;
            public static get persistentDataPath(): string;
            public static get temporaryCachePath(): string;
            public static get absoluteURL(): string;
            public static get unityVersion(): string;
            public static get version(): string;
            public static get installerName(): string;
            public static get identifier(): string;
            public static get installMode(): UnityEngine.ApplicationInstallMode;
            public static get sandboxType(): UnityEngine.ApplicationSandboxType;
            public static get productName(): string;
            public static get companyName(): string;
            public static get cloudProjectId(): string;
            public static targetFrameRate: number;
            public static stackTraceLogType: UnityEngine.StackTraceLogType;
            public static get consoleLogPath(): string;
            public static backgroundLoadingPriority: UnityEngine.ThreadPriority;
            public static get genuine(): boolean;
            public static get genuineCheckAvailable(): boolean;
            public static get isShowingSplashScreen(): boolean;
            public static get platform(): UnityEngine.RuntimePlatform;
            public static get isMobilePlatform(): boolean;
            public static get isConsolePlatform(): boolean;
            public static get systemLanguage(): UnityEngine.SystemLanguage;
            public static get internetReachability(): UnityEngine.NetworkReachability;
            public static get isPlayer(): boolean;
            public static get exitCancellationToken(): System.Threading.CancellationToken;
            public static get levelCount(): number;
            public static get loadedLevel(): number;
            public static get loadedLevelName(): string;
            public static get isEditor(): boolean;
            constructor();
            public static Quit($exitCode: number): void;
            public static Quit(): void;
            public static CancelQuit(): void;
            public static Unload(): void;
            public static GetStreamProgressForLevel($levelIndex: number): number;
            public static GetStreamProgressForLevel($levelName: string): number;
            public static CanStreamedLevelBeLoaded($levelIndex: number): boolean;
            public static CanStreamedLevelBeLoaded($levelName: string): boolean;
            public static IsPlaying($obj: UnityEngine.Object): boolean;
            public static GetBuildTags(): System.Array$1<string>;
            public static SetBuildTags($buildTags: System.Array$1<string>): void;
            public static HasProLicense(): boolean;
            public static ExternalEval($script: string): void;
            public static RequestAdvertisingIdentifierAsync($delegateMethod: UnityEngine.Application.AdvertisingIdentifierCallback): boolean;
            public static OpenURL($url: string): void;
            public static ForceCrash($mode: number): void;
            public static GetStackTraceLogType($logType: UnityEngine.LogType): UnityEngine.StackTraceLogType;
            public static SetStackTraceLogType($logType: UnityEngine.LogType, $stackTraceType: UnityEngine.StackTraceLogType): void;
            public static RequestUserAuthorization($mode: UnityEngine.UserAuthorization): UnityEngine.AsyncOperation;
            public static HasUserAuthorization($mode: UnityEngine.UserAuthorization): boolean;
            public static ExternalCall($functionName: string, ...args: any[]): void;
            public static DontDestroyOnLoad($o: UnityEngine.Object): void;
            public static RegisterLogCallback($handler: UnityEngine.Application.LogCallback): void;
            public static RegisterLogCallbackThreaded($handler: UnityEngine.Application.LogCallback): void;
            public static LoadLevel($index: number): void;
            public static LoadLevel($name: string): void;
            public static LoadLevelAdditive($index: number): void;
            public static LoadLevelAdditive($name: string): void;
            public static LoadLevelAsync($index: number): UnityEngine.AsyncOperation;
            public static LoadLevelAsync($levelName: string): UnityEngine.AsyncOperation;
            public static LoadLevelAdditiveAsync($index: number): UnityEngine.AsyncOperation;
            public static LoadLevelAdditiveAsync($levelName: string): UnityEngine.AsyncOperation;
            public static UnloadLevel($index: number): boolean;
            public static UnloadLevel($scenePath: string): boolean;
            public static add_lowMemory(handler: UnityEngine.Application.LowMemoryCallback): void;
            public static remove_lowMemory(handler: UnityEngine.Application.LowMemoryCallback): void;
            public static add_memoryUsageChanged(handler: UnityEngine.Application.MemoryUsageChangedCallback): void;
            public static remove_memoryUsageChanged(handler: UnityEngine.Application.MemoryUsageChangedCallback): void;
            public static add_logMessageReceived(handler: UnityEngine.Application.LogCallback): void;
            public static remove_logMessageReceived(handler: UnityEngine.Application.LogCallback): void;
            public static add_logMessageReceivedThreaded(handler: UnityEngine.Application.LogCallback): void;
            public static remove_logMessageReceivedThreaded(handler: UnityEngine.Application.LogCallback): void;
            public static add_onBeforeRender(handler: UnityEngine.Events.UnityAction): void;
            public static remove_onBeforeRender(handler: UnityEngine.Events.UnityAction): void;
            public static add_focusChanged(handler: System.Action$1<boolean>): void;
            public static remove_focusChanged(handler: System.Action$1<boolean>): void;
            public static add_deepLinkActivated(handler: System.Action$1<string>): void;
            public static remove_deepLinkActivated(handler: System.Action$1<string>): void;
            public static add_wantsToQuit(handler: System.Func$1<boolean>): void;
            public static remove_wantsToQuit(handler: System.Func$1<boolean>): void;
            public static add_quitting(handler: System.Action): void;
            public static remove_quitting(handler: System.Action): void;
            public static add_unloading(handler: System.Action): void;
            public static remove_unloading(handler: System.Action): void;
        }
        namespace Application {
            interface AdvertisingIdentifierCallback {
                ($advertisingId: string, $trackingEnabled: boolean, $errorMsg: string): void;
                Invoke?: ($advertisingId: string, $trackingEnabled: boolean, $errorMsg: string) => void;
            }
            var AdvertisingIdentifierCallback: { new (func: ($advertisingId: string, $trackingEnabled: boolean, $errorMsg: string) => void): AdvertisingIdentifierCallback; };

            interface LowMemoryCallback {
                (): void;
                Invoke?: () => void;
            }
            var LowMemoryCallback: { new (func: () => void): LowMemoryCallback; };

            interface MemoryUsageChangedCallback {
                ($usage: $Ref<UnityEngine.ApplicationMemoryUsageChange>): void;
                Invoke?: ($usage: $Ref<UnityEngine.ApplicationMemoryUsageChange>) => void;
            }
            var MemoryUsageChangedCallback: { new (func: ($usage: $Ref<UnityEngine.ApplicationMemoryUsageChange>) => void): MemoryUsageChangedCallback; };

            interface LogCallback {
                ($condition: string, $stackTrace: string, $type: UnityEngine.LogType): void;
                Invoke?: ($condition: string, $stackTrace: string, $type: UnityEngine.LogType) => void;
            }
            var LogCallback: { new (func: ($condition: string, $stackTrace: string, $type: UnityEngine.LogType) => void): LogCallback; };

        }

        enum ApplicationMemoryUsage {
            Unknown = 0,
            Low = 1,
            Medium = 2,
            High = 3,
            Critical = 4
        }

        class ApplicationMemoryUsageChange {
            protected [__keep_incompatibility]: never;
            public get memoryUsage(): UnityEngine.ApplicationMemoryUsage;
            constructor($usage: UnityEngine.ApplicationMemoryUsage);
        }

        enum StackTraceLogType {
            None = 0,
            ScriptOnly = 1,
            Full = 2
        }

        enum NetworkReachability {
            NotReachable = 0,
            ReachableViaCarrierDataNetwork = 1,
            ReachableViaLocalAreaNetwork = 2
        }

        enum UserAuthorization {
            WebCam = 1,
            Microphone = 2
        }

        enum ApplicationInstallMode {
            Unknown = 0,
            Store = 1,
            DeveloperBuild = 2,
            Adhoc = 3,
            Enterprise = 4,
            Editor = 5
        }

        enum ApplicationSandboxType {
            Unknown = 0,
            NotSandboxed = 1,
            Sandboxed = 2,
            SandboxBroken = 3
        }

        enum AudioType {
            UNKNOWN = 0,
            ACC = 1,
            AIFF = 2,
            IT = 10,
            MOD = 12,
            MPEG = 13,
            OGGVORBIS = 14,
            S3M = 17,
            WAV = 20,
            XM = 21,
            XMA = 22,
            VAG = 23,
            AUDIOQUEUE = 24
        }

        enum SendMessageOptions {
            RequireReceiver = 0,
            DontRequireReceiver = 1
        }

        enum PrimitiveType {
            Sphere = 0,
            Capsule = 1,
            Cylinder = 2,
            Cube = 3,
            Plane = 4,
            Quad = 5
        }

        enum Space {
            World = 0,
            Self = 1
        }

        enum RuntimePlatform {
            OSXEditor = 0,
            OSXPlayer = 1,
            WindowsPlayer = 2,
            OSXWebPlayer = 3,
            OSXDashboardPlayer = 4,
            WindowsWebPlayer = 5,
            WindowsEditor = 7,
            IPhonePlayer = 8,
            PS3 = 9,
            XBOX360 = 10,
            Android = 11,
            NaCl = 12,
            LinuxPlayer = 13,
            FlashPlayer = 15,
            LinuxEditor = 16,
            WebGLPlayer = 17,
            MetroPlayerX86 = 18,
            WSAPlayerX86 = 18,
            MetroPlayerX64 = 19,
            WSAPlayerX64 = 19,
            MetroPlayerARM = 20,
            WSAPlayerARM = 20,
            WP8Player = 21,
            BB10Player = 22,
            BlackBerryPlayer = 22,
            TizenPlayer = 23,
            PSP2 = 24,
            PS4 = 25,
            PSM = 26,
            XboxOne = 27,
            SamsungTVPlayer = 28,
            WiiU = 30,
            tvOS = 31,
            Switch = 32,
            Lumin = 33,
            Stadia = 34,
            LinuxHeadlessSimulation = 35,
            GameCoreXboxSeries = 36,
            GameCoreXboxOne = 37,
            PS5 = 38,
            EmbeddedLinuxArm64 = 39,
            EmbeddedLinuxArm32 = 40,
            EmbeddedLinuxX64 = 41,
            EmbeddedLinuxX86 = 42,
            LinuxServer = 43,
            WindowsServer = 44,
            OSXServer = 45,
            QNXArm32 = 46,
            QNXArm64 = 47,
            QNXX64 = 48,
            QNXX86 = 49,
            VisionOS = 50,
            Switch2 = 51,
            KeplerArm64 = 52,
            KeplerX64 = 53,
            CloudRendering = -1,
            GameCoreScarlett = -1
        }

        enum SystemLanguage {
            Afrikaans = 0,
            Arabic = 1,
            Basque = 2,
            Belarusian = 3,
            Bulgarian = 4,
            Catalan = 5,
            Chinese = 6,
            Czech = 7,
            Danish = 8,
            Dutch = 9,
            English = 10,
            Estonian = 11,
            Faroese = 12,
            Finnish = 13,
            French = 14,
            German = 15,
            Greek = 16,
            Hebrew = 17,
            Hungarian = 18,
            Hugarian = 18,
            Icelandic = 19,
            Indonesian = 20,
            Italian = 21,
            Japanese = 22,
            Korean = 23,
            Latvian = 24,
            Lithuanian = 25,
            Norwegian = 26,
            Polish = 27,
            Portuguese = 28,
            Romanian = 29,
            Russian = 30,
            SerboCroatian = 31,
            Slovak = 32,
            Slovenian = 33,
            Spanish = 34,
            Swedish = 35,
            Thai = 36,
            Turkish = 37,
            Ukrainian = 38,
            Vietnamese = 39,
            ChineseSimplified = 40,
            ChineseTraditional = 41,
            Hindi = 42,
            Unknown = 43
        }

        enum LogType {
            Error = 0,
            Assert = 1,
            Warning = 2,
            Log = 3,
            Exception = 4
        }

        enum LogOption {
            None = 0,
            NoStacktrace = 1
        }

        enum ThreadPriority {
            Low = 0,
            BelowNormal = 1,
            Normal = 2,
            High = 4
        }

        class CachedAssetBundle {
            protected [__keep_incompatibility]: never;
            public name: string;
            public hash: UnityEngine.Hash128;
            constructor($name: string, $hash: UnityEngine.Hash128);
        }

        class Cache implements System.IEquatable$1<UnityEngine.Cache> {
            protected [__keep_incompatibility]: never;
            public get valid(): boolean;
            public get ready(): boolean;
            public get readOnly(): boolean;
            public get path(): string;
            public get index(): number;
            public get spaceFree(): bigint;
            public maximumAvailableStorageSpace: bigint;
            public get spaceOccupied(): bigint;
            public expirationDelay: number;
            public GetHashCode(): number;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.Cache): boolean;
            public ClearCache(): boolean;
            public ClearCache($expiration: number): boolean;
        }

        class CacheIndex {
            protected [__keep_incompatibility]: never;
            public name: string;
            public bytesUsed: number;
            public expires: number;
        }

        class Caching {
            protected [__keep_incompatibility]: never;
            public static compressionEnabled: boolean;
            public static get ready(): boolean;
            public static get spaceUsed(): number;
            public static get spaceOccupied(): bigint;
            public static get spaceAvailable(): number;
            public static get spaceFree(): bigint;
            public static maximumAvailableDiskSpace: bigint;
            public static expirationDelay: number;
            public static get cacheCount(): number;
            public static get defaultCache(): UnityEngine.Cache;
            public static currentCacheForWriting: UnityEngine.Cache;
            constructor();
            public static ClearCache(): boolean;
            public static ClearCache($expiration: number): boolean;
            public static ClearCachedVersion($assetBundleName: string, $hash: UnityEngine.Hash128): boolean;
            public static ClearOtherCachedVersions($assetBundleName: string, $hash: UnityEngine.Hash128): boolean;
            public static ClearAllCachedVersions($assetBundleName: string): boolean;
            public static GetCachedVersions($assetBundleName: string, $outCachedVersions: System.Collections.Generic.List$1<UnityEngine.Hash128>): void;
            public static IsVersionCached($url: string, $version: number): boolean;
            public static IsVersionCached($url: string, $hash: UnityEngine.Hash128): boolean;
            public static IsVersionCached($cachedBundle: UnityEngine.CachedAssetBundle): boolean;
            public static MarkAsUsed($url: string, $version: number): boolean;
            public static MarkAsUsed($url: string, $hash: UnityEngine.Hash128): boolean;
            public static MarkAsUsed($cachedBundle: UnityEngine.CachedAssetBundle): boolean;
            public static SetNoBackupFlag($url: string, $version: number): void;
            public static SetNoBackupFlag($url: string, $hash: UnityEngine.Hash128): void;
            public static SetNoBackupFlag($cachedBundle: UnityEngine.CachedAssetBundle): void;
            public static ResetNoBackupFlag($url: string, $version: number): void;
            public static ResetNoBackupFlag($url: string, $hash: UnityEngine.Hash128): void;
            public static ResetNoBackupFlag($cachedBundle: UnityEngine.CachedAssetBundle): void;
            public static GetVersionFromCache($url: string): number;
            public static AddCache($cachePath: string): UnityEngine.Cache;
            public static GetCacheAt($cacheIndex: number): UnityEngine.Cache;
            public static GetCacheByPath($cachePath: string): UnityEngine.Cache;
            public static GetAllCachePaths($cachePaths: System.Collections.Generic.List$1<string>): void;
            public static RemoveCache($cache: UnityEngine.Cache): boolean;
            public static MoveCacheBefore($src: UnityEngine.Cache, $dst: UnityEngine.Cache): void;
            public static MoveCacheAfter($src: UnityEngine.Cache, $dst: UnityEngine.Cache): void;
            public static CleanCache(): boolean;
        }

        class Camera extends UnityEngine.Behaviour {
            protected [__keep_incompatibility]: never;
            public static readonly kMinAperture: number;
            public static readonly kMaxAperture: number;
            public static readonly kMinBladeCount: number;
            public static readonly kMaxBladeCount: number;
            public static onPreCull: UnityEngine.Camera.CameraCallback;
            public static onPreRender: UnityEngine.Camera.CameraCallback;
            public static onPostRender: UnityEngine.Camera.CameraCallback;
            public nearClipPlane: number;
            public farClipPlane: number;
            public fieldOfView: number;
            public renderingPath: UnityEngine.RenderingPath;
            public get actualRenderingPath(): UnityEngine.RenderingPath;
            public allowHDR: boolean;
            public allowMSAA: boolean;
            public allowDynamicResolution: boolean;
            public forceIntoRenderTexture: boolean;
            public orthographicSize: number;
            public orthographic: boolean;
            public opaqueSortMode: UnityEngine.Rendering.OpaqueSortMode;
            public transparencySortMode: UnityEngine.TransparencySortMode;
            public transparencySortAxis: UnityEngine.Vector3;
            public depth: number;
            public aspect: number;
            public get velocity(): UnityEngine.Vector3;
            public cullingMask: number;
            public eventMask: number;
            public layerCullSpherical: boolean;
            public cameraType: UnityEngine.CameraType;
            public overrideSceneCullingMask: bigint;
            public layerCullDistances: System.Array$1<number>;
            public useOcclusionCulling: boolean;
            public cullingMatrix: UnityEngine.Matrix4x4;
            public backgroundColor: UnityEngine.Color;
            public clearFlags: UnityEngine.CameraClearFlags;
            public depthTextureMode: UnityEngine.DepthTextureMode;
            public clearStencilAfterLightingPass: boolean;
            public usePhysicalProperties: boolean;
            public iso: number;
            public shutterSpeed: number;
            public aperture: number;
            public focusDistance: number;
            public focalLength: number;
            public bladeCount: number;
            public curvature: UnityEngine.Vector2;
            public barrelClipping: number;
            public anamorphism: number;
            public sensorSize: UnityEngine.Vector2;
            public lensShift: UnityEngine.Vector2;
            public gateFit: UnityEngine.Camera.GateFitMode;
            public rect: UnityEngine.Rect;
            public pixelRect: UnityEngine.Rect;
            public get pixelWidth(): number;
            public get pixelHeight(): number;
            public get scaledPixelWidth(): number;
            public get scaledPixelHeight(): number;
            public targetTexture: UnityEngine.RenderTexture;
            public get activeTexture(): UnityEngine.RenderTexture;
            public targetDisplay: number;
            public get cameraToWorldMatrix(): UnityEngine.Matrix4x4;
            public worldToCameraMatrix: UnityEngine.Matrix4x4;
            public projectionMatrix: UnityEngine.Matrix4x4;
            public nonJitteredProjectionMatrix: UnityEngine.Matrix4x4;
            public useJitteredProjectionMatrixForTransparentRendering: boolean;
            public get previousViewProjectionMatrix(): UnityEngine.Matrix4x4;
            public static get main(): UnityEngine.Camera;
            public static get current(): UnityEngine.Camera;
            public scene: UnityEngine.SceneManagement.Scene;
            public get stereoEnabled(): boolean;
            public stereoSeparation: number;
            public stereoConvergence: number;
            public get areVRStereoViewMatricesWithinSingleCullTolerance(): boolean;
            public stereoTargetEye: UnityEngine.StereoTargetEyeMask;
            public get stereoActiveEye(): UnityEngine.Camera.MonoOrStereoscopicEye;
            public static get allCamerasCount(): number;
            public static get allCameras(): System.Array$1<UnityEngine.Camera>;
            public get sceneViewFilterMode(): UnityEngine.Camera.SceneViewFilterMode;
            public renderCloudsInSceneView: boolean;
            public get isProcessingRenderRequest(): boolean;
            public get commandBufferCount(): number;
            public near: number;
            public far: number;
            public fov: number;
            public hdr: boolean;
            constructor();
            public Reset(): void;
            public ResetTransparencySortSettings(): void;
            public ResetAspect(): void;
            public ResetCullingMatrix(): void;
            public SetReplacementShader($shader: UnityEngine.Shader, $replacementTag: string): void;
            public ResetReplacementShader(): void;
            public GetGateFittedFieldOfView(): number;
            public GetGateFittedLensShift(): UnityEngine.Vector2;
            public SetTargetBuffers($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer): void;
            public SetTargetBuffers($colorBuffer: System.Array$1<UnityEngine.RenderBuffer>, $depthBuffer: UnityEngine.RenderBuffer): void;
            public ResetWorldToCameraMatrix(): void;
            public ResetProjectionMatrix(): void;
            public CalculateObliqueMatrix($clipPlane: UnityEngine.Vector4): UnityEngine.Matrix4x4;
            public WorldToScreenPoint($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye): UnityEngine.Vector3;
            public WorldToViewportPoint($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye): UnityEngine.Vector3;
            public ViewportToWorldPoint($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye): UnityEngine.Vector3;
            public ScreenToWorldPoint($position: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye): UnityEngine.Vector3;
            public WorldToScreenPoint($position: UnityEngine.Vector3): UnityEngine.Vector3;
            public WorldToViewportPoint($position: UnityEngine.Vector3): UnityEngine.Vector3;
            public ViewportToWorldPoint($position: UnityEngine.Vector3): UnityEngine.Vector3;
            public ScreenToWorldPoint($position: UnityEngine.Vector3): UnityEngine.Vector3;
            public ScreenToViewportPoint($position: UnityEngine.Vector3): UnityEngine.Vector3;
            public ViewportToScreenPoint($position: UnityEngine.Vector3): UnityEngine.Vector3;
            public ViewportPointToRay($pos: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye): UnityEngine.Ray;
            public ViewportPointToRay($pos: UnityEngine.Vector3): UnityEngine.Ray;
            public ScreenPointToRay($pos: UnityEngine.Vector3, $eye: UnityEngine.Camera.MonoOrStereoscopicEye): UnityEngine.Ray;
            public ScreenPointToRay($pos: UnityEngine.Vector3): UnityEngine.Ray;
            public CalculateFrustumCorners($viewport: UnityEngine.Rect, $z: number, $eye: UnityEngine.Camera.MonoOrStereoscopicEye, $outCorners: System.Array$1<UnityEngine.Vector3>): void;
            public static CalculateProjectionMatrixFromPhysicalProperties($output: $Out<UnityEngine.Matrix4x4>, $focalLength: number, $sensorSize: UnityEngine.Vector2, $lensShift: UnityEngine.Vector2, $nearClip: number, $farClip: number, $gateFitParameters?: UnityEngine.Camera.GateFitParameters): void;
            public static FocalLengthToFieldOfView($focalLength: number, $sensorSize: number): number;
            public static FieldOfViewToFocalLength($fieldOfView: number, $sensorSize: number): number;
            public static HorizontalToVerticalFieldOfView($horizontalFieldOfView: number, $aspectRatio: number): number;
            public static VerticalToHorizontalFieldOfView($verticalFieldOfView: number, $aspectRatio: number): number;
            public GetStereoNonJitteredProjectionMatrix($eye: UnityEngine.Camera.StereoscopicEye): UnityEngine.Matrix4x4;
            public GetStereoViewMatrix($eye: UnityEngine.Camera.StereoscopicEye): UnityEngine.Matrix4x4;
            public CopyStereoDeviceProjectionMatrixToNonJittered($eye: UnityEngine.Camera.StereoscopicEye): void;
            public GetStereoProjectionMatrix($eye: UnityEngine.Camera.StereoscopicEye): UnityEngine.Matrix4x4;
            public SetStereoProjectionMatrix($eye: UnityEngine.Camera.StereoscopicEye, $matrix: UnityEngine.Matrix4x4): void;
            public ResetStereoProjectionMatrices(): void;
            public SetStereoViewMatrix($eye: UnityEngine.Camera.StereoscopicEye, $matrix: UnityEngine.Matrix4x4): void;
            public ResetStereoViewMatrices(): void;
            public static GetAllCameras($cameras: System.Array$1<UnityEngine.Camera>): number;
            public RenderToCubemap($cubemap: UnityEngine.Cubemap, $faceMask: number): boolean;
            public RenderToCubemap($cubemap: UnityEngine.Cubemap): boolean;
            public RenderToCubemap($cubemap: UnityEngine.RenderTexture, $faceMask: number): boolean;
            public RenderToCubemap($cubemap: UnityEngine.RenderTexture): boolean;
            public RenderToCubemap($cubemap: UnityEngine.RenderTexture, $faceMask: number, $stereoEye: UnityEngine.Camera.MonoOrStereoscopicEye): boolean;
            public Render(): void;
            public RenderWithShader($shader: UnityEngine.Shader, $replacementTag: string): void;
            public RenderDontRestore(): void;
            public SubmitRenderRequest<RequestData>($renderRequest: RequestData): void;
            public static SetupCurrent($cur: UnityEngine.Camera): void;
            public CopyFrom($other: UnityEngine.Camera): void;
            public RemoveCommandBuffers($evt: UnityEngine.Rendering.CameraEvent): void;
            public RemoveAllCommandBuffers(): void;
            public AddCommandBuffer($evt: UnityEngine.Rendering.CameraEvent, $buffer: UnityEngine.Rendering.CommandBuffer): void;
            public AddCommandBufferAsync($evt: UnityEngine.Rendering.CameraEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $queueType: UnityEngine.Rendering.ComputeQueueType): void;
            public RemoveCommandBuffer($evt: UnityEngine.Rendering.CameraEvent, $buffer: UnityEngine.Rendering.CommandBuffer): void;
            public GetCommandBuffers($evt: UnityEngine.Rendering.CameraEvent): System.Array$1<UnityEngine.Rendering.CommandBuffer>;
            public TryGetCullingParameters($cullingParameters: $Out<UnityEngine.Rendering.ScriptableCullingParameters>): boolean;
            public TryGetCullingParameters($stereoAware: boolean, $cullingParameters: $Out<UnityEngine.Rendering.ScriptableCullingParameters>): boolean;
            public ResetFieldOfView(): void;
            public SetStereoViewMatrices($leftMatrix: UnityEngine.Matrix4x4, $rightMatrix: UnityEngine.Matrix4x4): void;
            public SetStereoProjectionMatrices($leftMatrix: UnityEngine.Matrix4x4, $rightMatrix: UnityEngine.Matrix4x4): void;
            public GetStereoViewMatrices(): System.Array$1<UnityEngine.Matrix4x4>;
            public GetStereoProjectionMatrices(): System.Array$1<UnityEngine.Matrix4x4>;
        }
        namespace Camera {
            enum GateFitMode {
                None = 0,
                Vertical = 1,
                Horizontal = 2,
                Fill = 3,
                Overscan = 4
            }

            enum FieldOfViewAxis {
                Vertical = 0,
                Horizontal = 1
            }

            class GateFitParameters {
                protected [__keep_incompatibility]: never;
                public mode: UnityEngine.Camera.GateFitMode;
                public aspect: number;
                constructor($mode: UnityEngine.Camera.GateFitMode, $aspect: number);
            }

            enum StereoscopicEye {
                Left = 0,
                Right = 1
            }

            enum MonoOrStereoscopicEye {
                Left = 0,
                Right = 1,
                Mono = 2
            }

            enum SceneViewFilterMode {
                Off = 0,
                ShowFiltered = 1
            }

            interface CameraCallback {
                ($cam: UnityEngine.Camera): void;
                Invoke?: ($cam: UnityEngine.Camera) => void;
            }
            var CameraCallback: { new (func: ($cam: UnityEngine.Camera) => void): CameraCallback; };

        }

        class BoundingSphere {
            protected [__keep_incompatibility]: never;
            public position: UnityEngine.Vector3;
            public radius: number;
            constructor($pos: UnityEngine.Vector3, $rad: number);
            constructor($packedSphere: UnityEngine.Vector4);
        }

        class CullingGroupEvent {
            protected [__keep_incompatibility]: never;
            public get index(): number;
            public get isVisible(): boolean;
            public get wasVisible(): boolean;
            public get hasBecomeVisible(): boolean;
            public get hasBecomeInvisible(): boolean;
            public get currentDistance(): number;
            public get previousDistance(): number;
        }

        class CullingGroup implements System.IDisposable {
            protected [__keep_incompatibility]: never;
            public onStateChanged: UnityEngine.CullingGroup.StateChanged;
            public enabled: boolean;
            public targetCamera: UnityEngine.Camera;
            constructor();
            public Dispose(): void;
            public SetBoundingSpheres($array: System.Array$1<UnityEngine.BoundingSphere>): void;
            public SetBoundingSphereCount($count: number): void;
            public EraseSwapBack($index: number): void;
            public static EraseSwapBack<T>($index: number, $myArray: System.Array$1<T>, $size: $Ref<number>): void;
            public QueryIndices($visible: boolean, $result: System.Array$1<number>, $firstIndex: number): number;
            public QueryIndices($distanceIndex: number, $result: System.Array$1<number>, $firstIndex: number): number;
            public QueryIndices($visible: boolean, $distanceIndex: number, $result: System.Array$1<number>, $firstIndex: number): number;
            public IsVisible($index: number): boolean;
            public GetDistance($index: number): number;
            public SetBoundingDistances($distances: System.Array$1<number>): void;
            public SetDistanceReferencePoint($point: UnityEngine.Vector3): void;
            public SetDistanceReferencePoint($transform: UnityEngine.Transform): void;
        }
        namespace CullingGroup {
            interface StateChanged {
                ($sphere: UnityEngine.CullingGroupEvent): void;
                Invoke?: ($sphere: UnityEngine.CullingGroupEvent) => void;
            }
            var StateChanged: { new (func: ($sphere: UnityEngine.CullingGroupEvent) => void): StateChanged; };

        }

        class FlareLayer extends UnityEngine.Behaviour {
            protected [__keep_incompatibility]: never;
        }

        class ReflectionProbe extends UnityEngine.Behaviour {
            protected [__keep_incompatibility]: never;
            public size: UnityEngine.Vector3;
            public center: UnityEngine.Vector3;
            public nearClipPlane: number;
            public farClipPlane: number;
            public intensity: number;
            public get bounds(): UnityEngine.Bounds;
            public hdr: boolean;
            public renderDynamicObjects: boolean;
            public shadowDistance: number;
            public resolution: number;
            public cullingMask: number;
            public clearFlags: UnityEngine.Rendering.ReflectionProbeClearFlags;
            public backgroundColor: UnityEngine.Color;
            public blendDistance: number;
            public boxProjection: boolean;
            public mode: UnityEngine.Rendering.ReflectionProbeMode;
            public importance: number;
            public refreshMode: UnityEngine.Rendering.ReflectionProbeRefreshMode;
            public timeSlicingMode: UnityEngine.Rendering.ReflectionProbeTimeSlicingMode;
            public bakedTexture: UnityEngine.Texture;
            public customBakedTexture: UnityEngine.Texture;
            public realtimeTexture: UnityEngine.RenderTexture;
            public get texture(): UnityEngine.Texture;
            public get textureHDRDecodeValues(): UnityEngine.Vector4;
            public static get minBakedCubemapResolution(): number;
            public static get maxBakedCubemapResolution(): number;
            public static get defaultTextureHDRDecodeValues(): UnityEngine.Vector4;
            public static get defaultTexture(): UnityEngine.Texture;
            constructor();
            public Reset(): void;
            public RenderProbe(): number;
            public RenderProbe($targetTexture: UnityEngine.RenderTexture): number;
            public IsFinishedRendering($renderId: number): boolean;
            public static BlendCubemap($src: UnityEngine.Texture, $dst: UnityEngine.Texture, $blend: number, $target: UnityEngine.RenderTexture): boolean;
            public static UpdateCachedState(): void;
            public static add_reflectionProbeChanged(handler: System.Action$2<UnityEngine.ReflectionProbe, UnityEngine.ReflectionProbe.ReflectionProbeEvent>): void;
            public static remove_reflectionProbeChanged(handler: System.Action$2<UnityEngine.ReflectionProbe, UnityEngine.ReflectionProbe.ReflectionProbeEvent>): void;
            public static add_defaultReflectionSet(handler: System.Action$1<UnityEngine.Cubemap>): void;
            public static remove_defaultReflectionSet(handler: System.Action$1<UnityEngine.Cubemap>): void;
            public static add_defaultReflectionTexture(handler: System.Action$1<UnityEngine.Texture>): void;
            public static remove_defaultReflectionTexture(handler: System.Action$1<UnityEngine.Texture>): void;
        }
        namespace ReflectionProbe {
            enum ReflectionProbeEvent {
                ReflectionProbeAdded = 0,
                ReflectionProbeRemoved = 1
            }

        }

        class CrashReport {
            protected [__keep_incompatibility]: never;
            public readonly time: System.DateTime;
            public readonly text: string;
            public static get reports(): System.Array$1<UnityEngine.CrashReport>;
            public static get lastReport(): UnityEngine.CrashReport;
            public static RemoveAll(): void;
            public Remove(): void;
        }

        enum IntegrityCheckLevel {
            Low = 1,
            Medium = 2,
            High = 3
        }

        enum ValidationLevel {
            None = 0,
            Low = 1,
            Medium = 2,
            High = 3
        }

        class Debug {
            protected [__keep_incompatibility]: never;
            public static get unityLogger(): UnityEngine.ILogger;
            public static developerConsoleEnabled: boolean;
            public static developerConsoleVisible: boolean;
            public static get isDebugBuild(): boolean;
            public static get logger(): UnityEngine.ILogger;
            constructor();
            public static DrawLine($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number): void;
            public static DrawLine($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $color: UnityEngine.Color): void;
            public static DrawLine($start: UnityEngine.Vector3, $end: UnityEngine.Vector3): void;
            public static DrawLine($start: UnityEngine.Vector3, $end: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number, $depthTest: boolean): void;
            public static DrawRay($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number): void;
            public static DrawRay($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3, $color: UnityEngine.Color): void;
            public static DrawRay($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3): void;
            public static DrawRay($start: UnityEngine.Vector3, $dir: UnityEngine.Vector3, $color: UnityEngine.Color, $duration: number, $depthTest: boolean): void;
            public static Break(): void;
            public static DebugBreak(): void;
            public static Log($message: any): void;
            public static Log($message: any, $context: UnityEngine.Object): void;
            public static LogFormat($format: string, ...args: any[]): void;
            public static LogFormat($context: UnityEngine.Object, $format: string, ...args: any[]): void;
            public static LogFormat($logType: UnityEngine.LogType, $logOptions: UnityEngine.LogOption, $context: UnityEngine.Object, $format: string, ...args: any[]): void;
            public static LogError($message: any): void;
            public static LogError($message: any, $context: UnityEngine.Object): void;
            public static LogErrorFormat($format: string, ...args: any[]): void;
            public static LogErrorFormat($context: UnityEngine.Object, $format: string, ...args: any[]): void;
            public static ClearDeveloperConsole(): void;
            public static LogException($exception: System.Exception): void;
            public static LogException($exception: System.Exception, $context: UnityEngine.Object): void;
            public static LogWarning($message: any): void;
            public static LogWarning($message: any, $context: UnityEngine.Object): void;
            public static LogWarningFormat($format: string, ...args: any[]): void;
            public static LogWarningFormat($context: UnityEngine.Object, $format: string, ...args: any[]): void;
            public static Assert($condition: boolean): void;
            public static Assert($condition: boolean, $context: UnityEngine.Object): void;
            public static Assert($condition: boolean, $message: any): void;
            public static Assert($condition: boolean, $message: string): void;
            public static Assert($condition: boolean, $message: any, $context: UnityEngine.Object): void;
            public static Assert($condition: boolean, $message: string, $context: UnityEngine.Object): void;
            public static AssertFormat($condition: boolean, $format: string, ...args: any[]): void;
            public static AssertFormat($condition: boolean, $context: UnityEngine.Object, $format: string, ...args: any[]): void;
            public static LogAssertion($message: any): void;
            public static LogAssertion($message: any, $context: UnityEngine.Object): void;
            public static LogAssertionFormat($format: string, ...args: any[]): void;
            public static LogAssertionFormat($context: UnityEngine.Object, $format: string, ...args: any[]): void;
            public static RetrieveStartupLogs(): System.Array$1<UnityEngine.Debug.StartupLog>;
            public static CheckIntegrity($level: UnityEngine.IntegrityCheckLevel): string;
            public static IsValidationLevelEnabled($level: UnityEngine.ValidationLevel): boolean;
        }
        namespace Debug {
            class StartupLog {
                protected [__keep_incompatibility]: never;
                public timestamp: bigint;
                public logType: UnityEngine.LogType;
                public message: string;
            }

        }

        class ExposedPropertyResolver {
            protected [__keep_incompatibility]: never;
        }

        class ExposedReference<T extends UnityEngine.Object> {
            protected [__keep_incompatibility]: never;
            public exposedName: UnityEngine.PropertyName;
            public defaultValue: UnityEngine.Object;
            public Resolve($resolver: UnityEngine.IExposedPropertyTable): T;
        }

        interface IExposedPropertyTable {
            SetReferenceValue($id: UnityEngine.PropertyName, $value: UnityEngine.Object): void;
            GetReferenceValue($id: UnityEngine.PropertyName, $idValid: $Out<boolean>): UnityEngine.Object;
            ClearReferenceValue($id: UnityEngine.PropertyName): void;
        }

        class EventProvider {
            protected [__keep_incompatibility]: never;
            constructor();
            public static WriteCustomEvent($value: number, $text: string): void;
        }

        class ExpressionEvaluator {
            protected [__keep_incompatibility]: never;
            constructor();
            public static Evaluate<T>($expression: string, $value: $Out<T>): boolean;
        }

        enum CompressionType {
            None = 0,
            Lzma = 1,
            Lz4 = 2,
            Lz4HC = 3
        }

        enum CompressionLevel {
            None = 0,
            Fastest = 1,
            Fast = 2,
            Normal = 3,
            High = 4,
            Maximum = 5
        }

        class BuildCompression {
            protected [__keep_incompatibility]: never;
            public static readonly Uncompressed: UnityEngine.BuildCompression;
            public static readonly LZ4: UnityEngine.BuildCompression;
            public static readonly LZMA: UnityEngine.BuildCompression;
            public static readonly UncompressedRuntime: UnityEngine.BuildCompression;
            public static readonly LZ4Runtime: UnityEngine.BuildCompression;
            public get compression(): UnityEngine.CompressionType;
            public get level(): UnityEngine.CompressionLevel;
            public get blockSize(): number;
        }

        class Bounds implements System.IEquatable$1<UnityEngine.Bounds>, System.IFormattable {
            protected [__keep_incompatibility]: never;
            public center: UnityEngine.Vector3;
            public size: UnityEngine.Vector3;
            public extents: UnityEngine.Vector3;
            public min: UnityEngine.Vector3;
            public max: UnityEngine.Vector3;
            constructor($center: UnityEngine.Vector3, $size: UnityEngine.Vector3);
            constructor($center: $Ref<UnityEngine.Vector3>, $size: $Ref<UnityEngine.Vector3>);
            public GetHashCode(): number;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.Bounds): boolean;
            public Equals($other: $Ref<UnityEngine.Bounds>): boolean;
            public SetMinMax($min: UnityEngine.Vector3, $max: UnityEngine.Vector3): void;
            public SetMinMax($min: $Ref<UnityEngine.Vector3>, $max: $Ref<UnityEngine.Vector3>): void;
            public Encapsulate($point: UnityEngine.Vector3): void;
            public Encapsulate($point: $Ref<UnityEngine.Vector3>): void;
            public Encapsulate($bounds: UnityEngine.Bounds): void;
            public Encapsulate($bounds: $Ref<UnityEngine.Bounds>): void;
            public Expand($amount: number): void;
            public Expand($amount: UnityEngine.Vector3): void;
            public Expand($amount: $Ref<UnityEngine.Vector3>): void;
            public Intersects($bounds: UnityEngine.Bounds): boolean;
            public Intersects($bounds: $Ref<UnityEngine.Bounds>): boolean;
            public IntersectRay($ray: UnityEngine.Ray): boolean;
            public IntersectRay($ray: $Ref<UnityEngine.Ray>): boolean;
            public IntersectRay($ray: UnityEngine.Ray, $distance: $Out<number>): boolean;
            public IntersectRay($ray: $Ref<UnityEngine.Ray>, $distance: $Out<number>): boolean;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
            public Contains($point: UnityEngine.Vector3): boolean;
            public Contains($point: $Ref<UnityEngine.Vector3>): boolean;
            public SqrDistance($point: UnityEngine.Vector3): number;
            public SqrDistance($point: $Ref<UnityEngine.Vector3>): number;
            public ClosestPoint($point: UnityEngine.Vector3): UnityEngine.Vector3;
            public ClosestPoint($point: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3;
        }

        class BoundsInt implements System.IEquatable$1<UnityEngine.BoundsInt>, System.IFormattable {
            protected [__keep_incompatibility]: never;
            public x: number;
            public y: number;
            public z: number;
            public get center(): UnityEngine.Vector3;
            public min: UnityEngine.Vector3Int;
            public max: UnityEngine.Vector3Int;
            public xMin: number;
            public yMin: number;
            public zMin: number;
            public xMax: number;
            public yMax: number;
            public zMax: number;
            public position: UnityEngine.Vector3Int;
            public size: UnityEngine.Vector3Int;
            public get allPositionsWithin(): UnityEngine.BoundsInt.PositionEnumerator;
            constructor($xMin: number, $yMin: number, $zMin: number, $sizeX: number, $sizeY: number, $sizeZ: number);
            constructor($position: UnityEngine.Vector3Int, $size: UnityEngine.Vector3Int);
            constructor($position: $Ref<UnityEngine.Vector3Int>, $size: $Ref<UnityEngine.Vector3Int>);
            public SetMinMax($minPosition: UnityEngine.Vector3Int, $maxPosition: UnityEngine.Vector3Int): void;
            public SetMinMax($minPosition: $Ref<UnityEngine.Vector3Int>, $maxPosition: $Ref<UnityEngine.Vector3Int>): void;
            public ClampToBounds($bounds: UnityEngine.BoundsInt): void;
            public ClampToBounds($bounds: $Ref<UnityEngine.BoundsInt>): void;
            public Contains($position: UnityEngine.Vector3Int): boolean;
            public Contains($position: $Ref<UnityEngine.Vector3Int>): boolean;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.BoundsInt): boolean;
            public Equals($other: $Ref<UnityEngine.BoundsInt>): boolean;
            public GetHashCode(): number;
        }
        namespace BoundsInt {
            class PositionEnumerator implements System.Collections.Generic.IEnumerator$1<UnityEngine.Vector3Int>, System.Collections.IEnumerator, System.IDisposable {
                protected [__keep_incompatibility]: never;
                public get Current(): UnityEngine.Vector3Int;
                constructor($min: $Ref<UnityEngine.Vector3Int>, $max: $Ref<UnityEngine.Vector3Int>);
                public GetEnumerator(): UnityEngine.BoundsInt.PositionEnumerator;
                public MoveNext(): boolean;
                public Reset(): void;
            }

        }

        class GeometryUtility {
            protected [__keep_incompatibility]: never;
            constructor();
            public static CalculateFrustumPlanes($camera: UnityEngine.Camera): System.Array$1<UnityEngine.Plane>;
            public static CalculateFrustumPlanes($worldToProjectionMatrix: UnityEngine.Matrix4x4): System.Array$1<UnityEngine.Plane>;
            public static CalculateFrustumPlanes($worldToProjectionMatrix: $Ref<UnityEngine.Matrix4x4>): System.Array$1<UnityEngine.Plane>;
            public static CalculateFrustumPlanes($camera: UnityEngine.Camera, $planes: System.Span$1<UnityEngine.Plane>): void;
            public static CalculateFrustumPlanes($camera: UnityEngine.Camera, $planes: System.Array$1<UnityEngine.Plane>): void;
            public static CalculateFrustumPlanes($worldToProjectionMatrix: UnityEngine.Matrix4x4, $planes: System.Span$1<UnityEngine.Plane>): void;
            public static CalculateFrustumPlanes($worldToProjectionMatrix: $Ref<UnityEngine.Matrix4x4>, $planes: System.Span$1<UnityEngine.Plane>): void;
            public static CalculateFrustumPlanes($worldToProjectionMatrix: UnityEngine.Matrix4x4, $planes: System.Array$1<UnityEngine.Plane>): void;
            public static CalculateFrustumPlanes($worldToProjectionMatrix: $Ref<UnityEngine.Matrix4x4>, $planes: System.Array$1<UnityEngine.Plane>): void;
            public static CalculateBounds($positions: System.Array$1<UnityEngine.Vector3>, $transform: UnityEngine.Matrix4x4): UnityEngine.Bounds;
            public static CalculateBounds($positions: System.Array$1<UnityEngine.Vector3>, $transform: $Ref<UnityEngine.Matrix4x4>): UnityEngine.Bounds;
            public static TryCreatePlaneFromPolygon($vertices: System.Array$1<UnityEngine.Vector3>, $plane: $Out<UnityEngine.Plane>): boolean;
            public static TestPlanesAABB($planes: System.Array$1<UnityEngine.Plane>, $bounds: UnityEngine.Bounds): boolean;
            public static TestPlanesAABB($planes: System.Array$1<UnityEngine.Plane>, $bounds: $Ref<UnityEngine.Bounds>): boolean;
            public static TestPlanesAABB($planes: System.ReadOnlySpan$1<UnityEngine.Plane>, $bounds: $Ref<UnityEngine.Bounds>): boolean;
        }

        class Plane implements System.IEquatable$1<UnityEngine.Plane>, System.IFormattable {
            protected [__keep_incompatibility]: never;
            public normal: UnityEngine.Vector3;
            public distance: number;
            public get flipped(): UnityEngine.Plane;
            constructor($inNormal: UnityEngine.Vector3, $inPoint: UnityEngine.Vector3);
            constructor($inNormal: $Ref<UnityEngine.Vector3>, $inPoint: $Ref<UnityEngine.Vector3>);
            constructor($inNormal: UnityEngine.Vector3, $d: number);
            constructor($inNormal: $Ref<UnityEngine.Vector3>, $d: number);
            constructor($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $c: UnityEngine.Vector3);
            constructor($a: $Ref<UnityEngine.Vector3>, $b: $Ref<UnityEngine.Vector3>, $c: $Ref<UnityEngine.Vector3>);
            public SetNormalAndPosition($inNormal: UnityEngine.Vector3, $inPoint: UnityEngine.Vector3): void;
            public SetNormalAndPosition($inNormal: $Ref<UnityEngine.Vector3>, $inPoint: $Ref<UnityEngine.Vector3>): void;
            public Set3Points($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $c: UnityEngine.Vector3): void;
            public Set3Points($a: $Ref<UnityEngine.Vector3>, $b: $Ref<UnityEngine.Vector3>, $c: $Ref<UnityEngine.Vector3>): void;
            public Flip(): void;
            public Translate($translation: UnityEngine.Vector3): void;
            public Translate($translation: $Ref<UnityEngine.Vector3>): void;
            public static Translate($plane: UnityEngine.Plane, $translation: UnityEngine.Vector3): UnityEngine.Plane;
            public static Translate($plane: $Ref<UnityEngine.Plane>, $translation: $Ref<UnityEngine.Vector3>): UnityEngine.Plane;
            public ClosestPointOnPlane($point: UnityEngine.Vector3): UnityEngine.Vector3;
            public ClosestPointOnPlane($point: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3;
            public GetDistanceToPoint($point: UnityEngine.Vector3): number;
            public GetDistanceToPoint($point: $Ref<UnityEngine.Vector3>): number;
            public GetSide($point: UnityEngine.Vector3): boolean;
            public GetSide($point: $Ref<UnityEngine.Vector3>): boolean;
            public SameSide($inPt0: UnityEngine.Vector3, $inPt1: UnityEngine.Vector3): boolean;
            public SameSide($inPt0: $Ref<UnityEngine.Vector3>, $inPt1: $Ref<UnityEngine.Vector3>): boolean;
            public Raycast($ray: UnityEngine.Ray, $enter: $Out<number>): boolean;
            public Raycast($ray: $Ref<UnityEngine.Ray>, $enter: $Out<number>): boolean;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.Plane): boolean;
            public Equals($other: $Ref<UnityEngine.Plane>): boolean;
            public GetHashCode(): number;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
        }

        class Ray implements System.IFormattable {
            protected [__keep_incompatibility]: never;
            public origin: UnityEngine.Vector3;
            public direction: UnityEngine.Vector3;
            constructor($origin: UnityEngine.Vector3, $direction: UnityEngine.Vector3);
            constructor($origin: $Ref<UnityEngine.Vector3>, $direction: $Ref<UnityEngine.Vector3>);
            public GetPoint($distance: number): UnityEngine.Vector3;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
        }

        class Ray2D implements System.IFormattable {
            protected [__keep_incompatibility]: never;
            public origin: UnityEngine.Vector2;
            public direction: UnityEngine.Vector2;
            constructor($origin: UnityEngine.Vector2, $direction: UnityEngine.Vector2);
            constructor($origin: $Ref<UnityEngine.Vector2>, $direction: $Ref<UnityEngine.Vector2>);
            public GetPoint($distance: number): UnityEngine.Vector2;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
        }

        class Rect implements System.IEquatable$1<UnityEngine.Rect>, System.IFormattable {
            protected [__keep_incompatibility]: never;
            public static get zero(): UnityEngine.Rect;
            public x: number;
            public y: number;
            public position: UnityEngine.Vector2;
            public center: UnityEngine.Vector2;
            public min: UnityEngine.Vector2;
            public max: UnityEngine.Vector2;
            public width: number;
            public height: number;
            public size: UnityEngine.Vector2;
            public xMin: number;
            public yMin: number;
            public xMax: number;
            public yMax: number;
            public get left(): number;
            public get right(): number;
            public get top(): number;
            public get bottom(): number;
            constructor($x: number, $y: number, $width: number, $height: number);
            constructor($position: UnityEngine.Vector2, $size: UnityEngine.Vector2);
            constructor($position: $Ref<UnityEngine.Vector2>, $size: $Ref<UnityEngine.Vector2>);
            constructor($source: UnityEngine.Rect);
            constructor($source: $Ref<UnityEngine.Rect>);
            public static MinMaxRect($xmin: number, $ymin: number, $xmax: number, $ymax: number): UnityEngine.Rect;
            public Set($x: number, $y: number, $width: number, $height: number): void;
            public Contains($point: UnityEngine.Vector2): boolean;
            public Contains($point: $Ref<UnityEngine.Vector2>): boolean;
            public Contains($point: UnityEngine.Vector3): boolean;
            public Contains($point: $Ref<UnityEngine.Vector3>): boolean;
            public Contains($point: UnityEngine.Vector3, $allowInverse: boolean): boolean;
            public Contains($point: $Ref<UnityEngine.Vector3>, $allowInverse: boolean): boolean;
            public Overlaps($other: UnityEngine.Rect): boolean;
            public Overlaps($other: $Ref<UnityEngine.Rect>): boolean;
            public Overlaps($other: UnityEngine.Rect, $allowInverse: boolean): boolean;
            public Overlaps($other: $Ref<UnityEngine.Rect>, $allowInverse: boolean): boolean;
            public static NormalizedToPoint($rectangle: UnityEngine.Rect, $normalizedRectCoordinates: UnityEngine.Vector2): UnityEngine.Vector2;
            public static NormalizedToPoint($rectangle: $Ref<UnityEngine.Rect>, $normalizedRectCoordinates: $Ref<UnityEngine.Vector2>): UnityEngine.Vector2;
            public static PointToNormalized($rectangle: UnityEngine.Rect, $point: UnityEngine.Vector2): UnityEngine.Vector2;
            public static PointToNormalized($rectangle: $Ref<UnityEngine.Rect>, $point: $Ref<UnityEngine.Vector2>): UnityEngine.Vector2;
            public GetHashCode(): number;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.Rect): boolean;
            public Equals($other: $Ref<UnityEngine.Rect>): boolean;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
        }

        class RectInt implements System.IEquatable$1<UnityEngine.RectInt>, System.IFormattable {
            protected [__keep_incompatibility]: never;
            public x: number;
            public y: number;
            public get center(): UnityEngine.Vector2;
            public min: UnityEngine.Vector2Int;
            public max: UnityEngine.Vector2Int;
            public width: number;
            public height: number;
            public xMin: number;
            public yMin: number;
            public xMax: number;
            public yMax: number;
            public position: UnityEngine.Vector2Int;
            public size: UnityEngine.Vector2Int;
            public static get zero(): UnityEngine.RectInt;
            public get allPositionsWithin(): UnityEngine.RectInt.PositionEnumerator;
            constructor($xMin: number, $yMin: number, $width: number, $height: number);
            constructor($position: UnityEngine.Vector2Int, $size: UnityEngine.Vector2Int);
            constructor($position: $Ref<UnityEngine.Vector2Int>, $size: $Ref<UnityEngine.Vector2Int>);
            public SetMinMax($minPosition: UnityEngine.Vector2Int, $maxPosition: UnityEngine.Vector2Int): void;
            public SetMinMax($minPosition: $Ref<UnityEngine.Vector2Int>, $maxPosition: $Ref<UnityEngine.Vector2Int>): void;
            public ClampToBounds($bounds: UnityEngine.RectInt): void;
            public ClampToBounds($bounds: $Ref<UnityEngine.RectInt>): void;
            public Contains($position: UnityEngine.Vector2Int): boolean;
            public Contains($position: $Ref<UnityEngine.Vector2Int>): boolean;
            public Overlaps($other: UnityEngine.RectInt): boolean;
            public Overlaps($other: $Ref<UnityEngine.RectInt>): boolean;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
            public GetHashCode(): number;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.RectInt): boolean;
            public Equals($other: $Ref<UnityEngine.RectInt>): boolean;
        }
        namespace RectInt {
            class PositionEnumerator implements System.Collections.Generic.IEnumerator$1<UnityEngine.Vector2Int>, System.Collections.IEnumerator, System.IDisposable {
                protected [__keep_incompatibility]: never;
                public get Current(): UnityEngine.Vector2Int;
                constructor($min: $Ref<UnityEngine.Vector2Int>, $max: $Ref<UnityEngine.Vector2Int>);
                public GetEnumerator(): UnityEngine.RectInt.PositionEnumerator;
                public MoveNext(): boolean;
                public Reset(): void;
            }

        }

        class RectOffset implements System.IFormattable {
            protected [__keep_incompatibility]: never;
            public left: number;
            public right: number;
            public top: number;
            public bottom: number;
            public get horizontal(): number;
            public get vertical(): number;
            constructor();
            constructor($left: number, $right: number, $top: number, $bottom: number);
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
            public Add($rect: UnityEngine.Rect): UnityEngine.Rect;
            public Remove($rect: UnityEngine.Rect): UnityEngine.Rect;
        }

        class DynamicGI {
            protected [__keep_incompatibility]: never;
            public static indirectScale: number;
            public static updateThreshold: number;
            public static materialUpdateTimeSlice: number;
            public static synchronousMode: boolean;
            public static get isConverged(): boolean;
            constructor();
            public static SetEmissive($renderer: UnityEngine.Renderer, $color: UnityEngine.Color): void;
            public static SetEnvironmentData($input: System.Array$1<number>): void;
            public static UpdateEnvironment(): void;
        }

        class LightingSettings extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public bakedGI: boolean;
            public realtimeGI: boolean;
            public realtimeEnvironmentLighting: boolean;
            public autoGenerate: boolean;
            public mixedBakeMode: UnityEngine.MixedLightingMode;
            public albedoBoost: number;
            public indirectScale: number;
            public lightmapper: UnityEngine.LightingSettings.Lightmapper;
            public lightmapMaxSize: number;
            public lightmapResolution: number;
            public lightmapPadding: number;
            public lightmapCompression: UnityEngine.LightmapCompression;
            public compressLightmaps: boolean;
            public ao: boolean;
            public aoMaxDistance: number;
            public aoExponentIndirect: number;
            public aoExponentDirect: number;
            public extractAO: boolean;
            public directionalityMode: UnityEngine.LightmapsMode;
            public exportTrainingData: boolean;
            public trainingDataDestination: string;
            public indirectResolution: number;
            public sampling: UnityEngine.LightingSettings.Sampling;
            public directSampleCount: number;
            public indirectSampleCount: number;
            public bounces: number;
            public maxBounces: number;
            public russianRouletteStartBounce: number;
            public minBounces: number;
            public prioritizeView: boolean;
            public filteringMode: UnityEngine.LightingSettings.FilterMode;
            public denoiserTypeDirect: UnityEngine.LightingSettings.DenoiserType;
            public denoiserTypeIndirect: UnityEngine.LightingSettings.DenoiserType;
            public denoiserTypeAO: UnityEngine.LightingSettings.DenoiserType;
            public filterTypeDirect: UnityEngine.LightingSettings.FilterType;
            public filterTypeIndirect: UnityEngine.LightingSettings.FilterType;
            public filterTypeAO: UnityEngine.LightingSettings.FilterType;
            public filteringGaussianRadiusDirect: number;
            public filteringGaussianRadiusIndirect: number;
            public filteringGaussianRadiusAO: number;
            public filteringAtrousPositionSigmaDirect: number;
            public filteringAtrousPositionSigmaIndirect: number;
            public filteringAtrousPositionSigmaAO: number;
            public environmentImportanceSampling: boolean;
            public environmentSampleCount: number;
            public lightProbeSampleCountMultiplier: number;
            public respectSceneVisibilityWhenBakingGI: boolean;
            public lightmapPackingMode: UnityEngine.LightingSettings.LightmapPackingMode;
            public lightmapPackingMethod: UnityEngine.LightingSettings.LightmapPackingMethod;
            public packingAttempts: number;
            public bruteForcePacking: boolean;
            public blockAlignedPacking: boolean;
            public repackUnderutilizedLightmaps: boolean;
            public filteringGaussRadiusDirect: number;
            public filteringGaussRadiusIndirect: number;
            public filteringGaussRadiusAO: number;
            constructor();
        }
        namespace LightingSettings {
            enum Lightmapper {
                Enlighten = 0,
                ProgressiveCPU = 1,
                ProgressiveGPU = 2
            }

            enum Sampling {
                Auto = 0,
                Fixed = 1
            }

            enum FilterMode {
                None = 0,
                Auto = 1,
                Advanced = 2
            }

            enum DenoiserType {
                None = 0,
                Optix = 1,
                OpenImage = 2,
                RadeonPro = 3
            }

            enum FilterType {
                Gaussian = 0,
                ATrous = 1,
                None = 2
            }

            enum LightmapPackingMode {
                Auto = 0,
                Custom = 1
            }

            enum LightmapPackingMethod {
                Unity = 0,
                XAtlas = 1
            }

        }

        class Gizmos {
            protected [__keep_incompatibility]: never;
            public static color: UnityEngine.Color;
            public static matrix: UnityEngine.Matrix4x4;
            public static exposure: UnityEngine.Texture;
            public static get probeSize(): number;
            constructor();
            public static DrawLine($from: UnityEngine.Vector3, $to: UnityEngine.Vector3): void;
            public static DrawLineStrip($points: System.ReadOnlySpan$1<UnityEngine.Vector3>, $looped: boolean): void;
            public static DrawLineList($points: System.ReadOnlySpan$1<UnityEngine.Vector3>): void;
            public static DrawWireSphere($center: UnityEngine.Vector3, $radius: number): void;
            public static DrawSphere($center: UnityEngine.Vector3, $radius: number): void;
            public static DrawWireCube($center: UnityEngine.Vector3, $size: UnityEngine.Vector3): void;
            public static DrawCube($center: UnityEngine.Vector3, $size: UnityEngine.Vector3): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3): void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3): void;
            public static DrawIcon($center: UnityEngine.Vector3, $name: string, $allowScaling: boolean): void;
            public static DrawIcon($center: UnityEngine.Vector3, $name: string, $allowScaling: boolean, $tint: UnityEngine.Color): void;
            public static DrawGUITexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material): void;
            public static DrawFrustum($center: UnityEngine.Vector3, $fov: number, $maxRange: number, $minRange: number, $aspect: number): void;
            public static CalculateLOD($position: UnityEngine.Vector3, $radius: number): number;
            public static DrawRay($r: UnityEngine.Ray): void;
            public static DrawRay($from: UnityEngine.Vector3, $direction: UnityEngine.Vector3): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3): void;
            public static DrawMesh($mesh: UnityEngine.Mesh): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $submeshIndex: number): void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion): void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3): void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh): void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $scale: UnityEngine.Vector3): void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion): void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh, $submeshIndex: number, $position: UnityEngine.Vector3): void;
            public static DrawWireMesh($mesh: UnityEngine.Mesh, $submeshIndex: number): void;
            public static DrawIcon($center: UnityEngine.Vector3, $name: string): void;
            public static DrawGUITexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture): void;
            public static DrawGUITexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $mat: UnityEngine.Material): void;
            public static DrawGUITexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number): void;
        }

        class BeforeRenderOrderAttribute extends System.Attribute {
            protected [__keep_incompatibility]: never;
            public get order(): number;
            constructor($order: number);
        }

        class BillboardAsset extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public width: number;
            public height: number;
            public bottom: number;
            public get imageCount(): number;
            public get vertexCount(): number;
            public get indexCount(): number;
            public material: UnityEngine.Material;
            constructor();
            public GetImageTexCoords($imageTexCoords: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public GetImageTexCoords(): System.Array$1<UnityEngine.Vector4>;
            public SetImageTexCoords($imageTexCoords: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public SetImageTexCoords($imageTexCoords: System.Array$1<UnityEngine.Vector4>): void;
            public GetVertices($vertices: System.Collections.Generic.List$1<UnityEngine.Vector2>): void;
            public GetVertices(): System.Array$1<UnityEngine.Vector2>;
            public SetVertices($vertices: System.Collections.Generic.List$1<UnityEngine.Vector2>): void;
            public SetVertices($vertices: System.Array$1<UnityEngine.Vector2>): void;
            public GetIndices($indices: System.Collections.Generic.List$1<number>): void;
            public GetIndices(): System.Array$1<number>;
            public SetIndices($indices: System.Collections.Generic.List$1<number>): void;
            public SetIndices($indices: System.Array$1<number>): void;
        }

        class BillboardRenderer extends UnityEngine.Renderer {
            protected [__keep_incompatibility]: never;
            public billboard: UnityEngine.BillboardAsset;
            constructor();
        }

        class CustomRenderTextureManager {
            protected [__keep_incompatibility]: never;
            public static GetAllCustomRenderTextures($currentCustomRenderTextures: System.Collections.Generic.List$1<UnityEngine.CustomRenderTexture>): void;
            public static add_textureLoaded(handler: System.Action$1<UnityEngine.CustomRenderTexture>): void;
            public static remove_textureLoaded(handler: System.Action$1<UnityEngine.CustomRenderTexture>): void;
            public static add_textureUnloaded(handler: System.Action$1<UnityEngine.CustomRenderTexture>): void;
            public static remove_textureUnloaded(handler: System.Action$1<UnityEngine.CustomRenderTexture>): void;
            public static add_updateTriggered(handler: System.Action$2<UnityEngine.CustomRenderTexture, number>): void;
            public static remove_updateTriggered(handler: System.Action$2<UnityEngine.CustomRenderTexture, number>): void;
            public static add_initializeTriggered(handler: System.Action$1<UnityEngine.CustomRenderTexture>): void;
            public static remove_initializeTriggered(handler: System.Action$1<UnityEngine.CustomRenderTexture>): void;
        }

        enum D3D12GraphicsDeviceType {
            DoNotCare = 0,
            Discrete = 1,
            Integrated = 2
        }

        enum D3D12Comparator {
            EqualTo = 0,
            NotEqualTo = 1,
            LessThan = 2,
            LessThanOrEqualTo = 3,
            GreaterThan = 4,
            GreaterThanOrEqualTo = 5
        }

        class D3D12DeviceFilterData {
            protected [__keep_incompatibility]: never;
            public vendorName: string;
            public deviceName: string;
            public driverVersionComparator: UnityEngine.D3D12Comparator;
            public driverVersion: string;
            public featureLevelComparator: UnityEngine.D3D12Comparator;
            public featureLevel: string;
            public graphicsMemoryComparator: UnityEngine.D3D12Comparator;
            public graphicsMemory: string;
            public processorCountComparator: UnityEngine.D3D12Comparator;
            public processorCount: string;
            public deviceType: UnityEngine.D3D12GraphicsDeviceType;
        }

        class D3D12GraphicsJobsDeviceFilterData {
            protected [__keep_incompatibility]: never;
            public preferredMode: UnityEngine.GraphicsJobsFilterMode;
            public filter: UnityEngine.D3D12DeviceFilterData;
        }

        class D3D12DeviceFilterLists extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public d3D12DeviceAllowFilters: System.Array$1<UnityEngine.D3D12DeviceFilterData>;
            public d3D12DeviceDenyFilters: System.Array$1<UnityEngine.D3D12DeviceFilterData>;
            public d3D12GraphicsJobsDeviceFilters: System.Array$1<UnityEngine.D3D12GraphicsJobsDeviceFilterData>;
            constructor($name?: string);
            public EnsureValidOrThrow(): void;
        }

        class Display {
            protected [__keep_incompatibility]: never;
            public static displays: System.Array$1<UnityEngine.Display>;
            public get renderingWidth(): number;
            public get renderingHeight(): number;
            public get systemWidth(): number;
            public get systemHeight(): number;
            public get colorBuffer(): UnityEngine.RenderBuffer;
            public get depthBuffer(): UnityEngine.RenderBuffer;
            public get active(): boolean;
            public get requiresBlitToBackbuffer(): boolean;
            public get requiresSrgbBlitToBackbuffer(): boolean;
            public static get main(): UnityEngine.Display;
            public static get activeEditorGameViewTarget(): number;
            public Activate(): void;
            public Activate($width: number, $height: number, $refreshRate: UnityEngine.RefreshRate): void;
            public Activate($width: number, $height: number, $refreshRate: number): void;
            public SetParams($width: number, $height: number, $x: number, $y: number): void;
            public SetRenderingResolution($w: number, $h: number): void;
            public static MultiDisplayLicense(): boolean;
            public static RelativeMouseAt($inputMouseCoordinates: UnityEngine.Vector3): UnityEngine.Vector3;
            public static add_onDisplaysUpdated(handler: UnityEngine.Display.DisplaysUpdatedDelegate): void;
            public static remove_onDisplaysUpdated(handler: UnityEngine.Display.DisplaysUpdatedDelegate): void;
        }
        namespace Display {
            interface DisplaysUpdatedDelegate {
                (): void;
                Invoke?: () => void;
            }
            var DisplaysUpdatedDelegate: { new (func: () => void): DisplaysUpdatedDelegate; };

        }

        class LightProbesQuery implements System.IDisposable {
            protected [__keep_incompatibility]: never;
            public get IsCreated(): boolean;
            constructor($allocator: Unity.Collections.Allocator);
            public Dispose(): void;
            public Dispose($inputDeps: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
            public CalculateInterpolatedLightAndOcclusionProbe($position: UnityEngine.Vector3, $tetrahedronIndex: $Ref<number>, $lightProbe: $Out<UnityEngine.Rendering.SphericalHarmonicsL2>, $occlusionProbe: $Out<UnityEngine.Vector4>): void;
            public CalculateInterpolatedLightAndOcclusionProbes($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>, $tetrahedronIndices: Unity.Collections.NativeArray$1<number>, $lightProbes: Unity.Collections.NativeArray$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $occlusionProbes: Unity.Collections.NativeArray$1<UnityEngine.Vector4>): void;
        }

        enum FullScreenMode {
            ExclusiveFullScreen = 0,
            FullScreenWindow = 1,
            MaximizedWindow = 2,
            Windowed = 3
        }

        class RefreshRate implements System.IEquatable$1<UnityEngine.RefreshRate>, System.IComparable$1<UnityEngine.RefreshRate> {
            protected [__keep_incompatibility]: never;
            public numerator: number;
            public denominator: number;
            public get value(): number;
            public Equals($other: UnityEngine.RefreshRate): boolean;
            public CompareTo($other: UnityEngine.RefreshRate): number;
            public ToString(): string;
        }

        class DisplayInfo implements System.IEquatable$1<UnityEngine.DisplayInfo> {
            protected [__keep_incompatibility]: never;
            public width: number;
            public height: number;
            public refreshRate: UnityEngine.RefreshRate;
            public workArea: UnityEngine.RectInt;
            public name: string;
            public physicalDpi: number;
            public get resolutions(): System.Array$1<UnityEngine.Resolution>;
            public Equals($other: UnityEngine.DisplayInfo): boolean;
            public static GetLayout($displayLayout: System.Collections.Generic.List$1<UnityEngine.DisplayInfo>): void;
        }

        class SleepTimeout {
            protected [__keep_incompatibility]: never;
            public static readonly NeverSleep: number;
            public static readonly SystemSetting: number;
            constructor();
        }

        class Screen {
            protected [__keep_incompatibility]: never;
            public static get width(): number;
            public static get height(): number;
            public static get dpi(): number;
            public static get currentResolution(): UnityEngine.Resolution;
            public static get resolutions(): System.Array$1<UnityEngine.Resolution>;
            public static get msaaSamples(): number;
            public static fullScreen: boolean;
            public static fullScreenMode: UnityEngine.FullScreenMode;
            public static get safeArea(): UnityEngine.Rect;
            public static get cutouts(): System.Array$1<UnityEngine.Rect>;
            public static autorotateToPortrait: boolean;
            public static autorotateToPortraitUpsideDown: boolean;
            public static autorotateToLandscapeLeft: boolean;
            public static autorotateToLandscapeRight: boolean;
            public static orientation: UnityEngine.ScreenOrientation;
            public static sleepTimeout: number;
            public static brightness: number;
            public static get mainWindowPosition(): UnityEngine.Vector2Int;
            public static get mainWindowDisplayInfo(): UnityEngine.DisplayInfo;
            public static lockCursor: boolean;
            constructor();
            public static SetResolution($width: number, $height: number, $fullscreenMode: UnityEngine.FullScreenMode, $preferredRefreshRate: UnityEngine.RefreshRate): void;
            public static SetResolution($width: number, $height: number, $fullscreenMode: UnityEngine.FullScreenMode, $preferredRefreshRate: number): void;
            public static SetResolution($width: number, $height: number, $fullscreenMode: UnityEngine.FullScreenMode): void;
            public static SetResolution($width: number, $height: number, $fullscreen: boolean, $preferredRefreshRate: number): void;
            public static SetResolution($width: number, $height: number, $fullscreen: boolean): void;
            public static SetMSAASamples($numSamples: number): void;
            public static GetDisplayLayout($displayLayout: System.Collections.Generic.List$1<UnityEngine.DisplayInfo>): void;
            public static MoveMainWindowTo($display: $Ref<UnityEngine.DisplayInfo>, $position: UnityEngine.Vector2Int): UnityEngine.AsyncOperation;
        }

        class RenderBuffer {
            protected [__keep_incompatibility]: never;
            public GetNativeRenderBufferPtr(): number;
        }

        enum ComputeBufferMode {
            Immutable = 0,
            Dynamic = 1,
            Circular = 2,
            StreamOut = 3,
            SubUpdates = 4
        }

        class Graphics {
            protected [__keep_incompatibility]: never;
            public static get activeColorGamut(): UnityEngine.ColorGamut;
            public static activeTier: UnityEngine.Rendering.GraphicsTier;
            public static get preserveFramebufferAlpha(): boolean;
            public static get minOpenGLESVersion(): UnityEngine.Rendering.OpenGLESVersion;
            public static get activeColorBuffer(): UnityEngine.RenderBuffer;
            public static get activeDepthBuffer(): UnityEngine.RenderBuffer;
            constructor();
            public static ClearRandomWriteTargets(): void;
            public static ExecuteCommandBuffer($buffer: UnityEngine.Rendering.CommandBuffer): void;
            public static ExecuteCommandBufferAsync($buffer: UnityEngine.Rendering.CommandBuffer, $queueType: UnityEngine.Rendering.ComputeQueueType): void;
            public static SetRenderTarget($rt: UnityEngine.RenderTexture, $mipLevel: number, $face: UnityEngine.CubemapFace, $depthSlice: number): void;
            public static SetRenderTarget($rt: UnityEngine.Rendering.GraphicsTexture, $mipLevel: number, $face: UnityEngine.CubemapFace, $depthSlice: number): void;
            public static SetRenderTarget($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace, $depthSlice: number): void;
            public static SetRenderTarget($colorBuffers: System.Array$1<UnityEngine.RenderBuffer>, $depthBuffer: UnityEngine.RenderBuffer): void;
            public static SetRenderTarget($setup: UnityEngine.RenderTargetSetup): void;
            public static SetRandomWriteTarget($index: number, $uav: UnityEngine.RenderTexture): void;
            public static SetRandomWriteTarget($index: number, $uav: UnityEngine.ComputeBuffer, $preserveCounterValue: boolean): void;
            public static SetRandomWriteTarget($index: number, $uav: UnityEngine.GraphicsBuffer, $preserveCounterValue: boolean): void;
            public static CopyTexture($src: UnityEngine.Texture, $dst: UnityEngine.Texture): void;
            public static CopyTexture($src: UnityEngine.Texture, $srcElement: number, $dst: UnityEngine.Texture, $dstElement: number): void;
            public static CopyTexture($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $dst: UnityEngine.Texture, $dstElement: number, $dstMip: number): void;
            public static CopyTexture($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $srcX: number, $srcY: number, $srcWidth: number, $srcHeight: number, $dst: UnityEngine.Texture, $dstElement: number, $dstMip: number, $dstX: number, $dstY: number): void;
            public static CopyTexture($src: UnityEngine.Rendering.GraphicsTexture, $dst: UnityEngine.Rendering.GraphicsTexture): void;
            public static CopyTexture($src: UnityEngine.Rendering.GraphicsTexture, $srcElement: number, $dst: UnityEngine.Rendering.GraphicsTexture, $dstElement: number): void;
            public static CopyTexture($src: UnityEngine.Rendering.GraphicsTexture, $srcElement: number, $srcMip: number, $dst: UnityEngine.Rendering.GraphicsTexture, $dstElement: number, $dstMip: number): void;
            public static CopyTexture($src: UnityEngine.Rendering.GraphicsTexture, $srcElement: number, $srcMip: number, $srcX: number, $srcY: number, $srcWidth: number, $srcHeight: number, $dst: UnityEngine.Rendering.GraphicsTexture, $dstElement: number, $dstMip: number, $dstX: number, $dstY: number): void;
            public static ConvertTexture($src: UnityEngine.Texture, $dst: UnityEngine.Texture): boolean;
            public static ConvertTexture($src: UnityEngine.Texture, $srcElement: number, $dst: UnityEngine.Texture, $dstElement: number): boolean;
            public static ConvertTexture($src: UnityEngine.Rendering.GraphicsTexture, $dst: UnityEngine.Rendering.GraphicsTexture): boolean;
            public static ConvertTexture($src: UnityEngine.Rendering.GraphicsTexture, $srcElement: number, $dst: UnityEngine.Rendering.GraphicsTexture, $dstElement: number): boolean;
            public static CreateAsyncGraphicsFence($stage: UnityEngine.Rendering.SynchronisationStage): UnityEngine.Rendering.GraphicsFence;
            public static CreateAsyncGraphicsFence(): UnityEngine.Rendering.GraphicsFence;
            public static CreateGraphicsFence($fenceType: UnityEngine.Rendering.GraphicsFenceType, $stage: UnityEngine.Rendering.SynchronisationStageFlags): UnityEngine.Rendering.GraphicsFence;
            public static WaitOnAsyncGraphicsFence($fence: UnityEngine.Rendering.GraphicsFence): void;
            public static WaitOnAsyncGraphicsFence($fence: UnityEngine.Rendering.GraphicsFence, $stage: UnityEngine.Rendering.SynchronisationStage): void;
            public static CopyBuffer($source: UnityEngine.GraphicsBuffer, $dest: UnityEngine.GraphicsBuffer): void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: UnityEngine.Color, $mat: UnityEngine.Material, $pass: number): void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material, $pass: number): void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material, $pass: number): void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $mat: UnityEngine.Material, $pass: number): void;
            public static RenderMesh($rparams: $Ref<UnityEngine.RenderParams>, $mesh: UnityEngine.Mesh, $submeshIndex: number, $objectToWorld: UnityEngine.Matrix4x4, $prevObjectToWorld?: UnityEngine.Matrix4x4 | null): void;
            public static RenderMeshInstanced<T>($rparams: $Ref<UnityEngine.RenderParams>, $mesh: UnityEngine.Mesh, $submeshIndex: number, $instanceData: System.Array$1<T>, $instanceCount?: number, $startInstance?: number): void;
            public static RenderMeshInstanced<T>($rparams: $Ref<UnityEngine.RenderParams>, $mesh: UnityEngine.Mesh, $submeshIndex: number, $instanceData: System.Collections.Generic.List$1<T>, $instanceCount?: number, $startInstance?: number): void;
            public static RenderMeshInstanced<T>($rparams: UnityEngine.RenderParams, $mesh: UnityEngine.Mesh, $submeshIndex: number, $instanceData: Unity.Collections.NativeArray$1<T>, $instanceCount?: number, $startInstance?: number): void;
            public static RenderMeshIndirect($rparams: $Ref<UnityEngine.RenderParams>, $mesh: UnityEngine.Mesh, $argsBuffer: UnityEngine.GraphicsBuffer, $commandCount?: number, $startCommand?: number): void;
            public static RenderMeshPrimitives($rparams: $Ref<UnityEngine.RenderParams>, $mesh: UnityEngine.Mesh, $submeshIndex: number, $instanceCount?: number): void;
            public static RenderPrimitives($rparams: $Ref<UnityEngine.RenderParams>, $topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount?: number): void;
            public static RenderPrimitivesIndexed($rparams: $Ref<UnityEngine.RenderParams>, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $indexCount: number, $startIndex?: number, $instanceCount?: number): void;
            public static RenderPrimitivesIndirect($rparams: $Ref<UnityEngine.RenderParams>, $topology: UnityEngine.MeshTopology, $argsBuffer: UnityEngine.GraphicsBuffer, $commandCount?: number, $startCommand?: number): void;
            public static RenderPrimitivesIndexedIndirect($rparams: $Ref<UnityEngine.RenderParams>, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $commandBuffer: UnityEngine.GraphicsBuffer, $commandCount?: number, $startCommand?: number): void;
            public static DrawMeshNow($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $materialIndex: number): void;
            public static DrawMeshNow($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $materialIndex: number): void;
            public static DrawMeshNow($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion): void;
            public static DrawMeshNow($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean, $useLightProbes: boolean): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $useLightProbes: boolean): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean, $useLightProbes: boolean): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume): void;
            public static DrawMeshInstancedProcedural($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $count: number, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: UnityEngine.Camera, $lightProbeUsage?: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume?: UnityEngine.LightProbeProxyVolume): void;
            public static DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume): void;
            public static DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage, $lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume): void;
            public static DrawProceduralNow($topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount?: number): void;
            public static DrawProceduralNow($topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $indexCount: number, $instanceCount?: number): void;
            public static DrawProceduralIndirectNow($topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number): void;
            public static DrawProceduralIndirectNow($topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number): void;
            public static DrawProceduralIndirectNow($topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number): void;
            public static DrawProceduralIndirectNow($topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number): void;
            public static DrawProcedural($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number): void;
            public static DrawProcedural($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $indexCount: number, $instanceCount?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number): void;
            public static DrawProceduralIndirect($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number): void;
            public static DrawProceduralIndirect($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number): void;
            public static DrawProceduralIndirect($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number): void;
            public static DrawProceduralIndirect($material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $topology: UnityEngine.MeshTopology, $indexBuffer: UnityEngine.GraphicsBuffer, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number): void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture): void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $sourceDepthSlice: number, $destDepthSlice: number): void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2): void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2, $sourceDepthSlice: number, $destDepthSlice: number): void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, $pass: number): void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, $pass: number, $destDepthSlice: number): void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material): void;
            public static Blit($source: UnityEngine.Texture, $mat: UnityEngine.Material, $pass: number): void;
            public static Blit($source: UnityEngine.Texture, $mat: UnityEngine.Material, $pass: number, $destDepthSlice: number): void;
            public static Blit($source: UnityEngine.Texture, $mat: UnityEngine.Material): void;
            public static BlitMultiTap($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, ...offsets: UnityEngine.Vector2[]): void;
            public static BlitMultiTap($source: UnityEngine.Texture, $dest: UnityEngine.RenderTexture, $mat: UnityEngine.Material, $destDepthSlice: number, ...offsets: UnityEngine.Vector2[]): void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture): void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $sourceDepthSlice: number, $destDepthSlice: number): void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2): void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2, $sourceDepthSlice: number, $destDepthSlice: number): void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $mat: UnityEngine.Material, $pass: number): void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $mat: UnityEngine.Material, $pass: number, $destDepthSlice: number): void;
            public static Blit($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $mat: UnityEngine.Material): void;
            public static BlitMultiTap($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $mat: UnityEngine.Material, ...offsets: UnityEngine.Vector2[]): void;
            public static BlitMultiTap($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.GraphicsTexture, $mat: UnityEngine.Material, $destDepthSlice: number, ...offsets: UnityEngine.Vector2[]): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: boolean, $receiveShadows: boolean): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $useLightProbes: boolean): void;
            public static DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $layer: number, $camera: UnityEngine.Camera, $submeshIndex: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $probeAnchor: UnityEngine.Transform, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera): void;
            public static DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $matrices: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>, $properties: UnityEngine.MaterialPropertyBlock, $castShadows: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows: boolean, $layer: number, $camera: UnityEngine.Camera, $lightProbeUsage: UnityEngine.Rendering.LightProbeUsage): void;
            public static DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset?: number, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: UnityEngine.Camera, $lightProbeUsage?: UnityEngine.Rendering.LightProbeUsage): void;
            public static DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $bounds: UnityEngine.Bounds, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset?: number, $properties?: UnityEngine.MaterialPropertyBlock, $castShadows?: UnityEngine.Rendering.ShadowCastingMode, $receiveShadows?: boolean, $layer?: number, $camera?: UnityEngine.Camera, $lightProbeUsage?: UnityEngine.Rendering.LightProbeUsage): void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: UnityEngine.Color, $mat: UnityEngine.Material): void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $color: UnityEngine.Color): void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material): void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $sourceRect: UnityEngine.Rect, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number): void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number, $mat: UnityEngine.Material): void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $leftBorder: number, $rightBorder: number, $topBorder: number, $bottomBorder: number): void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture, $mat: UnityEngine.Material): void;
            public static DrawTexture($screenRect: UnityEngine.Rect, $texture: UnityEngine.Texture): void;
            public static SetRenderTarget($rt: UnityEngine.RenderTexture): void;
            public static SetRenderTarget($rt: UnityEngine.RenderTexture, $mipLevel: number): void;
            public static SetRenderTarget($rt: UnityEngine.RenderTexture, $mipLevel: number, $face: UnityEngine.CubemapFace): void;
            public static SetRenderTarget($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer): void;
            public static SetRenderTarget($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer, $mipLevel: number): void;
            public static SetRenderTarget($colorBuffer: UnityEngine.RenderBuffer, $depthBuffer: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace): void;
            public static SetRandomWriteTarget($index: number, $uav: UnityEngine.ComputeBuffer): void;
            public static SetRandomWriteTarget($index: number, $uav: UnityEngine.GraphicsBuffer): void;
        }

        class GL {
            protected [__keep_incompatibility]: never;
            public static readonly TRIANGLES: number;
            public static readonly TRIANGLE_STRIP: number;
            public static readonly QUADS: number;
            public static readonly LINES: number;
            public static readonly LINE_STRIP: number;
            public static wireframe: boolean;
            public static sRGBWrite: boolean;
            public static invertCulling: boolean;
            public static modelview: UnityEngine.Matrix4x4;
            constructor();
            public static Vertex3($x: number, $y: number, $z: number): void;
            public static Vertex($v: UnityEngine.Vector3): void;
            public static TexCoord3($x: number, $y: number, $z: number): void;
            public static TexCoord($v: UnityEngine.Vector3): void;
            public static TexCoord2($x: number, $y: number): void;
            public static MultiTexCoord3($unit: number, $x: number, $y: number, $z: number): void;
            public static MultiTexCoord($unit: number, $v: UnityEngine.Vector3): void;
            public static MultiTexCoord2($unit: number, $x: number, $y: number): void;
            public static Color($c: UnityEngine.Color): void;
            public static Flush(): void;
            public static RenderTargetBarrier(): void;
            public static MultMatrix($m: UnityEngine.Matrix4x4): void;
            public static IssuePluginEvent($eventID: number): void;
            public static SetRevertBackfacing($revertBackFaces: boolean): void;
            public static PushMatrix(): void;
            public static PopMatrix(): void;
            public static LoadIdentity(): void;
            public static LoadOrtho(): void;
            public static LoadPixelMatrix(): void;
            public static LoadProjectionMatrix($mat: UnityEngine.Matrix4x4): void;
            public static InvalidateState(): void;
            public static GetGPUProjectionMatrix($proj: UnityEngine.Matrix4x4, $renderIntoTexture: boolean): UnityEngine.Matrix4x4;
            public static LoadPixelMatrix($left: number, $right: number, $bottom: number, $top: number): void;
            public static IssuePluginEvent($callback: number, $eventID: number): void;
            public static Begin($mode: number): void;
            public static End(): void;
            public static Clear($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color, $depth: number): void;
            public static Clear($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color): void;
            public static Viewport($pixelRect: UnityEngine.Rect): void;
            public static ClearWithSkybox($clearDepth: boolean, $camera: UnityEngine.Camera): void;
        }

        class ScalableBufferManager {
            protected [__keep_incompatibility]: never;
            public static get widthScaleFactor(): number;
            public static get heightScaleFactor(): number;
            public static ResizeBuffers($widthScale: number, $heightScale: number): void;
        }

        class FrameTiming {
            protected [__keep_incompatibility]: never;
            public cpuFrameTime: number;
            public cpuMainThreadFrameTime: number;
            public cpuMainThreadPresentWaitTime: number;
            public cpuRenderThreadFrameTime: number;
            public gpuFrameTime: number;
            public frameStartTimestamp: bigint;
            public firstSubmitTimestamp: bigint;
            public cpuTimePresentCalled: bigint;
            public cpuTimeFrameComplete: bigint;
            public heightScale: number;
            public widthScale: number;
            public syncInterval: number;
        }

        class FrameTimingManager {
            protected [__keep_incompatibility]: never;
            public static IsFeatureEnabled(): boolean;
            public static CaptureFrameTimings(): void;
            public static GetLatestTimings($numFrames: number, $timings: System.Array$1<UnityEngine.FrameTiming>): number;
            public static GetVSyncsPerSecond(): number;
            public static GetGpuTimerFrequency(): bigint;
            public static GetCpuTimerFrequency(): bigint;
        }

        class LightmapData {
            protected [__keep_incompatibility]: never;
            public lightmapLight: UnityEngine.Texture2D;
            public lightmapColor: UnityEngine.Texture2D;
            public lightmapDir: UnityEngine.Texture2D;
            public shadowMask: UnityEngine.Texture2D;
            constructor();
        }

        class LightmapSettings extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public static lightmaps: System.Array$1<UnityEngine.LightmapData>;
            public static lightmapsMode: UnityEngine.LightmapsMode;
            public static lightProbes: UnityEngine.LightProbes;
            public static lightmapsModeLegacy: UnityEngine.LightmapsModeLegacy;
            public static bakedColorSpace: UnityEngine.ColorSpace;
        }

        class LightProbes extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public get positions(): System.Array$1<UnityEngine.Vector3>;
            public bakedProbes: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>;
            public get count(): number;
            public get countSelf(): number;
            public get cellCount(): number;
            public get cellCountSelf(): number;
            public static Tetrahedralize(): void;
            public static TetrahedralizeAsync(): void;
            public static GetInterpolatedProbe($position: UnityEngine.Vector3, $renderer: UnityEngine.Renderer, $probe: $Out<UnityEngine.Rendering.SphericalHarmonicsL2>): void;
            public static CalculateInterpolatedLightAndOcclusionProbes($positions: System.Array$1<UnityEngine.Vector3>, $lightProbes: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $occlusionProbes: System.Array$1<UnityEngine.Vector4>): void;
            public static CalculateInterpolatedLightAndOcclusionProbes($positions: System.Collections.Generic.List$1<UnityEngine.Vector3>, $lightProbes: System.Collections.Generic.List$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $occlusionProbes: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public static GetSharedLightProbesForScene($scene: UnityEngine.SceneManagement.Scene): UnityEngine.LightProbes;
            public static GetInstantiatedLightProbesForScene($scene: UnityEngine.SceneManagement.Scene): UnityEngine.LightProbes;
            public GetPositionsSelf(): System.Array$1<UnityEngine.Vector3>;
            public SetPositionsSelf($positions: System.Array$1<UnityEngine.Vector3>, $checkForDuplicatePositions: boolean): boolean;
            public static add_lightProbesUpdated(handler: System.Action): void;
            public static remove_lightProbesUpdated(handler: System.Action): void;
            public static add_tetrahedralizationCompleted(handler: System.Action): void;
            public static remove_tetrahedralizationCompleted(handler: System.Action): void;
            public static add_needsRetetrahedralization(handler: System.Action): void;
            public static remove_needsRetetrahedralization(handler: System.Action): void;
        }

        enum D3DHDRDisplayBitDepth {
            D3DHDRDisplayBitDepth10 = 0,
            D3DHDRDisplayBitDepth16 = 1
        }

        class HDROutputSettings {
            protected [__keep_incompatibility]: never;
            public static displays: System.Array$1<UnityEngine.HDROutputSettings>;
            public static get main(): UnityEngine.HDROutputSettings;
            public get active(): boolean;
            public get available(): boolean;
            public automaticHDRTonemapping: boolean;
            public get displayColorGamut(): UnityEngine.ColorGamut;
            public get format(): UnityEngine.RenderTextureFormat;
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public paperWhiteNits: number;
            public get maxFullFrameToneMapLuminance(): number;
            public get maxToneMapLuminance(): number;
            public get minToneMapLuminance(): number;
            public get HDRModeChangeRequested(): boolean;
            public RequestHDRModeChange($enabled: boolean): void;
            public static SetPaperWhiteInNits($paperWhite: number): void;
        }

        class ColorGamutUtility {
            protected [__keep_incompatibility]: never;
            constructor();
            public static GetColorPrimaries($gamut: UnityEngine.ColorGamut): UnityEngine.ColorPrimaries;
            public static GetWhitePoint($gamut: UnityEngine.ColorGamut): UnityEngine.WhitePoint;
            public static GetTransferFunction($gamut: UnityEngine.ColorGamut): UnityEngine.TransferFunction;
        }

        class Resolution {
            protected [__keep_incompatibility]: never;
            public width: number;
            public height: number;
            public refreshRateRatio: UnityEngine.RefreshRate;
            public refreshRate: number;
            public ToString(): string;
        }

        class RenderTargetSetup {
            protected [__keep_incompatibility]: never;
            public color: System.Array$1<UnityEngine.RenderBuffer>;
            public depth: UnityEngine.RenderBuffer;
            public mipLevel: number;
            public cubemapFace: UnityEngine.CubemapFace;
            public depthSlice: number;
            public colorLoad: System.Array$1<UnityEngine.Rendering.RenderBufferLoadAction>;
            public colorStore: System.Array$1<UnityEngine.Rendering.RenderBufferStoreAction>;
            public depthLoad: UnityEngine.Rendering.RenderBufferLoadAction;
            public depthStore: UnityEngine.Rendering.RenderBufferStoreAction;
            constructor($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer, $mip: number, $face: UnityEngine.CubemapFace, $colorLoad: System.Array$1<UnityEngine.Rendering.RenderBufferLoadAction>, $colorStore: System.Array$1<UnityEngine.Rendering.RenderBufferStoreAction>, $depthLoad: UnityEngine.Rendering.RenderBufferLoadAction, $depthStore: UnityEngine.Rendering.RenderBufferStoreAction);
            constructor($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer);
            constructor($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer, $mipLevel: number);
            constructor($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace);
            constructor($color: UnityEngine.RenderBuffer, $depth: UnityEngine.RenderBuffer, $mipLevel: number, $face: UnityEngine.CubemapFace, $depthSlice: number);
            constructor($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer);
            constructor($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer, $mipLevel: number);
            constructor($color: System.Array$1<UnityEngine.RenderBuffer>, $depth: UnityEngine.RenderBuffer, $mip: number, $face: UnityEngine.CubemapFace);
        }

        class RenderParams {
            protected [__keep_incompatibility]: never;
            public layer: number;
            public renderingLayerMask: number;
            public rendererPriority: number;
            public instanceID: number;
            public entityId: UnityEngine.EntityId;
            public worldBounds: UnityEngine.Bounds;
            public camera: UnityEngine.Camera;
            public motionVectorMode: UnityEngine.MotionVectorGenerationMode;
            public reflectionProbeUsage: UnityEngine.Rendering.ReflectionProbeUsage;
            public material: UnityEngine.Material;
            public matProps: UnityEngine.MaterialPropertyBlock;
            public shadowCastingMode: UnityEngine.Rendering.ShadowCastingMode;
            public receiveShadows: boolean;
            public lightProbeUsage: UnityEngine.Rendering.LightProbeUsage;
            public lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume;
            public overrideSceneCullingMask: boolean;
            public sceneCullingMask: bigint;
            public forceMeshLod: number;
            public meshLodSelectionBias: number;
            constructor($mat: UnityEngine.Material);
        }

        class QualitySettings extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public static currentLevel: UnityEngine.QualityLevel;
            public static pixelLightCount: number;
            public static shadows: UnityEngine.ShadowQuality;
            public static shadowProjection: UnityEngine.ShadowProjection;
            public static shadowCascades: number;
            public static shadowDistance: number;
            public static shadowResolution: UnityEngine.ShadowResolution;
            public static shadowmaskMode: UnityEngine.ShadowmaskMode;
            public static shadowNearPlaneOffset: number;
            public static shadowCascade2Split: number;
            public static shadowCascade4Split: UnityEngine.Vector3;
            public static lodBias: number;
            public static meshLodThreshold: number;
            public static anisotropicFiltering: UnityEngine.AnisotropicFiltering;
            public static masterTextureLimit: number;
            public static globalTextureMipmapLimit: number;
            public static maximumLODLevel: number;
            public static enableLODCrossFade: boolean;
            public static particleRaycastBudget: number;
            public static softParticles: boolean;
            public static softVegetation: boolean;
            public static vSyncCount: number;
            public static realtimeGICPUUsage: number;
            public static antiAliasing: number;
            public static asyncUploadTimeSlice: number;
            public static asyncUploadBufferSize: number;
            public static asyncUploadPersistentBuffer: boolean;
            public static realtimeReflectionProbes: boolean;
            public static billboardsFaceCameraPosition: boolean;
            public static useLegacyDetailDistribution: boolean;
            public static resolutionScalingFixedDPIFactor: number;
            public static terrainQualityOverrides: UnityEngine.TerrainQualityOverrides;
            public static terrainPixelError: number;
            public static terrainDetailDensityScale: number;
            public static terrainBasemapDistance: number;
            public static terrainDetailDistance: number;
            public static terrainTreeDistance: number;
            public static terrainBillboardStart: number;
            public static terrainFadeLength: number;
            public static terrainMaxTrees: number;
            public static renderPipeline: UnityEngine.Rendering.RenderPipelineAsset;
            public static skinWeights: UnityEngine.SkinWeights;
            public static get count(): number;
            public static streamingMipmapsActive: boolean;
            public static streamingMipmapsMemoryBudget: number;
            public static streamingMipmapsRenderersPerFrame: number;
            public static streamingMipmapsMaxLevelReduction: number;
            public static streamingMipmapsAddAllCameras: boolean;
            public static streamingMipmapsMaxFileIORequests: number;
            public static maxQueuedFrames: number;
            public static get names(): System.Array$1<string>;
            public static get desiredColorSpace(): UnityEngine.ColorSpace;
            public static get activeColorSpace(): UnityEngine.ColorSpace;
            public static IncreaseLevel($applyExpensiveChanges: boolean): void;
            public static DecreaseLevel($applyExpensiveChanges: boolean): void;
            public static SetQualityLevel($index: number): void;
            public static IncreaseLevel(): void;
            public static DecreaseLevel(): void;
            public static ForEach($callback: System.Action): void;
            public static ForEach($callback: System.Action$2<number, string>): void;
            public static SetLODSettings($lodBias: number, $maximumLODLevel: number, $setDirty?: boolean): void;
            public static SetTextureMipmapLimitSettings($groupName: string, $textureMipmapLimitSettings: UnityEngine.TextureMipmapLimitSettings): void;
            public static GetTextureMipmapLimitSettings($groupName: string): UnityEngine.TextureMipmapLimitSettings;
            public static GetRenderPipelineAssetAt($index: number): UnityEngine.Rendering.RenderPipelineAsset;
            public static GetQualityLevel(): number;
            public static GetQualitySettings(): UnityEngine.Object;
            public static SetQualityLevel($index: number, $applyExpensiveChanges: boolean): void;
            public static IsPlatformIncluded($buildTargetGroupName: string, $index: number): boolean;
            public static TryIncludePlatformAt($buildTargetGroupName: string, $index: number, $error: $Out<System.Exception>): boolean;
            public static TryExcludePlatformAt($buildTargetGroupName: string, $index: number, $error: $Out<System.Exception>): boolean;
            public static GetActiveQualityLevelsForPlatform($buildTargetGroupName: string): System.Array$1<number>;
            public static GetActiveQualityLevelsForPlatformCount($buildTargetGroupName: string): number;
            public static GetRenderPipelineAssetsForPlatform<T extends UnityEngine.Rendering.RenderPipelineAsset>($buildTargetGroupName: string, $uniqueRenderPipelineAssets: $Out<System.Collections.Generic.HashSet$1<T>>): void;
            public static GetRenderPipelineAssetsForPlatform<T extends UnityEngine.Rendering.RenderPipelineAsset>($buildTargetGroupName: string, $uniqueRenderPipelineAssets: $Out<System.Collections.Generic.HashSet$1<T>>, $allLevelsAreOverridden: $Out<boolean>): void;
            public static GetAllRenderPipelineAssetsForPlatform($buildTargetGroupName: string, $renderPipelineAssets: $Ref<System.Collections.Generic.List$1<UnityEngine.Rendering.RenderPipelineAsset>>): void;
            public static add_activeQualityLevelChanged(handler: System.Action$2<number, number>): void;
            public static remove_activeQualityLevelChanged(handler: System.Action$2<number, number>): void;
            public static add_activeQualityLevelRenamed(handler: System.Action$2<string, string>): void;
            public static remove_activeQualityLevelRenamed(handler: System.Action$2<string, string>): void;
        }

        class RendererExtensions {
            protected [__keep_incompatibility]: never;
            public static UpdateGIMaterials(): void;
        }

        class ImageEffectTransformsToLDR extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class ImageEffectAllowedInSceneView extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class ImageEffectOpaque extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class ImageEffectAfterScale extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class ImageEffectUsesCommandBuffer extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class Mesh extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public indexFormat: UnityEngine.Rendering.IndexFormat;
            public get vertexBufferCount(): number;
            public vertexBufferTarget: UnityEngine.GraphicsBuffer.Target;
            public indexBufferTarget: UnityEngine.GraphicsBuffer.Target;
            public get blendShapeCount(): number;
            public get bindposeCount(): number;
            public bindposes: System.Array$1<UnityEngine.Matrix4x4>;
            public get isReadable(): boolean;
            public get vertexCount(): number;
            public subMeshCount: number;
            public bounds: UnityEngine.Bounds;
            public vertices: System.Array$1<UnityEngine.Vector3>;
            public normals: System.Array$1<UnityEngine.Vector3>;
            public tangents: System.Array$1<UnityEngine.Vector4>;
            public uv: System.Array$1<UnityEngine.Vector2>;
            public uv2: System.Array$1<UnityEngine.Vector2>;
            public uv3: System.Array$1<UnityEngine.Vector2>;
            public uv4: System.Array$1<UnityEngine.Vector2>;
            public uv5: System.Array$1<UnityEngine.Vector2>;
            public uv6: System.Array$1<UnityEngine.Vector2>;
            public uv7: System.Array$1<UnityEngine.Vector2>;
            public uv8: System.Array$1<UnityEngine.Vector2>;
            public colors: System.Array$1<UnityEngine.Color>;
            public colors32: System.Array$1<UnityEngine.Color32>;
            public lodCount: number;
            public lodSelectionCurve: UnityEngine.Mesh.LodSelectionCurve;
            public get vertexAttributeCount(): number;
            public triangles: System.Array$1<number>;
            public boneWeights: System.Array$1<UnityEngine.BoneWeight>;
            public get skinWeightBufferLayout(): UnityEngine.SkinWeights;
            constructor();
            public SetIndexBufferParams($indexCount: number, $format: UnityEngine.Rendering.IndexFormat): void;
            public GetVertexAttribute($index: number): UnityEngine.Rendering.VertexAttributeDescriptor;
            public HasVertexAttribute($attr: UnityEngine.Rendering.VertexAttribute): boolean;
            public GetVertexAttributeDimension($attr: UnityEngine.Rendering.VertexAttribute): number;
            public GetVertexAttributeFormat($attr: UnityEngine.Rendering.VertexAttribute): UnityEngine.Rendering.VertexAttributeFormat;
            public GetVertexAttributeStream($attr: UnityEngine.Rendering.VertexAttribute): number;
            public GetVertexAttributeOffset($attr: UnityEngine.Rendering.VertexAttribute): number;
            public GetVertexBufferStride($stream: number): number;
            public GetNativeVertexBufferPtr($index: number): number;
            public GetNativeIndexBufferPtr(): number;
            public ClearBlendShapes(): void;
            public GetBlendShapeName($shapeIndex: number): string;
            public GetBlendShapeIndex($blendShapeName: string): number;
            public GetBlendShapeFrameCount($shapeIndex: number): number;
            public GetBlendShapeFrameWeight($shapeIndex: number, $frameIndex: number): number;
            public GetBlendShapeFrameVertices($shapeIndex: number, $frameIndex: number, $deltaVertices: System.Array$1<UnityEngine.Vector3>, $deltaNormals: System.Array$1<UnityEngine.Vector3>, $deltaTangents: System.Array$1<UnityEngine.Vector3>): void;
            public AddBlendShapeFrame($shapeName: string, $frameWeight: number, $deltaVertices: System.ReadOnlySpan$1<UnityEngine.Vector3>, $deltaNormals: System.ReadOnlySpan$1<UnityEngine.Vector3>, $deltaTangents: System.ReadOnlySpan$1<UnityEngine.Vector3>): void;
            public AddBlendShapeFrame($shapeName: string, $frameWeight: number, $deltaVertices: System.Array$1<UnityEngine.Vector3>, $deltaNormals: System.Array$1<UnityEngine.Vector3>, $deltaTangents: System.Array$1<UnityEngine.Vector3>): void;
            public SetBoneWeights($bonesPerVertex: Unity.Collections.NativeArray$1<number>, $weights: Unity.Collections.NativeArray$1<UnityEngine.BoneWeight1>): void;
            public GetAllBoneWeights(): Unity.Collections.NativeArray$1<UnityEngine.BoneWeight1>;
            public GetBonesPerVertex(): Unity.Collections.NativeArray$1<number>;
            public GetBindposes(): Unity.Collections.NativeArray$1<UnityEngine.Matrix4x4>;
            public SetBindposes($poses: Unity.Collections.NativeArray$1<UnityEngine.Matrix4x4>): void;
            public SetSubMesh($index: number, $desc: UnityEngine.Rendering.SubMeshDescriptor, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public GetSubMesh($index: number): UnityEngine.Rendering.SubMeshDescriptor;
            public GetLod($subMeshIndex: number, $levelIndex: number): UnityEngine.MeshLodRange;
            public MarkModified(): void;
            public GetUVDistributionMetric($uvSetIndex: number): number;
            public GetVertices($vertices: System.Collections.Generic.List$1<UnityEngine.Vector3>): void;
            public SetVertices($inVertices: System.Collections.Generic.List$1<UnityEngine.Vector3>): void;
            public SetVertices($inVertices: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number): void;
            public SetVertices($inVertices: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetVertices($inVertices: System.Array$1<UnityEngine.Vector3>): void;
            public SetVertices($inVertices: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number): void;
            public SetVertices($inVertices: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetVertices<T>($inVertices: Unity.Collections.NativeArray$1<T>): void;
            public SetVertices<T>($inVertices: Unity.Collections.NativeArray$1<T>, $start: number, $length: number): void;
            public SetVertices<T>($inVertices: Unity.Collections.NativeArray$1<T>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public GetNormals($normals: System.Collections.Generic.List$1<UnityEngine.Vector3>): void;
            public SetNormals($inNormals: System.Collections.Generic.List$1<UnityEngine.Vector3>): void;
            public SetNormals($inNormals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number): void;
            public SetNormals($inNormals: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetNormals($inNormals: System.Array$1<UnityEngine.Vector3>): void;
            public SetNormals($inNormals: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number): void;
            public SetNormals($inNormals: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetNormals<T>($inNormals: Unity.Collections.NativeArray$1<T>): void;
            public SetNormals<T>($inNormals: Unity.Collections.NativeArray$1<T>, $start: number, $length: number): void;
            public SetNormals<T>($inNormals: Unity.Collections.NativeArray$1<T>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public GetTangents($tangents: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public SetTangents($inTangents: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public SetTangents($inTangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number): void;
            public SetTangents($inTangents: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetTangents($inTangents: System.Array$1<UnityEngine.Vector4>): void;
            public SetTangents($inTangents: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number): void;
            public SetTangents($inTangents: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetTangents<T>($inTangents: Unity.Collections.NativeArray$1<T>): void;
            public SetTangents<T>($inTangents: Unity.Collections.NativeArray$1<T>, $start: number, $length: number): void;
            public SetTangents<T>($inTangents: Unity.Collections.NativeArray$1<T>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public GetColors($colors: System.Collections.Generic.List$1<UnityEngine.Color>): void;
            public SetColors($inColors: System.Collections.Generic.List$1<UnityEngine.Color>): void;
            public SetColors($inColors: System.Collections.Generic.List$1<UnityEngine.Color>, $start: number, $length: number): void;
            public SetColors($inColors: System.Collections.Generic.List$1<UnityEngine.Color>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetColors($inColors: System.Array$1<UnityEngine.Color>): void;
            public SetColors($inColors: System.Array$1<UnityEngine.Color>, $start: number, $length: number): void;
            public SetColors($inColors: System.Array$1<UnityEngine.Color>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public GetColors($colors: System.Collections.Generic.List$1<UnityEngine.Color32>): void;
            public SetColors($inColors: System.Collections.Generic.List$1<UnityEngine.Color32>): void;
            public SetColors($inColors: System.Collections.Generic.List$1<UnityEngine.Color32>, $start: number, $length: number): void;
            public SetColors($inColors: System.Collections.Generic.List$1<UnityEngine.Color32>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetColors($inColors: System.Array$1<UnityEngine.Color32>): void;
            public SetColors($inColors: System.Array$1<UnityEngine.Color32>, $start: number, $length: number): void;
            public SetColors($inColors: System.Array$1<UnityEngine.Color32>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetColors<T>($inColors: Unity.Collections.NativeArray$1<T>): void;
            public SetColors<T>($inColors: Unity.Collections.NativeArray$1<T>, $start: number, $length: number): void;
            public SetColors<T>($inColors: Unity.Collections.NativeArray$1<T>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>): void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>): void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>, $start: number, $length: number): void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number): void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number): void;
            public SetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector2>): void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector3>): void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector4>): void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector2>, $start: number, $length: number): void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector2>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number): void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector3>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number): void;
            public SetUVs($channel: number, $uvs: System.Array$1<UnityEngine.Vector4>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetUVs<T>($channel: number, $uvs: Unity.Collections.NativeArray$1<T>): void;
            public SetUVs<T>($channel: number, $uvs: Unity.Collections.NativeArray$1<T>, $start: number, $length: number): void;
            public SetUVs<T>($channel: number, $uvs: Unity.Collections.NativeArray$1<T>, $start: number, $length: number, $flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public GetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector2>): void;
            public GetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector3>): void;
            public GetUVs($channel: number, $uvs: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public GetVertexAttributes(): System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>;
            public GetVertexAttributes($attributes: System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>): number;
            public GetVertexAttributes($attributes: System.Collections.Generic.List$1<UnityEngine.Rendering.VertexAttributeDescriptor>): number;
            public SetVertexBufferParams($vertexCount: number, ...attributes: UnityEngine.Rendering.VertexAttributeDescriptor[]): void;
            public SetVertexBufferParams($vertexCount: number, $attributes: Unity.Collections.NativeArray$1<UnityEngine.Rendering.VertexAttributeDescriptor>): void;
            public SetVertexBufferData<T>($data: Unity.Collections.NativeArray$1<T>, $dataStart: number, $meshBufferStart: number, $count: number, $stream?: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetVertexBufferData<T>($data: System.Array$1<T>, $dataStart: number, $meshBufferStart: number, $count: number, $stream?: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetVertexBufferData<T>($data: System.Collections.Generic.List$1<T>, $dataStart: number, $meshBufferStart: number, $count: number, $stream?: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public static AcquireReadOnlyMeshData($mesh: UnityEngine.Mesh): UnityEngine.Mesh.MeshDataArray;
            public static AcquireReadOnlyMeshData($meshes: System.Array$1<UnityEngine.Mesh>): UnityEngine.Mesh.MeshDataArray;
            public static AcquireReadOnlyMeshData($meshes: System.Collections.Generic.List$1<UnityEngine.Mesh>): UnityEngine.Mesh.MeshDataArray;
            public static AllocateWritableMeshData($meshCount: number): UnityEngine.Mesh.MeshDataArray;
            public static AllocateWritableMeshData($mesh: UnityEngine.Mesh): UnityEngine.Mesh.MeshDataArray;
            public static AllocateWritableMeshData($meshes: System.Array$1<UnityEngine.Mesh>): UnityEngine.Mesh.MeshDataArray;
            public static AllocateWritableMeshData($meshes: System.Collections.Generic.List$1<UnityEngine.Mesh>): UnityEngine.Mesh.MeshDataArray;
            public static ApplyAndDisposeWritableMeshData($data: UnityEngine.Mesh.MeshDataArray, $mesh: UnityEngine.Mesh, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public static ApplyAndDisposeWritableMeshData($data: UnityEngine.Mesh.MeshDataArray, $meshes: System.Array$1<UnityEngine.Mesh>, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public static ApplyAndDisposeWritableMeshData($data: UnityEngine.Mesh.MeshDataArray, $meshes: System.Collections.Generic.List$1<UnityEngine.Mesh>, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public GetVertexBuffer($index: number): UnityEngine.GraphicsBuffer;
            public GetIndexBuffer(): UnityEngine.GraphicsBuffer;
            public GetBoneWeightBuffer($layout: UnityEngine.SkinWeights): UnityEngine.GraphicsBuffer;
            public GetBlendShapeBuffer($layout: UnityEngine.Rendering.BlendShapeBufferLayout): UnityEngine.GraphicsBuffer;
            public GetBlendShapeBuffer(): UnityEngine.GraphicsBuffer;
            public GetBlendShapeBufferRange($blendShapeIndex: number): UnityEngine.BlendShapeBufferRange;
            public GetTriangles($submesh: number): System.Array$1<number>;
            public GetTriangles($submesh: number, $applyBaseVertex: boolean): System.Array$1<number>;
            public GetTriangles($submesh: number, $meshLod: number, $applyBaseVertex: boolean): System.Array$1<number>;
            public GetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number): void;
            public GetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex: boolean): void;
            public GetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $meshLod: number, $applyBaseVertex?: boolean): void;
            public GetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex?: boolean): void;
            public GetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $meshLod: number, $applyBaseVertex?: boolean): void;
            public GetIndices($submesh: number): System.Array$1<number>;
            public GetIndices($submesh: number, $applyBaseVertex: boolean): System.Array$1<number>;
            public GetIndices($submesh: number, $meshLod: number, $applyBaseVertex?: boolean): System.Array$1<number>;
            public GetIndices($indices: System.Collections.Generic.List$1<number>, $submesh: number): void;
            public GetIndices($indices: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex: boolean): void;
            public GetIndices($indices: System.Collections.Generic.List$1<number>, $submesh: number, $meshLod: number, $applyBaseVertex?: boolean): void;
            public GetIndices($indices: System.Collections.Generic.List$1<number>, $submesh: number, $applyBaseVertex?: boolean): void;
            public GetIndices($indices: System.Collections.Generic.List$1<number>, $submesh: number, $meshLod: number, $applyBaseVertex?: boolean): void;
            public SetIndexBufferData<T>($data: Unity.Collections.NativeArray$1<T>, $dataStart: number, $meshBufferStart: number, $count: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetIndexBufferData<T>($data: System.Array$1<T>, $dataStart: number, $meshBufferStart: number, $count: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetIndexBufferData<T>($data: System.Collections.Generic.List$1<T>, $dataStart: number, $meshBufferStart: number, $count: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public GetIndexStart($submesh: number): number;
            public GetIndexStart($submesh: number, $meshLod: number): number;
            public GetIndexCount($submesh: number): number;
            public GetIndexCount($submesh: number, $meshLod: number): number;
            public GetBaseVertex($submesh: number): number;
            public SetTriangles($triangles: System.Array$1<number>, $submesh: number): void;
            public SetTriangles($triangles: System.Array$1<number>, $submesh: number, $calculateBounds: boolean): void;
            public SetTriangles($triangles: System.Array$1<number>, $submesh: number, $calculateBounds: boolean, $baseVertex: number): void;
            public SetTriangles($triangles: System.Array$1<number>, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetTriangles($triangles: System.Array$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetTriangles($triangles: System.Array$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetTriangles($triangles: System.Array$1<number>, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetTriangles($triangles: System.Array$1<number>, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetTriangles($triangles: System.Array$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetTriangles($triangles: System.Array$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number): void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $calculateBounds: boolean): void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $calculateBounds: boolean, $baseVertex: number): void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetTriangles($triangles: System.Collections.Generic.List$1<number>, $trianglesStart: number, $trianglesLength: number, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number): void;
            public SetIndices($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds: boolean): void;
            public SetIndices($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds: boolean, $baseVertex: number): void;
            public SetIndices($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Array$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Array$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Array$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Array$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Array$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices<T>($indices: Unity.Collections.NativeArray$1<T>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices<T>($indices: Unity.Collections.NativeArray$1<T>, $topology: UnityEngine.MeshTopology, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices<T>($indices: Unity.Collections.NativeArray$1<T>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices<T>($indices: Unity.Collections.NativeArray$1<T>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Collections.Generic.List$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Collections.Generic.List$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Collections.Generic.List$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Collections.Generic.List$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Collections.Generic.List$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Collections.Generic.List$1<number>, $topology: UnityEngine.MeshTopology, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Collections.Generic.List$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetIndices($indices: System.Collections.Generic.List$1<number>, $indicesStart: number, $indicesLength: number, $topology: UnityEngine.MeshTopology, $submesh: number, $meshLod: number, $calculateBounds?: boolean, $baseVertex?: number): void;
            public SetSubMeshes($desc: System.Array$1<UnityEngine.Rendering.SubMeshDescriptor>, $start: number, $count: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetSubMeshes($desc: System.Array$1<UnityEngine.Rendering.SubMeshDescriptor>, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetSubMeshes($desc: System.Collections.Generic.List$1<UnityEngine.Rendering.SubMeshDescriptor>, $start: number, $count: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetSubMeshes($desc: System.Collections.Generic.List$1<UnityEngine.Rendering.SubMeshDescriptor>, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetSubMeshes<T>($desc: Unity.Collections.NativeArray$1<T>, $start: number, $count: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetSubMeshes<T>($desc: Unity.Collections.NativeArray$1<T>, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetLod($submesh: number, $level: number, $levelRange: UnityEngine.MeshLodRange, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetLods($levels: System.Collections.Generic.List$1<UnityEngine.MeshLodRange>, $submesh: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetLods($levels: System.Collections.Generic.List$1<UnityEngine.MeshLodRange>, $start: number, $count: number, $submesh: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetLods($levels: System.Array$1<UnityEngine.MeshLodRange>, $submesh: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetLods($levels: System.Array$1<UnityEngine.MeshLodRange>, $start: number, $count: number, $submesh: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetLods($levels: Unity.Collections.NativeArray$1<UnityEngine.MeshLodRange>, $submesh: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public SetLods($levels: Unity.Collections.NativeArray$1<UnityEngine.MeshLodRange>, $start: number, $count: number, $submesh: number, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            public GetLods($submesh: number): System.Array$1<UnityEngine.MeshLodRange>;
            public GetLods($levels: System.Collections.Generic.List$1<UnityEngine.MeshLodRange>, $submesh: number): void;
            public GetBindposes($bindposes: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
            public GetBoneWeights($boneWeights: System.Collections.Generic.List$1<UnityEngine.BoneWeight>): void;
            public Clear($keepVertexLayout: boolean): void;
            public Clear(): void;
            public RecalculateBounds(): void;
            public RecalculateNormals(): void;
            public RecalculateTangents(): void;
            public RecalculateBounds($flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public RecalculateNormals($flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public RecalculateTangents($flags: UnityEngine.Rendering.MeshUpdateFlags): void;
            public RecalculateUVDistributionMetric($uvSetIndex: number, $uvAreaThreshold?: number): void;
            public RecalculateUVDistributionMetrics($uvAreaThreshold?: number): void;
            public MarkDynamic(): void;
            public UploadMeshData($markNoLongerReadable: boolean): void;
            public Optimize(): void;
            public OptimizeIndexBuffers(): void;
            public OptimizeReorderVertexBuffer(): void;
            public GetTopology($submesh: number): UnityEngine.MeshTopology;
            public CombineMeshes($combine: System.Array$1<UnityEngine.CombineInstance>, $mergeSubMeshes: boolean, $useMatrices: boolean, $hasLightmapData: boolean): void;
            public CombineMeshes($combine: System.Array$1<UnityEngine.CombineInstance>, $mergeSubMeshes: boolean, $useMatrices: boolean): void;
            public CombineMeshes($combine: System.Array$1<UnityEngine.CombineInstance>, $mergeSubMeshes: boolean): void;
            public CombineMeshes($combine: System.Array$1<UnityEngine.CombineInstance>): void;
        }
        namespace Mesh {
            class LodSelectionCurve {
                protected [__keep_incompatibility]: never;
                public lodSlope: number;
                public lodBias: number;
                constructor($slope: number, $bias: number);
                public IsValid(): boolean;
            }

            class MeshData {
                protected [__keep_incompatibility]: never;
                public get vertexCount(): number;
                public get vertexBufferCount(): number;
                public get indexFormat(): UnityEngine.Rendering.IndexFormat;
                public subMeshCount: number;
                public lodCount: number;
                public lodSelectionCurve: UnityEngine.Mesh.LodSelectionCurve;
                public GetVertexBufferStride($stream: number): number;
                public HasVertexAttribute($attr: UnityEngine.Rendering.VertexAttribute): boolean;
                public GetVertexAttributeDimension($attr: UnityEngine.Rendering.VertexAttribute): number;
                public GetVertexAttributeFormat($attr: UnityEngine.Rendering.VertexAttribute): UnityEngine.Rendering.VertexAttributeFormat;
                public GetVertexAttributeStream($attr: UnityEngine.Rendering.VertexAttribute): number;
                public GetVertexAttributeOffset($attr: UnityEngine.Rendering.VertexAttribute): number;
                public GetVertices($outVertices: Unity.Collections.NativeArray$1<UnityEngine.Vector3>): void;
                public GetNormals($outNormals: Unity.Collections.NativeArray$1<UnityEngine.Vector3>): void;
                public GetTangents($outTangents: Unity.Collections.NativeArray$1<UnityEngine.Vector4>): void;
                public GetColors($outColors: Unity.Collections.NativeArray$1<UnityEngine.Color>): void;
                public GetColors($outColors: Unity.Collections.NativeArray$1<UnityEngine.Color32>): void;
                public GetUVs($channel: number, $outUVs: Unity.Collections.NativeArray$1<UnityEngine.Vector2>): void;
                public GetUVs($channel: number, $outUVs: Unity.Collections.NativeArray$1<UnityEngine.Vector3>): void;
                public GetUVs($channel: number, $outUVs: Unity.Collections.NativeArray$1<UnityEngine.Vector4>): void;
                public GetVertexData<T>($stream?: number): Unity.Collections.NativeArray$1<T>;
                public SetVertexBufferParams($vertexCount: number, ...attributes: UnityEngine.Rendering.VertexAttributeDescriptor[]): void;
                public SetVertexBufferParams($vertexCount: number, $attributes: Unity.Collections.NativeArray$1<UnityEngine.Rendering.VertexAttributeDescriptor>): void;
                public SetIndexBufferParams($indexCount: number, $format: UnityEngine.Rendering.IndexFormat): void;
                public GetIndices($outIndices: Unity.Collections.NativeArray$1<number>, $submesh: number, $applyBaseVertex?: boolean): void;
                public GetIndices($outIndices: Unity.Collections.NativeArray$1<number>, $submesh: number, $meshlod: number, $applyBaseVertex?: boolean): void;
                public GetIndices($outIndices: Unity.Collections.NativeArray$1<number>, $submesh: number, $applyBaseVertex?: boolean): void;
                public GetIndices($outIndices: Unity.Collections.NativeArray$1<number>, $submesh: number, $meshlod: number, $applyBaseVertex?: boolean): void;
                public GetIndexData<T>(): Unity.Collections.NativeArray$1<T>;
                public GetLod($submesh: number, $level: number): UnityEngine.MeshLodRange;
                public SetLod($submesh: number, $level: number, $levelRange: UnityEngine.MeshLodRange, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
                public GetSubMesh($index: number): UnityEngine.Rendering.SubMeshDescriptor;
                public SetSubMesh($index: number, $desc: UnityEngine.Rendering.SubMeshDescriptor, $flags?: UnityEngine.Rendering.MeshUpdateFlags): void;
            }

            class MeshDataArray implements System.IDisposable {
                protected [__keep_incompatibility]: never;
                public get Length(): number;
                public Dispose(): void;
                public get_Item($index: number): UnityEngine.Mesh.MeshData;
            }

        }

        class Renderer extends UnityEngine.Component {
            protected [__keep_incompatibility]: never;
            public castShadows: boolean;
            public motionVectors: boolean;
            public useLightProbes: boolean;
            public bounds: UnityEngine.Bounds;
            public localBounds: UnityEngine.Bounds;
            public enabled: boolean;
            public get isVisible(): boolean;
            public shadowCastingMode: UnityEngine.Rendering.ShadowCastingMode;
            public receiveShadows: boolean;
            public forceRenderingOff: boolean;
            public staticShadowCaster: boolean;
            public motionVectorGenerationMode: UnityEngine.MotionVectorGenerationMode;
            public lightProbeUsage: UnityEngine.Rendering.LightProbeUsage;
            public reflectionProbeUsage: UnityEngine.Rendering.ReflectionProbeUsage;
            public renderingLayerMask: number;
            public rendererPriority: number;
            public rayTracingMode: UnityEngine.Experimental.Rendering.RayTracingMode;
            public rayTracingAccelerationStructureBuildFlags: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
            public rayTracingAccelerationStructureBuildFlagsOverride: boolean;
            public sortingLayerName: string;
            public sortingLayerID: number;
            public sortingOrder: number;
            public get isLOD0(): boolean;
            public allowOcclusionWhenDynamic: boolean;
            public forceMeshLod: number;
            public meshLodSelectionBias: number;
            public get isPartOfStaticBatch(): boolean;
            public get worldToLocalMatrix(): UnityEngine.Matrix4x4;
            public get localToWorldMatrix(): UnityEngine.Matrix4x4;
            public lightProbeProxyVolumeOverride: UnityEngine.GameObject;
            public probeAnchor: UnityEngine.Transform;
            public lightmapIndex: number;
            public realtimeLightmapIndex: number;
            public lightmapScaleOffset: UnityEngine.Vector4;
            public realtimeLightmapScaleOffset: UnityEngine.Vector4;
            public materials: System.Array$1<UnityEngine.Material>;
            public material: UnityEngine.Material;
            public sharedMaterial: UnityEngine.Material;
            public sharedMaterials: System.Array$1<UnityEngine.Material>;
            public get LODGroup(): UnityEngine.LODGroup;
            constructor();
            public ResetBounds(): void;
            public ResetLocalBounds(): void;
            public HasPropertyBlock(): boolean;
            public SetPropertyBlock($properties: UnityEngine.MaterialPropertyBlock): void;
            public SetPropertyBlock($properties: UnityEngine.MaterialPropertyBlock, $materialIndex: number): void;
            public GetPropertyBlock($properties: UnityEngine.MaterialPropertyBlock): void;
            public GetPropertyBlock($properties: UnityEngine.MaterialPropertyBlock, $materialIndex: number): void;
            public GetMaterials($m: System.Collections.Generic.List$1<UnityEngine.Material>): void;
            public SetSharedMaterials($materials: System.Collections.Generic.List$1<UnityEngine.Material>): void;
            public SetMaterials($materials: System.Collections.Generic.List$1<UnityEngine.Material>): void;
            public GetSharedMaterials($m: System.Collections.Generic.List$1<UnityEngine.Material>): void;
            public GetClosestReflectionProbes($result: System.Collections.Generic.List$1<UnityEngine.Rendering.ReflectionProbeBlendInfo>): void;
        }

        class Projector extends UnityEngine.Behaviour {
            protected [__keep_incompatibility]: never;
            public nearClipPlane: number;
            public farClipPlane: number;
            public fieldOfView: number;
            public aspectRatio: number;
            public orthographic: boolean;
            public orthographicSize: number;
            public ignoreLayers: number;
            public material: UnityEngine.Material;
            constructor();
        }

        class Shader extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public static maximumChunksOverride: number;
            public maximumLOD: number;
            public static globalMaximumLOD: number;
            public get isSupported(): boolean;
            public static globalRenderPipeline: string;
            public static get enabledGlobalKeywords(): System.Array$1<UnityEngine.Rendering.GlobalKeyword>;
            public static get globalKeywords(): System.Array$1<UnityEngine.Rendering.GlobalKeyword>;
            public get keywordSpace(): UnityEngine.Rendering.LocalKeywordSpace;
            public get renderQueue(): number;
            public get passCount(): number;
            public get subshaderCount(): number;
            public static Find($name: string): UnityEngine.Shader;
            public static EnableKeyword($keyword: string): void;
            public static DisableKeyword($keyword: string): void;
            public static IsKeywordEnabled($keyword: string): boolean;
            public static EnableKeyword($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>): void;
            public static DisableKeyword($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>): void;
            public static SetKeyword($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>, $value: boolean): void;
            public static IsKeywordEnabled($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>): boolean;
            public static WarmupAllShaders(): void;
            public static PropertyToID($name: string): number;
            public GetDependency($name: string): UnityEngine.Shader;
            public GetPassCountInSubshader($subshaderIndex: number): number;
            public FindPassTagValue($passIndex: number, $tagName: UnityEngine.Rendering.ShaderTagId): UnityEngine.Rendering.ShaderTagId;
            public FindPassTagValue($subshaderIndex: number, $passIndex: number, $tagName: UnityEngine.Rendering.ShaderTagId): UnityEngine.Rendering.ShaderTagId;
            public FindSubshaderTagValue($subshaderIndex: number, $tagName: UnityEngine.Rendering.ShaderTagId): UnityEngine.Rendering.ShaderTagId;
            public static SetGlobalInt($name: string, $value: number): void;
            public static SetGlobalInt($nameID: number, $value: number): void;
            public static SetGlobalFloat($name: string, $value: number): void;
            public static SetGlobalFloat($nameID: number, $value: number): void;
            public static SetGlobalInteger($name: string, $value: number): void;
            public static SetGlobalInteger($nameID: number, $value: number): void;
            public static SetGlobalVector($name: string, $value: UnityEngine.Vector4): void;
            public static SetGlobalVector($nameID: number, $value: UnityEngine.Vector4): void;
            public static SetGlobalColor($name: string, $value: UnityEngine.Color): void;
            public static SetGlobalColor($nameID: number, $value: UnityEngine.Color): void;
            public static SetGlobalMatrix($name: string, $value: UnityEngine.Matrix4x4): void;
            public static SetGlobalMatrix($nameID: number, $value: UnityEngine.Matrix4x4): void;
            public static SetGlobalTexture($name: string, $value: UnityEngine.Texture): void;
            public static SetGlobalTexture($nameID: number, $value: UnityEngine.Texture): void;
            public static SetGlobalTexture($name: string, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement): void;
            public static SetGlobalTexture($nameID: number, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement): void;
            public static SetGlobalBuffer($name: string, $value: UnityEngine.ComputeBuffer): void;
            public static SetGlobalBuffer($nameID: number, $value: UnityEngine.ComputeBuffer): void;
            public static SetGlobalBuffer($name: string, $value: UnityEngine.GraphicsBuffer): void;
            public static SetGlobalBuffer($nameID: number, $value: UnityEngine.GraphicsBuffer): void;
            public static SetGlobalConstantBuffer($name: string, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number): void;
            public static SetGlobalConstantBuffer($nameID: number, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number): void;
            public static SetGlobalConstantBuffer($name: string, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number): void;
            public static SetGlobalConstantBuffer($nameID: number, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number): void;
            public static SetGlobalRayTracingAccelerationStructure($name: string, $value: UnityEngine.Rendering.RayTracingAccelerationStructure): void;
            public static SetGlobalRayTracingAccelerationStructure($nameID: number, $value: UnityEngine.Rendering.RayTracingAccelerationStructure): void;
            public static SetGlobalFloatArray($name: string, $values: System.Collections.Generic.List$1<number>): void;
            public static SetGlobalFloatArray($nameID: number, $values: System.Collections.Generic.List$1<number>): void;
            public static SetGlobalFloatArray($name: string, $values: System.Array$1<number>): void;
            public static SetGlobalFloatArray($nameID: number, $values: System.Array$1<number>): void;
            public static SetGlobalVectorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public static SetGlobalVectorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public static SetGlobalVectorArray($name: string, $values: System.Array$1<UnityEngine.Vector4>): void;
            public static SetGlobalVectorArray($nameID: number, $values: System.Array$1<UnityEngine.Vector4>): void;
            public static SetGlobalMatrixArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
            public static SetGlobalMatrixArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
            public static SetGlobalMatrixArray($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>): void;
            public static SetGlobalMatrixArray($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>): void;
            public static GetGlobalInt($name: string): number;
            public static GetGlobalInt($nameID: number): number;
            public static GetGlobalFloat($name: string): number;
            public static GetGlobalFloat($nameID: number): number;
            public static GetGlobalInteger($name: string): number;
            public static GetGlobalInteger($nameID: number): number;
            public static GetGlobalVector($name: string): UnityEngine.Vector4;
            public static GetGlobalVector($nameID: number): UnityEngine.Vector4;
            public static GetGlobalColor($name: string): UnityEngine.Color;
            public static GetGlobalColor($nameID: number): UnityEngine.Color;
            public static GetGlobalMatrix($name: string): UnityEngine.Matrix4x4;
            public static GetGlobalMatrix($nameID: number): UnityEngine.Matrix4x4;
            public static GetGlobalTexture($name: string): UnityEngine.Texture;
            public static GetGlobalTexture($nameID: number): UnityEngine.Texture;
            public static GetGlobalFloatArray($name: string): System.Array$1<number>;
            public static GetGlobalFloatArray($nameID: number): System.Array$1<number>;
            public static GetGlobalVectorArray($name: string): System.Array$1<UnityEngine.Vector4>;
            public static GetGlobalVectorArray($nameID: number): System.Array$1<UnityEngine.Vector4>;
            public static GetGlobalMatrixArray($name: string): System.Array$1<UnityEngine.Matrix4x4>;
            public static GetGlobalMatrixArray($nameID: number): System.Array$1<UnityEngine.Matrix4x4>;
            public static GetGlobalFloatArray($name: string, $values: System.Collections.Generic.List$1<number>): void;
            public static GetGlobalFloatArray($nameID: number, $values: System.Collections.Generic.List$1<number>): void;
            public static GetGlobalVectorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public static GetGlobalVectorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public static GetGlobalMatrixArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
            public static GetGlobalMatrixArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
            public GetPropertyCount(): number;
            public FindPropertyIndex($propertyName: string): number;
            public GetPropertyName($propertyIndex: number): string;
            public GetPropertyNameId($propertyIndex: number): number;
            public GetPropertyType($propertyIndex: number): UnityEngine.Rendering.ShaderPropertyType;
            public GetPropertyDescription($propertyIndex: number): string;
            public GetPropertyFlags($propertyIndex: number): UnityEngine.Rendering.ShaderPropertyFlags;
            public GetPropertyAttributes($propertyIndex: number): System.Array$1<string>;
            public GetPropertyDefaultFloatValue($propertyIndex: number): number;
            public GetPropertyDefaultVectorValue($propertyIndex: number): UnityEngine.Vector4;
            public GetPropertyRangeLimits($propertyIndex: number): UnityEngine.Vector2;
            public GetPropertyDefaultIntValue($propertyIndex: number): number;
            public GetPropertyTextureDimension($propertyIndex: number): UnityEngine.Rendering.TextureDimension;
            public GetPropertyTextureDefaultName($propertyIndex: number): string;
            public FindTextureStack($propertyIndex: number, $stackName: $Out<string>, $layerIndex: $Out<number>): boolean;
        }

        enum LightmapsModeLegacy {
            Single = 0,
            Dual = 1,
            Directional = 2
        }

        class TrailRenderer extends UnityEngine.Renderer {
            protected [__keep_incompatibility]: never;
            public get numPositions(): number;
            public time: number;
            public startWidth: number;
            public endWidth: number;
            public widthMultiplier: number;
            public autodestruct: boolean;
            public emitting: boolean;
            public numCornerVertices: number;
            public numCapVertices: number;
            public minVertexDistance: number;
            public startColor: UnityEngine.Color;
            public endColor: UnityEngine.Color;
            public get positionCount(): number;
            public textureScale: UnityEngine.Vector2;
            public shadowBias: number;
            public generateLightingData: boolean;
            public applyActiveColorSpace: boolean;
            public textureMode: UnityEngine.LineTextureMode;
            public alignment: UnityEngine.LineAlignment;
            public maskInteraction: UnityEngine.SpriteMaskInteraction;
            public widthCurve: UnityEngine.AnimationCurve;
            public colorGradient: UnityEngine.Gradient;
            constructor();
            public SetPosition($index: number, $position: UnityEngine.Vector3): void;
            public GetPosition($index: number): UnityEngine.Vector3;
            public Clear(): void;
            public BakeMesh($mesh: UnityEngine.Mesh, $useTransform?: boolean): void;
            public BakeMesh($mesh: UnityEngine.Mesh, $camera: UnityEngine.Camera, $useTransform?: boolean): void;
            public GetPositions($positions: $Out<System.Array$1<UnityEngine.Vector3>>): number;
            public GetVisiblePositions($positions: $Out<System.Array$1<UnityEngine.Vector3>>): number;
            public SetPositions($positions: System.Array$1<UnityEngine.Vector3>): void;
            public AddPosition($position: UnityEngine.Vector3): void;
            public AddPositions($positions: System.Array$1<UnityEngine.Vector3>): void;
            public SetPositions($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>): void;
            public SetPositions($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>): void;
            public GetPositions($positions: $Out<Unity.Collections.NativeArray$1<UnityEngine.Vector3>>): number;
            public GetPositions($positions: $Out<Unity.Collections.NativeSlice$1<UnityEngine.Vector3>>): number;
            public GetVisiblePositions($positions: $Out<Unity.Collections.NativeArray$1<UnityEngine.Vector3>>): number;
            public GetVisiblePositions($positions: $Out<Unity.Collections.NativeSlice$1<UnityEngine.Vector3>>): number;
            public AddPositions($positions: $Out<Unity.Collections.NativeArray$1<UnityEngine.Vector3>>): void;
            public AddPositions($positions: $Out<Unity.Collections.NativeSlice$1<UnityEngine.Vector3>>): void;
        }

        class LineRenderer extends UnityEngine.Renderer {
            protected [__keep_incompatibility]: never;
            public numPositions: number;
            public startWidth: number;
            public endWidth: number;
            public widthMultiplier: number;
            public numCornerVertices: number;
            public numCapVertices: number;
            public useWorldSpace: boolean;
            public loop: boolean;
            public startColor: UnityEngine.Color;
            public endColor: UnityEngine.Color;
            public positionCount: number;
            public textureScale: UnityEngine.Vector2;
            public shadowBias: number;
            public generateLightingData: boolean;
            public applyActiveColorSpace: boolean;
            public textureMode: UnityEngine.LineTextureMode;
            public alignment: UnityEngine.LineAlignment;
            public maskInteraction: UnityEngine.SpriteMaskInteraction;
            public widthCurve: UnityEngine.AnimationCurve;
            public colorGradient: UnityEngine.Gradient;
            constructor();
            public SetWidth($start: number, $end: number): void;
            public SetColors($start: UnityEngine.Color, $end: UnityEngine.Color): void;
            public SetVertexCount($count: number): void;
            public SetPosition($index: number, $position: UnityEngine.Vector3): void;
            public GetPosition($index: number): UnityEngine.Vector3;
            public Simplify($tolerance: number): void;
            public BakeMesh($mesh: UnityEngine.Mesh, $useTransform?: boolean): void;
            public BakeMesh($mesh: UnityEngine.Mesh, $camera: UnityEngine.Camera, $useTransform?: boolean): void;
            public GetPositions($positions: $Out<System.Array$1<UnityEngine.Vector3>>): number;
            public SetPositions($positions: System.Array$1<UnityEngine.Vector3>): void;
            public SetPositions($positions: Unity.Collections.NativeArray$1<UnityEngine.Vector3>): void;
            public SetPositions($positions: Unity.Collections.NativeSlice$1<UnityEngine.Vector3>): void;
            public GetPositions($positions: $Out<Unity.Collections.NativeArray$1<UnityEngine.Vector3>>): number;
            public GetPositions($positions: $Out<Unity.Collections.NativeSlice$1<UnityEngine.Vector3>>): number;
        }

        class MaterialPropertyBlock {
            protected [__keep_incompatibility]: never;
            public get isEmpty(): boolean;
            constructor();
            public Clear(): void;
            public SetInt($name: string, $value: number): void;
            public SetInt($nameID: number, $value: number): void;
            public SetFloat($name: string, $value: number): void;
            public SetFloat($nameID: number, $value: number): void;
            public SetInteger($name: string, $value: number): void;
            public SetInteger($nameID: number, $value: number): void;
            public SetVector($name: string, $value: UnityEngine.Vector4): void;
            public SetVector($nameID: number, $value: UnityEngine.Vector4): void;
            public SetColor($name: string, $value: UnityEngine.Color): void;
            public SetColor($nameID: number, $value: UnityEngine.Color): void;
            public SetMatrix($name: string, $value: UnityEngine.Matrix4x4): void;
            public SetMatrix($nameID: number, $value: UnityEngine.Matrix4x4): void;
            public SetBuffer($name: string, $value: UnityEngine.ComputeBuffer): void;
            public SetBuffer($nameID: number, $value: UnityEngine.ComputeBuffer): void;
            public SetBuffer($name: string, $value: UnityEngine.GraphicsBuffer): void;
            public SetBuffer($nameID: number, $value: UnityEngine.GraphicsBuffer): void;
            public SetTexture($name: string, $value: UnityEngine.Texture): void;
            public SetTexture($nameID: number, $value: UnityEngine.Texture): void;
            public SetTexture($name: string, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement): void;
            public SetTexture($nameID: number, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement): void;
            public SetConstantBuffer($name: string, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number): void;
            public SetConstantBuffer($nameID: number, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number): void;
            public SetConstantBuffer($name: string, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number): void;
            public SetConstantBuffer($nameID: number, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number): void;
            public SetFloatArray($name: string, $values: System.Collections.Generic.List$1<number>): void;
            public SetFloatArray($nameID: number, $values: System.Collections.Generic.List$1<number>): void;
            public SetFloatArray($name: string, $values: System.Array$1<number>): void;
            public SetFloatArray($nameID: number, $values: System.Array$1<number>): void;
            public SetVectorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public SetVectorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public SetVectorArray($name: string, $values: System.Array$1<UnityEngine.Vector4>): void;
            public SetVectorArray($nameID: number, $values: System.Array$1<UnityEngine.Vector4>): void;
            public SetMatrixArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
            public SetMatrixArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
            public SetMatrixArray($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>): void;
            public SetMatrixArray($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>): void;
            public HasProperty($name: string): boolean;
            public HasProperty($nameID: number): boolean;
            public HasInt($name: string): boolean;
            public HasInt($nameID: number): boolean;
            public HasFloat($name: string): boolean;
            public HasFloat($nameID: number): boolean;
            public HasInteger($name: string): boolean;
            public HasInteger($nameID: number): boolean;
            public HasTexture($name: string): boolean;
            public HasTexture($nameID: number): boolean;
            public HasMatrix($name: string): boolean;
            public HasMatrix($nameID: number): boolean;
            public HasVector($name: string): boolean;
            public HasVector($nameID: number): boolean;
            public HasColor($name: string): boolean;
            public HasColor($nameID: number): boolean;
            public HasBuffer($name: string): boolean;
            public HasBuffer($nameID: number): boolean;
            public HasConstantBuffer($name: string): boolean;
            public HasConstantBuffer($nameID: number): boolean;
            public GetFloat($name: string): number;
            public GetFloat($nameID: number): number;
            public GetInt($name: string): number;
            public GetInt($nameID: number): number;
            public GetInteger($name: string): number;
            public GetInteger($nameID: number): number;
            public GetVector($name: string): UnityEngine.Vector4;
            public GetVector($nameID: number): UnityEngine.Vector4;
            public GetColor($name: string): UnityEngine.Color;
            public GetColor($nameID: number): UnityEngine.Color;
            public GetMatrix($name: string): UnityEngine.Matrix4x4;
            public GetMatrix($nameID: number): UnityEngine.Matrix4x4;
            public GetTexture($name: string): UnityEngine.Texture;
            public GetTexture($nameID: number): UnityEngine.Texture;
            public GetFloatArray($name: string): System.Array$1<number>;
            public GetFloatArray($nameID: number): System.Array$1<number>;
            public GetVectorArray($name: string): System.Array$1<UnityEngine.Vector4>;
            public GetVectorArray($nameID: number): System.Array$1<UnityEngine.Vector4>;
            public GetMatrixArray($name: string): System.Array$1<UnityEngine.Matrix4x4>;
            public GetMatrixArray($nameID: number): System.Array$1<UnityEngine.Matrix4x4>;
            public GetFloatArray($name: string, $values: System.Collections.Generic.List$1<number>): void;
            public GetFloatArray($nameID: number, $values: System.Collections.Generic.List$1<number>): void;
            public GetVectorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public GetVectorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public GetMatrixArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
            public GetMatrixArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
            public CopySHCoefficientArraysFrom($lightProbes: System.Collections.Generic.List$1<UnityEngine.Rendering.SphericalHarmonicsL2>): void;
            public CopySHCoefficientArraysFrom($lightProbes: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>): void;
            public CopySHCoefficientArraysFrom($lightProbes: System.Collections.Generic.List$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $sourceStart: number, $destStart: number, $count: number): void;
            public CopySHCoefficientArraysFrom($lightProbes: System.Array$1<UnityEngine.Rendering.SphericalHarmonicsL2>, $sourceStart: number, $destStart: number, $count: number): void;
            public CopyProbeOcclusionArrayFrom($occlusionProbes: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public CopyProbeOcclusionArrayFrom($occlusionProbes: System.Array$1<UnityEngine.Vector4>): void;
            public CopyProbeOcclusionArrayFrom($occlusionProbes: System.Collections.Generic.List$1<UnityEngine.Vector4>, $sourceStart: number, $destStart: number, $count: number): void;
            public CopyProbeOcclusionArrayFrom($occlusionProbes: System.Array$1<UnityEngine.Vector4>, $sourceStart: number, $destStart: number, $count: number): void;
        }

        class RenderSettings extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public static ambientSkyboxAmount: number;
            public static fog: boolean;
            public static fogStartDistance: number;
            public static fogEndDistance: number;
            public static fogMode: UnityEngine.FogMode;
            public static fogColor: UnityEngine.Color;
            public static fogDensity: number;
            public static ambientMode: UnityEngine.Rendering.AmbientMode;
            public static ambientSkyColor: UnityEngine.Color;
            public static ambientEquatorColor: UnityEngine.Color;
            public static ambientGroundColor: UnityEngine.Color;
            public static ambientIntensity: number;
            public static ambientLight: UnityEngine.Color;
            public static subtractiveShadowColor: UnityEngine.Color;
            public static skybox: UnityEngine.Material;
            public static sun: UnityEngine.Light;
            public static ambientProbe: UnityEngine.Rendering.SphericalHarmonicsL2;
            public static customReflection: UnityEngine.Cubemap;
            public static customReflectionTexture: UnityEngine.Texture;
            public static reflectionIntensity: number;
            public static reflectionBounces: number;
            public static defaultReflectionMode: UnityEngine.Rendering.DefaultReflectionMode;
            public static defaultReflectionResolution: number;
            public static haloStrength: number;
            public static flareStrength: number;
            public static flareFadeSpeed: number;
        }

        class Material extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public shader: UnityEngine.Shader;
            public color: UnityEngine.Color;
            public mainTexture: UnityEngine.Texture;
            public mainTextureOffset: UnityEngine.Vector2;
            public mainTextureScale: UnityEngine.Vector2;
            public renderQueue: number;
            public get rawRenderQueue(): number;
            public enabledKeywords: System.Array$1<UnityEngine.Rendering.LocalKeyword>;
            public globalIlluminationFlags: UnityEngine.MaterialGlobalIlluminationFlags;
            public doubleSidedGI: boolean;
            public enableInstancing: boolean;
            public get passCount(): number;
            public shaderKeywords: System.Array$1<string>;
            public parent: UnityEngine.Material;
            public get isVariant(): boolean;
            constructor($shader: UnityEngine.Shader);
            constructor($source: UnityEngine.Material);
            public HasProperty($nameID: number): boolean;
            public HasProperty($name: string): boolean;
            public HasFloat($name: string): boolean;
            public HasFloat($nameID: number): boolean;
            public HasInt($name: string): boolean;
            public HasInt($nameID: number): boolean;
            public HasInteger($name: string): boolean;
            public HasInteger($nameID: number): boolean;
            public HasTexture($name: string): boolean;
            public HasTexture($nameID: number): boolean;
            public HasMatrix($name: string): boolean;
            public HasMatrix($nameID: number): boolean;
            public HasVector($name: string): boolean;
            public HasVector($nameID: number): boolean;
            public HasColor($name: string): boolean;
            public HasColor($nameID: number): boolean;
            public HasBuffer($name: string): boolean;
            public HasBuffer($nameID: number): boolean;
            public HasConstantBuffer($name: string): boolean;
            public HasConstantBuffer($nameID: number): boolean;
            public EnableKeyword($keyword: string): void;
            public DisableKeyword($keyword: string): void;
            public IsKeywordEnabled($keyword: string): boolean;
            public EnableKeyword($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): void;
            public DisableKeyword($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): void;
            public SetKeyword($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>, $value: boolean): void;
            public IsKeywordEnabled($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): boolean;
            public SetShaderPassEnabled($passName: string, $enabled: boolean): void;
            public GetShaderPassEnabled($passName: string): boolean;
            public GetPassName($pass: number): string;
            public FindPass($passName: string): number;
            public SetOverrideTag($tag: string, $val: string): void;
            public GetTag($tag: string, $searchFallbacks: boolean, $defaultValue: string): string;
            public GetTag($tag: string, $searchFallbacks: boolean): string;
            public Lerp($start: UnityEngine.Material, $end: UnityEngine.Material, $t: number): void;
            public SetPass($pass: number): boolean;
            public CopyPropertiesFromMaterial($mat: UnityEngine.Material): void;
            public CopyMatchingPropertiesFromMaterial($mat: UnityEngine.Material): void;
            public ComputeCRC(): number;
            public GetTexturePropertyNames(): System.Array$1<string>;
            public GetTexturePropertyNameIDs(): System.Array$1<number>;
            public GetTexturePropertyNames($outNames: System.Collections.Generic.List$1<string>): void;
            public GetTexturePropertyNameIDs($outNames: System.Collections.Generic.List$1<number>): void;
            public IsChildOf($ancestor: UnityEngine.Material): boolean;
            public RevertAllPropertyOverrides(): void;
            public IsPropertyOverriden($nameID: number): boolean;
            public IsPropertyLocked($nameID: number): boolean;
            public IsPropertyLockedByAncestor($nameID: number): boolean;
            public IsPropertyOverriden($name: string): boolean;
            public IsPropertyLocked($name: string): boolean;
            public IsPropertyLockedByAncestor($name: string): boolean;
            public SetPropertyLock($nameID: number, $value: boolean): void;
            public ApplyPropertyOverride($destination: UnityEngine.Material, $nameID: number, $recordUndo?: boolean): void;
            public RevertPropertyOverride($nameID: number): void;
            public SetPropertyLock($name: string, $value: boolean): void;
            public ApplyPropertyOverride($destination: UnityEngine.Material, $name: string, $recordUndo?: boolean): void;
            public RevertPropertyOverride($name: string): void;
            public SetInt($name: string, $value: number): void;
            public SetInt($nameID: number, $value: number): void;
            public SetFloat($name: string, $value: number): void;
            public SetFloat($nameID: number, $value: number): void;
            public SetInteger($name: string, $value: number): void;
            public SetInteger($nameID: number, $value: number): void;
            public SetColor($name: string, $value: UnityEngine.Color): void;
            public SetColor($nameID: number, $value: UnityEngine.Color): void;
            public SetVector($name: string, $value: UnityEngine.Vector4): void;
            public SetVector($nameID: number, $value: UnityEngine.Vector4): void;
            public SetMatrix($name: string, $value: UnityEngine.Matrix4x4): void;
            public SetMatrix($nameID: number, $value: UnityEngine.Matrix4x4): void;
            public SetTexture($name: string, $value: UnityEngine.Texture): void;
            public SetTexture($nameID: number, $value: UnityEngine.Texture): void;
            public SetTexture($name: string, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement): void;
            public SetTexture($nameID: number, $value: UnityEngine.RenderTexture, $element: UnityEngine.Rendering.RenderTextureSubElement): void;
            public SetBuffer($name: string, $value: UnityEngine.ComputeBuffer): void;
            public SetBuffer($nameID: number, $value: UnityEngine.ComputeBuffer): void;
            public SetBuffer($name: string, $value: UnityEngine.GraphicsBuffer): void;
            public SetBuffer($nameID: number, $value: UnityEngine.GraphicsBuffer): void;
            public SetConstantBuffer($name: string, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number): void;
            public SetConstantBuffer($nameID: number, $value: UnityEngine.ComputeBuffer, $offset: number, $size: number): void;
            public SetConstantBuffer($name: string, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number): void;
            public SetConstantBuffer($nameID: number, $value: UnityEngine.GraphicsBuffer, $offset: number, $size: number): void;
            public SetFloatArray($name: string, $values: System.Collections.Generic.List$1<number>): void;
            public SetFloatArray($nameID: number, $values: System.Collections.Generic.List$1<number>): void;
            public SetFloatArray($name: string, $values: System.Array$1<number>): void;
            public SetFloatArray($nameID: number, $values: System.Array$1<number>): void;
            public SetColorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Color>): void;
            public SetColorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Color>): void;
            public SetColorArray($name: string, $values: System.Array$1<UnityEngine.Color>): void;
            public SetColorArray($nameID: number, $values: System.Array$1<UnityEngine.Color>): void;
            public SetVectorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public SetVectorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public SetVectorArray($name: string, $values: System.Array$1<UnityEngine.Vector4>): void;
            public SetVectorArray($nameID: number, $values: System.Array$1<UnityEngine.Vector4>): void;
            public SetMatrixArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
            public SetMatrixArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
            public SetMatrixArray($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>): void;
            public SetMatrixArray($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>): void;
            public GetInt($name: string): number;
            public GetInt($nameID: number): number;
            public GetFloat($name: string): number;
            public GetFloat($nameID: number): number;
            public GetInteger($name: string): number;
            public GetInteger($nameID: number): number;
            public GetColor($name: string): UnityEngine.Color;
            public GetColor($nameID: number): UnityEngine.Color;
            public GetVector($name: string): UnityEngine.Vector4;
            public GetVector($nameID: number): UnityEngine.Vector4;
            public GetMatrix($name: string): UnityEngine.Matrix4x4;
            public GetMatrix($nameID: number): UnityEngine.Matrix4x4;
            public GetTexture($name: string): UnityEngine.Texture;
            public GetTexture($nameID: number): UnityEngine.Texture;
            public GetBuffer($name: string): UnityEngine.GraphicsBufferHandle;
            public GetConstantBuffer($name: string): UnityEngine.GraphicsBufferHandle;
            public GetFloatArray($name: string): System.Array$1<number>;
            public GetFloatArray($nameID: number): System.Array$1<number>;
            public GetColorArray($name: string): System.Array$1<UnityEngine.Color>;
            public GetColorArray($nameID: number): System.Array$1<UnityEngine.Color>;
            public GetVectorArray($name: string): System.Array$1<UnityEngine.Vector4>;
            public GetVectorArray($nameID: number): System.Array$1<UnityEngine.Vector4>;
            public GetMatrixArray($name: string): System.Array$1<UnityEngine.Matrix4x4>;
            public GetMatrixArray($nameID: number): System.Array$1<UnityEngine.Matrix4x4>;
            public GetFloatArray($name: string, $values: System.Collections.Generic.List$1<number>): void;
            public GetFloatArray($nameID: number, $values: System.Collections.Generic.List$1<number>): void;
            public GetColorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Color>): void;
            public GetColorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Color>): void;
            public GetVectorArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public GetVectorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
            public GetMatrixArray($name: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
            public GetMatrixArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
            public SetTextureOffset($name: string, $value: UnityEngine.Vector2): void;
            public SetTextureOffset($nameID: number, $value: UnityEngine.Vector2): void;
            public SetTextureScale($name: string, $value: UnityEngine.Vector2): void;
            public SetTextureScale($nameID: number, $value: UnityEngine.Vector2): void;
            public GetTextureOffset($name: string): UnityEngine.Vector2;
            public GetTextureOffset($nameID: number): UnityEngine.Vector2;
            public GetTextureScale($name: string): UnityEngine.Vector2;
            public GetTextureScale($nameID: number): UnityEngine.Vector2;
            public GetPropertyNames($type: UnityEngine.MaterialPropertyType): System.Array$1<string>;
        }

        class GraphicsBufferHandle implements System.IEquatable$1<UnityEngine.GraphicsBufferHandle> {
            protected [__keep_incompatibility]: never;
            public readonly value: number;
            public GetHashCode(): number;
            public Equals($obj: any): boolean;
            public Equals($other: UnityEngine.GraphicsBufferHandle): boolean;
            public CompareTo($other: UnityEngine.GraphicsBufferHandle): number;
        }

        class GraphicsBuffer implements System.IDisposable {
            protected [__keep_incompatibility]: never;
            public get count(): number;
            public get stride(): number;
            public get target(): UnityEngine.GraphicsBuffer.Target;
            public get usageFlags(): UnityEngine.GraphicsBuffer.UsageFlags;
            public get bufferHandle(): UnityEngine.GraphicsBufferHandle;
            public set name(value: string);
            constructor($target: UnityEngine.GraphicsBuffer.Target, $count: number, $stride: number);
            constructor($target: UnityEngine.GraphicsBuffer.Target, $usageFlags: UnityEngine.GraphicsBuffer.UsageFlags, $count: number, $stride: number);
            public Dispose(): void;
            public Release(): void;
            public IsValid(): boolean;
            public SetData($data: System.Array): void;
            public SetData<T>($data: System.Collections.Generic.List$1<T>): void;
            public SetData<T>($data: Unity.Collections.NativeArray$1<T>): void;
            public SetData($data: System.Array, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number): void;
            public SetData<T>($data: System.Collections.Generic.List$1<T>, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number): void;
            public SetData<T>($data: Unity.Collections.NativeArray$1<T>, $nativeBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number): void;
            public GetData($data: System.Array): void;
            public GetData($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number): void;
            public GetNativeBufferPtr(): number;
            public LockBufferForWrite<T>($bufferStartIndex: number, $count: number): Unity.Collections.NativeArray$1<T>;
            public UnlockBufferAfterWrite<T>($countWritten: number): void;
            public SetCounterValue($counterValue: number): void;
            public static CopyCount($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number): void;
            public static CopyCount($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number): void;
            public static CopyCount($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: number): void;
            public static CopyCount($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: number): void;
        }
        namespace GraphicsBuffer {
            enum Target {
                Vertex = 1,
                Index = 2,
                CopySource = 4,
                CopyDestination = 8,
                Structured = 16,
                Raw = 32,
                Append = 64,
                Counter = 128,
                IndirectArguments = 256,
                Constant = 512
            }

            enum UsageFlags {
                None = 0,
                LockBufferForWrite = 1
            }

            class IndirectDrawArgs {
                protected [__keep_incompatibility]: never;
                public static readonly size: number;
                public vertexCountPerInstance: number;
                public instanceCount: number;
                public startVertex: number;
                public startInstance: number;
            }

            class IndirectDrawIndexedArgs {
                protected [__keep_incompatibility]: never;
                public static readonly size: number;
                public indexCountPerInstance: number;
                public instanceCount: number;
                public startIndex: number;
                public baseVertexIndex: number;
                public startInstance: number;
            }

        }

        class OcclusionPortal extends UnityEngine.Component {
            protected [__keep_incompatibility]: never;
            public open: boolean;
            constructor();
        }

        class OcclusionArea extends UnityEngine.Component {
            protected [__keep_incompatibility]: never;
            public center: UnityEngine.Vector3;
            public size: UnityEngine.Vector3;
            constructor();
        }

        class Flare extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class LensFlare extends UnityEngine.Behaviour {
            protected [__keep_incompatibility]: never;
            public brightness: number;
            public fadeSpeed: number;
            public color: UnityEngine.Color;
            public flare: UnityEngine.Flare;
            constructor();
        }

        class LightBakingOutput {
            protected [__keep_incompatibility]: never;
            public probeOcclusionLightIndex: number;
            public occlusionMaskChannel: number;
            public lightmapBakeType: UnityEngine.LightmapBakeType;
            public mixedLightingMode: UnityEngine.MixedLightingMode;
            public isBaked: boolean;
        }

        enum LightShadowCasterMode {
            Default = 0,
            NonLightmappedOnly = 1,
            Everything = 2
        }

        class Light extends UnityEngine.Behaviour {
            protected [__keep_incompatibility]: never;
            public type: UnityEngine.LightType;
            public shape: UnityEngine.LightShape;
            public spotAngle: number;
            public innerSpotAngle: number;
            public color: UnityEngine.Color;
            public colorTemperature: number;
            public useColorTemperature: boolean;
            public intensity: number;
            public bounceIntensity: number;
            public lightUnit: UnityEngine.Rendering.LightUnit;
            public luxAtDistance: number;
            public enableSpotReflector: boolean;
            public useBoundingSphereOverride: boolean;
            public boundingSphereOverride: UnityEngine.Vector4;
            public useViewFrustumForShadowCasterCull: boolean;
            public forceVisible: boolean;
            public shadowCustomResolution: number;
            public shadowBias: number;
            public shadowNormalBias: number;
            public shadowNearPlane: number;
            public useShadowMatrixOverride: boolean;
            public shadowMatrixOverride: UnityEngine.Matrix4x4;
            public range: number;
            public get dilatedRange(): number;
            public flare: UnityEngine.Flare;
            public bakingOutput: UnityEngine.LightBakingOutput;
            public cullingMask: number;
            public renderingLayerMask: number;
            public lightShadowCasterMode: UnityEngine.LightShadowCasterMode;
            public shadowRadius: number;
            public shadowAngle: number;
            public shadows: UnityEngine.LightShadows;
            public shadowStrength: number;
            public shadowResolution: UnityEngine.Rendering.LightShadowResolution;
            public layerShadowCullDistances: System.Array$1<number>;
            public cookieSize: number;
            public cookieSize2D: UnityEngine.Vector2;
            public cookie: UnityEngine.Texture;
            public renderMode: UnityEngine.LightRenderMode;
            public areaSize: UnityEngine.Vector2;
            public lightmapBakeType: UnityEngine.LightmapBakeType;
            public get commandBufferCount(): number;
            public static pixelLightCount: number;
            public get isBaked(): boolean;
            public alreadyLightmapped: boolean;
            constructor();
            public Reset(): void;
            public SetLightDirty(): void;
            public AddCommandBuffer($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer): void;
            public AddCommandBuffer($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $shadowPassMask: UnityEngine.Rendering.ShadowMapPass): void;
            public AddCommandBufferAsync($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $queueType: UnityEngine.Rendering.ComputeQueueType): void;
            public AddCommandBufferAsync($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer, $shadowPassMask: UnityEngine.Rendering.ShadowMapPass, $queueType: UnityEngine.Rendering.ComputeQueueType): void;
            public RemoveCommandBuffer($evt: UnityEngine.Rendering.LightEvent, $buffer: UnityEngine.Rendering.CommandBuffer): void;
            public RemoveCommandBuffers($evt: UnityEngine.Rendering.LightEvent): void;
            public RemoveAllCommandBuffers(): void;
            public GetCommandBuffers($evt: UnityEngine.Rendering.LightEvent): System.Array$1<UnityEngine.Rendering.CommandBuffer>;
            public static GetLights($type: UnityEngine.LightType, $layer: number): System.Array$1<UnityEngine.Light>;
        }

        class Skybox extends UnityEngine.Behaviour {
            protected [__keep_incompatibility]: never;
            public material: UnityEngine.Material;
            constructor();
        }

        class MeshFilter extends UnityEngine.Component {
            protected [__keep_incompatibility]: never;
            public sharedMesh: UnityEngine.Mesh;
            public mesh: UnityEngine.Mesh;
            constructor();
        }

        enum RenderingPath {
            VertexLit = 0,
            Forward = 1,
            DeferredLighting = 2,
            DeferredShading = 3,
            UsePlayerSettings = -1
        }

        enum TransparencySortMode {
            Default = 0,
            Perspective = 1,
            Orthographic = 2,
            CustomAxis = 3
        }

        enum StereoTargetEyeMask {
            None = 0,
            Left = 1,
            Right = 2,
            Both = 3
        }

        enum CameraType {
            Game = 1,
            SceneView = 2,
            Preview = 4,
            VR = 8,
            Reflection = 16
        }

        enum ComputeBufferType {
            Default = 0,
            Raw = 1,
            Append = 2,
            Counter = 4,
            Constant = 8,
            Structured = 16,
            DrawIndirect = 256,
            IndirectArguments = 256,
            GPUMemory = 512
        }

        enum LightType {
            Spot = 0,
            Directional = 1,
            Point = 2,
            Area = 3,
            Rectangle = 3,
            Disc = 4,
            Pyramid = 5,
            Box = 6,
            Tube = 7
        }

        enum LightShape {
            Cone = 0,
            Pyramid = 1,
            Box = 2
        }

        enum LightRenderMode {
            Auto = 0,
            ForcePixel = 1,
            ForceVertex = 2
        }

        enum LightShadows {
            None = 0,
            Hard = 1,
            Soft = 2
        }

        enum FogMode {
            Linear = 1,
            Exponential = 2,
            ExponentialSquared = 3
        }

        enum LightmapBakeType {
            Mixed = 1,
            Baked = 2,
            Realtime = 4
        }

        enum MixedLightingMode {
            IndirectOnly = 0,
            Subtractive = 1,
            Shadowmask = 2
        }

        enum ReceiveGI {
            Lightmaps = 1,
            LightProbes = 2
        }

        enum LightmapCompression {
            None = 0,
            LowQuality = 1,
            NormalQuality = 2,
            HighQuality = 3
        }

        enum QualityLevel {
            Fastest = 0,
            Fast = 1,
            Simple = 2,
            Good = 3,
            Beautiful = 4,
            Fantastic = 5
        }

        enum ShadowProjection {
            CloseFit = 0,
            StableFit = 1
        }

        enum ShadowQuality {
            Disable = 0,
            HardOnly = 1,
            All = 2
        }

        enum ShadowResolution {
            Low = 0,
            Medium = 1,
            High = 2,
            VeryHigh = 3
        }

        enum ShadowmaskMode {
            Shadowmask = 0,
            DistanceShadowmask = 1
        }

        enum ShadowObjectsFilter {
            AllObjects = 0,
            DynamicOnly = 1,
            StaticOnly = 2
        }

        enum CameraClearFlags {
            Skybox = 1,
            Color = 2,
            SolidColor = 2,
            Depth = 3,
            Nothing = 4
        }

        enum DepthTextureMode {
            None = 0,
            Depth = 1,
            DepthNormals = 2,
            MotionVectors = 4
        }

        enum TexGenMode {
            None = 0,
            SphereMap = 1,
            Object = 2,
            EyeLinear = 3,
            CubeReflect = 4,
            CubeNormal = 5
        }

        enum AnisotropicFiltering {
            Disable = 0,
            Enable = 1,
            ForceEnable = 2
        }

        enum BlendWeights {
            OneBone = 1,
            TwoBones = 2,
            FourBones = 4
        }

        enum SkinWeights {
            None = 0,
            OneBone = 1,
            TwoBones = 2,
            FourBones = 4,
            Unlimited = 255
        }

        enum MeshTopology {
            Triangles = 0,
            Quads = 2,
            Lines = 3,
            LineStrip = 4,
            Points = 5
        }

        enum SkinQuality {
            Auto = 0,
            Bone1 = 1,
            Bone2 = 2,
            Bone4 = 4
        }

        enum ColorSpace {
            Gamma = 0,
            Linear = 1,
            Uninitialized = -1
        }

        enum ColorGamut {
            sRGB = 0,
            Rec709 = 1,
            Rec2020 = 2,
            DisplayP3 = 3,
            HDR10 = 4,
            DolbyHDR = 5,
            P3D65G22 = 6
        }

        enum ColorPrimaries {
            Rec709 = 0,
            Rec2020 = 1,
            P3 = 2,
            Unknown = -1
        }

        enum WhitePoint {
            D65 = 0,
            Unknown = -1
        }

        enum TransferFunction {
            sRGB = 0,
            BT1886 = 1,
            PQ = 2,
            Linear = 3,
            Gamma22 = 4,
            Unknown = -1
        }

        enum ScreenOrientation {
            Unknown = 0,
            Portrait = 1,
            PortraitUpsideDown = 2,
            LandscapeLeft = 3,
            Landscape = 3,
            LandscapeRight = 4,
            AutoRotation = 5
        }

        enum FilterMode {
            Point = 0,
            Bilinear = 1,
            Trilinear = 2
        }

        enum TextureWrapMode {
            Repeat = 0,
            Clamp = 1,
            Mirror = 2,
            MirrorOnce = 3
        }

        enum NPOTSupport {
            None = 0,
            Restricted = 1,
            Full = 2
        }

        enum TextureFormat {
            Alpha8 = 1,
            ARGB4444 = 2,
            RGB24 = 3,
            RGBA32 = 4,
            ARGB32 = 5,
            RGB565 = 7,
            R16 = 9,
            DXT1 = 10,
            DXT5 = 12,
            RGBA4444 = 13,
            BGRA32 = 14,
            RHalf = 15,
            RGHalf = 16,
            RGBAHalf = 17,
            RFloat = 18,
            RGFloat = 19,
            RGBAFloat = 20,
            YUY2 = 21,
            RGB9e5Float = 22,
            BC6H = 24,
            BC7 = 25,
            BC4 = 26,
            BC5 = 27,
            DXT1Crunched = 28,
            DXT5Crunched = 29,
            PVRTC_RGB2 = 30,
            PVRTC_RGBA2 = 31,
            PVRTC_RGB4 = 32,
            PVRTC_RGBA4 = 33,
            ETC_RGB4 = 34,
            EAC_R = 41,
            EAC_R_SIGNED = 42,
            EAC_RG = 43,
            EAC_RG_SIGNED = 44,
            ETC2_RGB = 45,
            ETC2_RGBA1 = 46,
            ETC2_RGBA8 = 47,
            ASTC_4x4 = 48,
            ASTC_5x5 = 49,
            ASTC_6x6 = 50,
            ASTC_8x8 = 51,
            ASTC_10x10 = 52,
            ASTC_12x12 = 53,
            RG16 = 62,
            R8 = 63,
            ETC_RGB4Crunched = 64,
            ETC2_RGBA8Crunched = 65,
            ASTC_HDR_4x4 = 66,
            ASTC_HDR_5x5 = 67,
            ASTC_HDR_6x6 = 68,
            ASTC_HDR_8x8 = 69,
            ASTC_HDR_10x10 = 70,
            ASTC_HDR_12x12 = 71,
            RG32 = 72,
            RGB48 = 73,
            RGBA64 = 74,
            R8_SIGNED = 75,
            RG16_SIGNED = 76,
            RGB24_SIGNED = 77,
            RGBA32_SIGNED = 78,
            R16_SIGNED = 79,
            RG32_SIGNED = 80,
            RGB48_SIGNED = 81,
            RGBA64_SIGNED = 82,
            ETC_RGBA8_3DS = -61,
            ETC_RGB4_3DS = -60,
            ASTC_RGBA_12x12 = -59,
            ASTC_RGBA_10x10 = -58,
            ASTC_RGBA_8x8 = -57,
            ASTC_RGBA_6x6 = -56,
            ASTC_RGBA_5x5 = -55,
            ASTC_RGBA_4x4 = -54,
            ASTC_RGB_12x12 = -53,
            ASTC_RGB_10x10 = -52,
            ASTC_RGB_8x8 = -51,
            ASTC_RGB_6x6 = -50,
            ASTC_RGB_5x5 = -49,
            ASTC_RGB_4x4 = -48
        }

        enum CubemapFace {
            PositiveX = 0,
            NegativeX = 1,
            PositiveY = 2,
            NegativeY = 3,
            PositiveZ = 4,
            NegativeZ = 5,
            Unknown = -1
        }

        enum RenderTextureFormat {
            ARGB32 = 0,
            Depth = 1,
            ARGBHalf = 2,
            Shadowmap = 3,
            RGB565 = 4,
            ARGB4444 = 5,
            ARGB1555 = 6,
            Default = 7,
            ARGB2101010 = 8,
            DefaultHDR = 9,
            ARGB64 = 10,
            ARGBFloat = 11,
            RGFloat = 12,
            RGHalf = 13,
            RFloat = 14,
            RHalf = 15,
            R8 = 16,
            ARGBInt = 17,
            RGInt = 18,
            RInt = 19,
            BGRA32 = 20,
            RGB111110Float = 22,
            RG32 = 23,
            RGBAUShort = 24,
            RG16 = 25,
            BGRA10101010_XR = 26,
            BGR101010_XR = 27,
            R16 = 28
        }

        enum VRTextureUsage {
            None = 0,
            OneEye = 1,
            TwoEyes = 2,
            DeviceSpecific = 3
        }

        enum RenderTextureCreationFlags {
            MipMap = 1,
            AutoGenerateMips = 2,
            SRGB = 4,
            EyeTexture = 8,
            EnableRandomWrite = 16,
            CreatedFromScript = 32,
            AllowVerticalFlip = 128,
            NoResolvedColorSurface = 256,
            DynamicallyScalable = 1024,
            BindMS = 2048,
            ShadingRate = 16384,
            DynamicallyScalableExplicit = 131072
        }

        enum RenderTextureReadWrite {
            Default = 0,
            Linear = 1,
            sRGB = 2
        }

        enum RenderTextureMemoryless {
            None = 0,
            Color = 1,
            Depth = 2,
            MSAA = 4
        }

        enum HDRDisplaySupportFlags {
            None = 0,
            Supported = 1,
            RuntimeSwitchable = 2,
            AutomaticTonemapping = 4
        }

        enum HDRDisplayBitDepth {
            BitDepth10 = 0,
            BitDepth16 = 1
        }

        enum LightmapsMode {
            NonDirectional = 0,
            Single = 0,
            CombinedDirectional = 1,
            Dual = 1,
            SeparateDirectional = 2,
            Directional = 2
        }

        enum MaterialGlobalIlluminationFlags {
            None = 0,
            RealtimeEmissive = 1,
            BakedEmissive = 2,
            AnyEmissive = 3,
            EmissiveIsBlack = 4
        }

        class LightProbeProxyVolume extends UnityEngine.Behaviour {
            protected [__keep_incompatibility]: never;
            public static get isFeatureSupported(): boolean;
            public get boundsGlobal(): UnityEngine.Bounds;
            public sizeCustom: UnityEngine.Vector3;
            public originCustom: UnityEngine.Vector3;
            public probeDensity: number;
            public gridResolutionX: number;
            public gridResolutionY: number;
            public gridResolutionZ: number;
            public boundingBoxMode: UnityEngine.LightProbeProxyVolume.BoundingBoxMode;
            public resolutionMode: UnityEngine.LightProbeProxyVolume.ResolutionMode;
            public probePositionMode: UnityEngine.LightProbeProxyVolume.ProbePositionMode;
            public refreshMode: UnityEngine.LightProbeProxyVolume.RefreshMode;
            public qualityMode: UnityEngine.LightProbeProxyVolume.QualityMode;
            public dataFormat: UnityEngine.LightProbeProxyVolume.DataFormat;
            constructor();
            public Update(): void;
        }
        namespace LightProbeProxyVolume {
            enum ResolutionMode {
                Automatic = 0,
                Custom = 1
            }

            enum BoundingBoxMode {
                AutomaticLocal = 0,
                AutomaticWorld = 1,
                Custom = 2
            }

            enum ProbePositionMode {
                CellCorner = 0,
                CellCenter = 1
            }

            enum RefreshMode {
                Automatic = 0,
                EveryFrame = 1,
                ViaScripting = 2
            }

            enum QualityMode {
                Low = 0,
                Normal = 1
            }

            enum DataFormat {
                HalfFloat = 0,
                Float = 1
            }

        }

        enum CustomRenderTextureInitializationSource {
            TextureAndColor = 0,
            Material = 1
        }

        enum CustomRenderTextureUpdateMode {
            OnLoad = 0,
            Realtime = 1,
            OnDemand = 2
        }

        enum CustomRenderTextureUpdateZoneSpace {
            Normalized = 0,
            Pixel = 1
        }

        enum MotionVectorGenerationMode {
            Camera = 0,
            Object = 1,
            ForceNoMotion = 2
        }

        enum LineTextureMode {
            Stretch = 0,
            Tile = 1,
            DistributePerSegment = 2,
            RepeatPerSegment = 3,
            Static = 4
        }

        enum LineAlignment {
            View = 0,
            Local = 1,
            TransformZ = 1
        }

        enum TextureMipmapLimitBiasMode {
            OffsetGlobalLimit = 0,
            OverrideGlobalLimit = 1
        }

        enum GraphicsJobsFilterMode {
            Off = 0,
            Native = 1,
            Legacy = 2,
            Split = 3
        }

        enum TerrainQualityOverrides {
            None = 0,
            PixelError = 1,
            BasemapDistance = 2,
            DetailDensity = 4,
            DetailDistance = 8,
            TreeDistance = 16,
            BillboardStart = 32,
            FadeLength = 64,
            MaxTrees = 128
        }

        class TextureMipmapLimitSettings {
            protected [__keep_incompatibility]: never;
            public limitBiasMode: UnityEngine.TextureMipmapLimitBiasMode;
            public limitBias: number;
        }

        class TextureMipmapLimitGroups {
            protected [__keep_incompatibility]: never;
            public static CreateGroup($groupName: string): void;
            public static RemoveGroup($groupName: string): void;
            public static GetGroups(): System.Array$1<string>;
            public static HasGroup($groupName: string): boolean;
        }

        class SkinnedMeshRenderer extends UnityEngine.Renderer {
            protected [__keep_incompatibility]: never;
            public quality: UnityEngine.SkinQuality;
            public updateWhenOffscreen: boolean;
            public forceMatrixRecalculationPerRender: boolean;
            public rootBone: UnityEngine.Transform;
            public bones: System.Array$1<UnityEngine.Transform>;
            public sharedMesh: UnityEngine.Mesh;
            public skinnedMotionVectors: boolean;
            public vertexBufferTarget: UnityEngine.GraphicsBuffer.Target;
            constructor();
            public GetBlendShapeWeight($index: number): number;
            public SetBlendShapeWeight($index: number, $value: number): void;
            public BakeMesh($mesh: UnityEngine.Mesh): void;
            public BakeMesh($mesh: UnityEngine.Mesh, $useScale: boolean): void;
            public GetVertexBuffer(): UnityEngine.GraphicsBuffer;
            public GetPreviousVertexBuffer(): UnityEngine.GraphicsBuffer;
            public SetShaderUserValue($v: number): void;
            public GetShaderUserValue(): number;
        }

        class MeshRenderer extends UnityEngine.Renderer {
            protected [__keep_incompatibility]: never;
            public additionalVertexStreams: UnityEngine.Mesh;
            public enlightenVertexStream: UnityEngine.Mesh;
            public get subMeshStartIndex(): number;
            public scaleInLightmap: number;
            public receiveGI: UnityEngine.ReceiveGI;
            public stitchLightmapSeams: boolean;
            public globalIlluminationMeshLod: number;
            constructor();
            public SetShaderUserValue($v: number): void;
            public GetShaderUserValue(): number;
        }

        enum LightmappingMode {
            Mixed = 1,
            Baked = 2,
            Realtime = 4
        }

        class LightProbeGroup extends UnityEngine.Behaviour {
            protected [__keep_incompatibility]: never;
            public probePositions: System.Array$1<UnityEngine.Vector3>;
            public dering: boolean;
            constructor();
        }

        class LineUtility {
            protected [__keep_incompatibility]: never;
            constructor();
            public static Simplify($points: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tolerance: number, $pointsToKeep: System.Collections.Generic.List$1<number>): void;
            public static Simplify($points: System.Collections.Generic.List$1<UnityEngine.Vector3>, $tolerance: number, $simplifiedPoints: System.Collections.Generic.List$1<UnityEngine.Vector3>): void;
            public static Simplify($points: System.Collections.Generic.List$1<UnityEngine.Vector2>, $tolerance: number, $pointsToKeep: System.Collections.Generic.List$1<number>): void;
            public static Simplify($points: System.Collections.Generic.List$1<UnityEngine.Vector2>, $tolerance: number, $simplifiedPoints: System.Collections.Generic.List$1<UnityEngine.Vector2>): void;
        }

        enum LODFadeMode {
            None = 0,
            CrossFade = 1,
            SpeedTree = 2
        }

        class LOD {
            protected [__keep_incompatibility]: never;
            public screenRelativeTransitionHeight: number;
            public fadeTransitionWidth: number;
            public renderers: System.Array$1<UnityEngine.Renderer>;
            constructor($screenRelativeTransitionHeight: number, $renderers: System.Array$1<UnityEngine.Renderer>);
        }

        class LODGroup extends UnityEngine.Component {
            protected [__keep_incompatibility]: never;
            public localReferencePoint: UnityEngine.Vector3;
            public size: number;
            public get lodCount(): number;
            public lastLODBillboard: boolean;
            public fadeMode: UnityEngine.LODFadeMode;
            public animateCrossFading: boolean;
            public enabled: boolean;
            public static crossFadeAnimationDuration: number;
            constructor();
            public RecalculateBounds(): void;
            public GetLODs(): System.Array$1<UnityEngine.LOD>;
            public SetLODS($lods: System.Array$1<UnityEngine.LOD>): void;
            public SetLODs($lods: System.Array$1<UnityEngine.LOD>): void;
            public ForceLOD($index: number): void;
        }

        class BlendShapeBufferRange {
            protected [__keep_incompatibility]: never;
            public get startIndex(): number;
            public get endIndex(): number;
        }

        class BoneWeight implements System.IEquatable$1<UnityEngine.BoneWeight> {
            protected [__keep_incompatibility]: never;
            public weight0: number;
            public weight1: number;
            public weight2: number;
            public weight3: number;
            public boneIndex0: number;
            public boneIndex1: number;
            public boneIndex2: number;
            public boneIndex3: number;
            public GetHashCode(): number;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.BoneWeight): boolean;
        }

        class BoneWeight1 implements System.IEquatable$1<UnityEngine.BoneWeight1> {
            protected [__keep_incompatibility]: never;
            public weight: number;
            public boneIndex: number;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.BoneWeight1): boolean;
            public GetHashCode(): number;
        }

        class CombineInstance {
            protected [__keep_incompatibility]: never;
            public mesh: UnityEngine.Mesh;
            public subMeshIndex: number;
            public transform: UnityEngine.Matrix4x4;
            public lightmapScaleOffset: UnityEngine.Vector4;
            public realtimeLightmapScaleOffset: UnityEngine.Vector4;
        }

        class MeshLodRange {
            protected [__keep_incompatibility]: never;
            public indexStart: number;
            public indexCount: number;
            constructor($indexStart: number, $indexCount: number);
            public ToString(): string;
        }

        class Texture extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public static readonly GenerateAllMips: number;
            public static masterTextureLimit: number;
            public static globalMipmapLimit: number;
            public get mipmapCount(): number;
            public static anisotropicFiltering: UnityEngine.AnisotropicFiltering;
            public get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public width: number;
            public height: number;
            public dimension: UnityEngine.Rendering.TextureDimension;
            public get isReadable(): boolean;
            public wrapMode: UnityEngine.TextureWrapMode;
            public wrapModeU: UnityEngine.TextureWrapMode;
            public wrapModeV: UnityEngine.TextureWrapMode;
            public wrapModeW: UnityEngine.TextureWrapMode;
            public filterMode: UnityEngine.FilterMode;
            public anisoLevel: number;
            public mipMapBias: number;
            public get texelSize(): UnityEngine.Vector2;
            public get updateCount(): number;
            public get isDataSRGB(): boolean;
            public imageContentsHash: UnityEngine.Hash128;
            public static get totalTextureMemory(): bigint;
            public static get desiredTextureMemory(): bigint;
            public static get targetTextureMemory(): bigint;
            public static get currentTextureMemory(): bigint;
            public static get nonStreamingTextureMemory(): bigint;
            public static get streamingMipmapUploadCount(): bigint;
            public static get streamingRendererCount(): bigint;
            public static get streamingTextureCount(): bigint;
            public static get nonStreamingTextureCount(): bigint;
            public static get streamingTexturePendingLoadCount(): bigint;
            public static get streamingTextureLoadingCount(): bigint;
            public static streamingTextureForceLoadAll: boolean;
            public static streamingTextureDiscardUnusedMips: boolean;
            public static allowThreadedTextureCreation: boolean;
            public get graphicsTexture(): UnityEngine.Rendering.GraphicsTexture;
            public static SetGlobalAnisotropicFilteringLimits($forcedMin: number, $globalMax: number): void;
            public GetNativeTexturePtr(): number;
            public GetNativeTextureID(): number;
            public IncrementUpdateCount(): void;
            public static SetStreamingTextureMaterialDebugProperties(): void;
            public static SetStreamingTextureMaterialDebugProperties($materialTextureSlot: number): void;
        }

        class Texture2D extends UnityEngine.Texture {
            protected [__keep_incompatibility]: never;
            public get format(): UnityEngine.TextureFormat;
            public get mipmapLimitGroup(): string;
            public get activeMipmapLimit(): number;
            public static get whiteTexture(): UnityEngine.Texture2D;
            public static get blackTexture(): UnityEngine.Texture2D;
            public static get redTexture(): UnityEngine.Texture2D;
            public static get grayTexture(): UnityEngine.Texture2D;
            public static get linearGrayTexture(): UnityEngine.Texture2D;
            public static get normalTexture(): UnityEngine.Texture2D;
            public get isReadable(): boolean;
            public get vtOnly(): boolean;
            public get streamingMipmaps(): boolean;
            public get streamingMipmapsPriority(): number;
            public requestedMipmapLevel: number;
            public minimumMipmapLevel: number;
            public get calculatedMipmapLevel(): number;
            public get desiredMipmapLevel(): number;
            public get loadingMipmapLevel(): number;
            public get loadedMipmapLevel(): number;
            public alphaIsTransparency: boolean;
            public ignoreMipmapLimit: boolean;
            constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $mipCount: number, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $mipCount: number, $mipmapLimitGroupName: string, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $mipCount: number, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipmapLimitDescriptor: UnityEngine.MipmapLimitDescriptor);
            constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number, $mipmapLimitGroupName: string, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipmapLimitDescriptor: UnityEngine.MipmapLimitDescriptor);
            constructor($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean);
            constructor($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean, $createUninitialized: boolean);
            constructor($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean, $createUninitialized: boolean, $mipmapLimitDescriptor: UnityEngine.MipmapLimitDescriptor);
            constructor($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean, $createUninitialized: boolean, $ignoreMipmapLimit: boolean, $mipmapLimitGroupName: string);
            constructor($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean);
            constructor($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean, $createUninitialized: boolean);
            constructor($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean);
            constructor($width: number, $height: number);
            public Compress($highQuality: boolean): void;
            public ClearRequestedMipmapLevel(): void;
            public IsRequestedMipmapLevelLoaded(): boolean;
            public ClearMinimumMipmapLevel(): void;
            public UpdateExternalTexture($nativeTex: number): void;
            public GetRawTextureData(): System.Array$1<number>;
            public GetPixels($x: number, $y: number, $blockWidth: number, $blockHeight: number, $miplevel: number): System.Array$1<UnityEngine.Color>;
            public GetPixels($x: number, $y: number, $blockWidth: number, $blockHeight: number): System.Array$1<UnityEngine.Color>;
            public GetPixels32($miplevel: number): System.Array$1<UnityEngine.Color32>;
            public GetPixels32(): System.Array$1<UnityEngine.Color32>;
            public PackTextures($textures: System.Array$1<UnityEngine.Texture2D>, $padding: number, $maximumAtlasSize: number, $makeNoLongerReadable: boolean): System.Array$1<UnityEngine.Rect>;
            public PackTextures($textures: System.Array$1<UnityEngine.Texture2D>, $padding: number, $maximumAtlasSize: number): System.Array$1<UnityEngine.Rect>;
            public PackTextures($textures: System.Array$1<UnityEngine.Texture2D>, $padding: number): System.Array$1<UnityEngine.Rect>;
            public static CreateExternalTexture($width: number, $height: number, $format: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean, $nativeTex: number): UnityEngine.Texture2D;
            public SetPixel($x: number, $y: number, $color: UnityEngine.Color): void;
            public SetPixel($x: number, $y: number, $color: UnityEngine.Color, $mipLevel: number): void;
            public SetPixels($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color>, $miplevel: number): void;
            public SetPixels($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color>): void;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $miplevel: number): void;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>): void;
            public GetPixel($x: number, $y: number): UnityEngine.Color;
            public GetPixel($x: number, $y: number, $mipLevel: number): UnityEngine.Color;
            public GetPixelBilinear($u: number, $v: number): UnityEngine.Color;
            public GetPixelBilinear($u: number, $v: number, $mipLevel: number): UnityEngine.Color;
            public LoadRawTextureData($data: number, $size: number): void;
            public LoadRawTextureData($data: System.Array$1<number>): void;
            public LoadRawTextureData<T>($data: Unity.Collections.NativeArray$1<T>): void;
            public SetPixelData<T>($data: System.Array$1<T>, $mipLevel: number, $sourceDataStartIndex?: number): void;
            public SetPixelData<T>($data: Unity.Collections.NativeArray$1<T>, $mipLevel: number, $sourceDataStartIndex?: number): void;
            public GetPixelData<T>($mipLevel: number): Unity.Collections.NativeArray$1<T>;
            public GetRawTextureData<T>(): Unity.Collections.NativeArray$1<T>;
            public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean): void;
            public Apply($updateMipmaps: boolean): void;
            public Apply(): void;
            public Reinitialize($width: number, $height: number): boolean;
            public Reinitialize($width: number, $height: number, $format: UnityEngine.TextureFormat, $hasMipMap: boolean): boolean;
            public Reinitialize($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $hasMipMap: boolean): boolean;
            public Resize($width: number, $height: number): boolean;
            public Resize($width: number, $height: number, $format: UnityEngine.TextureFormat, $hasMipMap: boolean): boolean;
            public Resize($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $hasMipMap: boolean): boolean;
            public ReadPixels($source: UnityEngine.Rect, $destX: number, $destY: number, $recalculateMipMaps: boolean): void;
            public ReadPixels($source: UnityEngine.Rect, $destX: number, $destY: number): void;
            public static GenerateAtlas($sizes: System.Array$1<UnityEngine.Vector2>, $padding: number, $atlasSize: number, $results: System.Collections.Generic.List$1<UnityEngine.Rect>): boolean;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>, $miplevel: number): void;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>): void;
            public SetPixels32($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color32>, $miplevel: number): void;
            public SetPixels32($x: number, $y: number, $blockWidth: number, $blockHeight: number, $colors: System.Array$1<UnityEngine.Color32>): void;
            public GetPixels($miplevel: number): System.Array$1<UnityEngine.Color>;
            public GetPixels(): System.Array$1<UnityEngine.Color>;
            public CopyPixels($src: UnityEngine.Texture): void;
            public CopyPixels($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $dstMip: number): void;
            public CopyPixels($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $srcX: number, $srcY: number, $srcWidth: number, $srcHeight: number, $dstMip: number, $dstX: number, $dstY: number): void;
        }
        namespace Texture2D {
            enum EXRFlags {
                None = 0,
                OutputAsFloat = 1,
                CompressZIP = 2,
                CompressRLE = 4,
                CompressPIZ = 8
            }

        }

        class Cubemap extends UnityEngine.Texture {
            protected [__keep_incompatibility]: never;
            public get format(): UnityEngine.TextureFormat;
            public get isReadable(): boolean;
            public get streamingMipmaps(): boolean;
            public get streamingMipmapsPriority(): number;
            public requestedMipmapLevel: number;
            public get desiredMipmapLevel(): number;
            public get loadingMipmapLevel(): number;
            public get loadedMipmapLevel(): number;
            constructor($width: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            constructor($width: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number);
            constructor($width: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            constructor($width: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number);
            constructor($width: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean);
            constructor($width: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $createUninitialized: boolean);
            constructor($width: number, $format: UnityEngine.TextureFormat, $mipCount: number);
            constructor($width: number, $format: UnityEngine.TextureFormat, $mipCount: number, $createUninitialized: boolean);
            public UpdateExternalTexture($nativeTexture: number): void;
            public SmoothEdges($smoothRegionWidthInPixels: number): void;
            public SmoothEdges(): void;
            public GetPixels($face: UnityEngine.CubemapFace, $miplevel: number): System.Array$1<UnityEngine.Color>;
            public GetPixels($face: UnityEngine.CubemapFace): System.Array$1<UnityEngine.Color>;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace, $miplevel: number): void;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace): void;
            public ClearRequestedMipmapLevel(): void;
            public IsRequestedMipmapLevelLoaded(): boolean;
            public static CreateExternalTexture($width: number, $format: UnityEngine.TextureFormat, $mipmap: boolean, $nativeTex: number): UnityEngine.Cubemap;
            public SetPixelData<T>($data: System.Array$1<T>, $mipLevel: number, $face: UnityEngine.CubemapFace, $sourceDataStartIndex?: number): void;
            public SetPixelData<T>($data: Unity.Collections.NativeArray$1<T>, $mipLevel: number, $face: UnityEngine.CubemapFace, $sourceDataStartIndex?: number): void;
            public GetPixelData<T>($mipLevel: number, $face: UnityEngine.CubemapFace): Unity.Collections.NativeArray$1<T>;
            public SetPixel($face: UnityEngine.CubemapFace, $x: number, $y: number, $color: UnityEngine.Color): void;
            public SetPixel($face: UnityEngine.CubemapFace, $x: number, $y: number, $color: UnityEngine.Color, $mip: number): void;
            public GetPixel($face: UnityEngine.CubemapFace, $x: number, $y: number): UnityEngine.Color;
            public GetPixel($face: UnityEngine.CubemapFace, $x: number, $y: number, $mip: number): UnityEngine.Color;
            public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean): void;
            public Apply($updateMipmaps: boolean): void;
            public Apply(): void;
            public CopyPixels($src: UnityEngine.Texture): void;
            public CopyPixels($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $dstFace: UnityEngine.CubemapFace, $dstMip: number): void;
            public CopyPixels($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $srcX: number, $srcY: number, $srcWidth: number, $srcHeight: number, $dstFace: UnityEngine.CubemapFace, $dstMip: number, $dstX: number, $dstY: number): void;
        }

        class Texture3D extends UnityEngine.Texture {
            protected [__keep_incompatibility]: never;
            public get depth(): number;
            public get format(): UnityEngine.TextureFormat;
            public get isReadable(): boolean;
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number);
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number);
            constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number);
            constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $nativeTex: number);
            constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $nativeTex: number, $createUninitialized: boolean);
            constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean);
            constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $createUninitialized: boolean);
            constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $nativeTex: number);
            public UpdateExternalTexture($nativeTex: number): void;
            public GetPixels($miplevel: number): System.Array$1<UnityEngine.Color>;
            public GetPixels(): System.Array$1<UnityEngine.Color>;
            public GetPixels32($miplevel: number): System.Array$1<UnityEngine.Color32>;
            public GetPixels32(): System.Array$1<UnityEngine.Color32>;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $miplevel: number): void;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>): void;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>, $miplevel: number): void;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>): void;
            public static CreateExternalTexture($width: number, $height: number, $depth: number, $format: UnityEngine.TextureFormat, $mipChain: boolean, $nativeTex: number): UnityEngine.Texture3D;
            public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean): void;
            public Apply($updateMipmaps: boolean): void;
            public Apply(): void;
            public SetPixel($x: number, $y: number, $z: number, $color: UnityEngine.Color): void;
            public SetPixel($x: number, $y: number, $z: number, $color: UnityEngine.Color, $mipLevel: number): void;
            public GetPixel($x: number, $y: number, $z: number): UnityEngine.Color;
            public GetPixel($x: number, $y: number, $z: number, $mipLevel: number): UnityEngine.Color;
            public GetPixelBilinear($u: number, $v: number, $w: number): UnityEngine.Color;
            public GetPixelBilinear($u: number, $v: number, $w: number, $mipLevel: number): UnityEngine.Color;
            public SetPixelData<T>($data: System.Array$1<T>, $mipLevel: number, $sourceDataStartIndex?: number): void;
            public SetPixelData<T>($data: Unity.Collections.NativeArray$1<T>, $mipLevel: number, $sourceDataStartIndex?: number): void;
            public GetPixelData<T>($mipLevel: number): Unity.Collections.NativeArray$1<T>;
            public CopyPixels($src: UnityEngine.Texture): void;
            public CopyPixels($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $dstElement: number, $dstMip: number): void;
            public CopyPixels($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $srcX: number, $srcY: number, $srcWidth: number, $srcHeight: number, $dstElement: number, $dstMip: number, $dstX: number, $dstY: number): void;
        }

        class Texture2DArray extends UnityEngine.Texture {
            protected [__keep_incompatibility]: never;
            public static get allSlices(): number;
            public get depth(): number;
            public get format(): UnityEngine.TextureFormat;
            public get mipmapLimitGroup(): string;
            public get activeMipmapLimit(): number;
            public get isReadable(): boolean;
            public ignoreMipmapLimit: boolean;
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number);
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number, $mipmapLimitDescriptor: UnityEngine.MipmapLimitDescriptor);
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number);
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number, $mipmapLimitDescriptor: UnityEngine.MipmapLimitDescriptor);
            constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean, $createUninitialized: boolean, $mipmapLimitDescriptor: UnityEngine.MipmapLimitDescriptor);
            constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean, $createUninitialized: boolean);
            constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean);
            constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean, $createUninitialized: boolean);
            constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean);
            constructor($width: number, $height: number, $depth: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean);
            public GetPixels($arrayElement: number, $miplevel: number): System.Array$1<UnityEngine.Color>;
            public GetPixels($arrayElement: number): System.Array$1<UnityEngine.Color>;
            public GetPixels32($arrayElement: number, $miplevel: number): System.Array$1<UnityEngine.Color32>;
            public GetPixels32($arrayElement: number): System.Array$1<UnityEngine.Color32>;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $arrayElement: number, $miplevel: number): void;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $arrayElement: number): void;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>, $arrayElement: number, $miplevel: number): void;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>, $arrayElement: number): void;
            public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean): void;
            public Apply($updateMipmaps: boolean): void;
            public Apply(): void;
            public SetPixelData<T>($data: System.Array$1<T>, $mipLevel: number, $element: number, $sourceDataStartIndex?: number): void;
            public SetPixelData<T>($data: Unity.Collections.NativeArray$1<T>, $mipLevel: number, $element: number, $sourceDataStartIndex?: number): void;
            public GetPixelData<T>($mipLevel: number, $element: number): Unity.Collections.NativeArray$1<T>;
            public CopyPixels($src: UnityEngine.Texture): void;
            public CopyPixels($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $dstElement: number, $dstMip: number): void;
            public CopyPixels($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $srcX: number, $srcY: number, $srcWidth: number, $srcHeight: number, $dstElement: number, $dstMip: number, $dstX: number, $dstY: number): void;
        }

        class CubemapArray extends UnityEngine.Texture {
            protected [__keep_incompatibility]: never;
            public get cubemapCount(): number;
            public get format(): UnityEngine.TextureFormat;
            public get isReadable(): boolean;
            constructor($width: number, $cubemapCount: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            constructor($width: number, $cubemapCount: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number);
            constructor($width: number, $cubemapCount: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags);
            constructor($width: number, $cubemapCount: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $flags: UnityEngine.Experimental.Rendering.TextureCreationFlags, $mipCount: number);
            constructor($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean, $createUninitialized: boolean);
            constructor($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean);
            constructor($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean, $createUninitialized: boolean);
            constructor($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean, $linear: boolean);
            constructor($width: number, $cubemapCount: number, $textureFormat: UnityEngine.TextureFormat, $mipChain: boolean);
            public GetPixels($face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number): System.Array$1<UnityEngine.Color>;
            public GetPixels($face: UnityEngine.CubemapFace, $arrayElement: number): System.Array$1<UnityEngine.Color>;
            public GetPixels32($face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number): System.Array$1<UnityEngine.Color32>;
            public GetPixels32($face: UnityEngine.CubemapFace, $arrayElement: number): System.Array$1<UnityEngine.Color32>;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number): void;
            public SetPixels($colors: System.Array$1<UnityEngine.Color>, $face: UnityEngine.CubemapFace, $arrayElement: number): void;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>, $face: UnityEngine.CubemapFace, $arrayElement: number, $miplevel: number): void;
            public SetPixels32($colors: System.Array$1<UnityEngine.Color32>, $face: UnityEngine.CubemapFace, $arrayElement: number): void;
            public Apply($updateMipmaps: boolean, $makeNoLongerReadable: boolean): void;
            public Apply($updateMipmaps: boolean): void;
            public Apply(): void;
            public SetPixelData<T>($data: System.Array$1<T>, $mipLevel: number, $face: UnityEngine.CubemapFace, $element: number, $sourceDataStartIndex?: number): void;
            public SetPixelData<T>($data: Unity.Collections.NativeArray$1<T>, $mipLevel: number, $face: UnityEngine.CubemapFace, $element: number, $sourceDataStartIndex?: number): void;
            public GetPixelData<T>($mipLevel: number, $face: UnityEngine.CubemapFace, $element: number): Unity.Collections.NativeArray$1<T>;
            public CopyPixels($src: UnityEngine.Texture): void;
            public CopyPixels($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $dstElement: number, $dstMip: number): void;
            public CopyPixels($src: UnityEngine.Texture, $srcElement: number, $srcMip: number, $srcX: number, $srcY: number, $srcWidth: number, $srcHeight: number, $dstElement: number, $dstMip: number, $dstX: number, $dstY: number): void;
        }

        class SparseTexture extends UnityEngine.Texture {
            protected [__keep_incompatibility]: never;
            public get tileWidth(): number;
            public get tileHeight(): number;
            public get isCreated(): boolean;
            constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat, $mipCount: number);
            constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number);
            constructor($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number);
            constructor($width: number, $height: number, $textureFormat: UnityEngine.TextureFormat, $mipCount: number, $linear: boolean);
            public UpdateTile($tileX: number, $tileY: number, $miplevel: number, $data: System.Array$1<UnityEngine.Color32>): void;
            public UpdateTileRaw($tileX: number, $tileY: number, $miplevel: number, $data: System.Array$1<number>): void;
            public UnloadTile($tileX: number, $tileY: number, $miplevel: number): void;
        }

        class RenderTexture extends UnityEngine.Texture {
            protected [__keep_incompatibility]: never;
            public width: number;
            public height: number;
            public dimension: UnityEngine.Rendering.TextureDimension;
            public graphicsFormat: UnityEngine.Experimental.Rendering.GraphicsFormat;
            public useMipMap: boolean;
            public get sRGB(): boolean;
            public vrUsage: UnityEngine.VRTextureUsage;
            public memorylessMode: UnityEngine.RenderTextureMemoryless;
            public format: UnityEngine.RenderTextureFormat;
            public stencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat;
            public depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat;
            public autoGenerateMips: boolean;
            public volumeDepth: number;
            public antiAliasing: number;
            public bindTextureMS: boolean;
            public enableRandomWrite: boolean;
            public useDynamicScale: boolean;
            public useDynamicScaleExplicit: boolean;
            public enableShadingRate: boolean;
            public isPowerOfTwo: boolean;
            public static active: UnityEngine.RenderTexture;
            public get colorBuffer(): UnityEngine.RenderBuffer;
            public get depthBuffer(): UnityEngine.RenderBuffer;
            public depth: number;
            public descriptor: UnityEngine.RenderTextureDescriptor;
            public generateMips: boolean;
            public isCubemap: boolean;
            public isVolume: boolean;
            public static enabled: boolean;
            constructor($desc: UnityEngine.RenderTextureDescriptor);
            constructor($textureToCopy: UnityEngine.RenderTexture);
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.DefaultFormat);
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat);
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number);
            constructor($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number);
            constructor($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat);
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite);
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat);
            constructor($width: number, $height: number, $depth: number);
            constructor($width: number, $height: number, $depth: number, $format: UnityEngine.RenderTextureFormat, $mipCount: number);
            public ApplyDynamicScale(): void;
            public GetNativeDepthBufferPtr(): number;
            public DiscardContents($discardColor: boolean, $discardDepth: boolean): void;
            public MarkRestoreExpected(): void;
            public DiscardContents(): void;
            public ResolveAntiAliasedSurface(): void;
            public ResolveAntiAliasedSurface($target: UnityEngine.RenderTexture): void;
            public SetGlobalShaderProperty($propertyName: string): void;
            public Create(): boolean;
            public Release(): void;
            public IsCreated(): boolean;
            public GenerateMips(): void;
            public ConvertToEquirect($equirect: UnityEngine.RenderTexture, $eye?: UnityEngine.Camera.MonoOrStereoscopicEye): void;
            public static SupportsStencil($rt: UnityEngine.RenderTexture): boolean;
            public static ReleaseTemporary($temp: UnityEngine.RenderTexture): void;
            public static GetTemporary($desc: UnityEngine.RenderTextureDescriptor): UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage, $useDynamicScale: boolean): UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage): UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless): UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number): UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage, $useDynamicScale: boolean): UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless, $vrUsage: UnityEngine.VRTextureUsage): UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $memorylessMode: UnityEngine.RenderTextureMemoryless): UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number): UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite): UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number, $format: UnityEngine.RenderTextureFormat): UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number, $depthBuffer: number): UnityEngine.RenderTexture;
            public static GetTemporary($width: number, $height: number): UnityEngine.RenderTexture;
            public GetTexelOffset(): UnityEngine.Vector2;
        }

        class CustomRenderTextureUpdateZone {
            protected [__keep_incompatibility]: never;
            public updateZoneCenter: UnityEngine.Vector3;
            public updateZoneSize: UnityEngine.Vector3;
            public rotation: number;
            public passIndex: number;
            public needSwap: boolean;
        }

        class CustomRenderTexture extends UnityEngine.RenderTexture {
            protected [__keep_incompatibility]: never;
            public material: UnityEngine.Material;
            public initializationMaterial: UnityEngine.Material;
            public initializationTexture: UnityEngine.Texture;
            public initializationSource: UnityEngine.CustomRenderTextureInitializationSource;
            public initializationColor: UnityEngine.Color;
            public updateMode: UnityEngine.CustomRenderTextureUpdateMode;
            public initializationMode: UnityEngine.CustomRenderTextureUpdateMode;
            public updateZoneSpace: UnityEngine.CustomRenderTextureUpdateZoneSpace;
            public shaderPass: number;
            public cubemapFaceMask: number;
            public doubleBuffered: boolean;
            public wrapUpdateZones: boolean;
            public updatePeriod: number;
            constructor($width: number, $height: number, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite);
            constructor($width: number, $height: number, $format: UnityEngine.RenderTextureFormat);
            constructor($width: number, $height: number);
            constructor($width: number, $height: number, $defaultFormat: UnityEngine.Experimental.Rendering.DefaultFormat);
            constructor($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat);
            public Update($count: number): void;
            public Update(): void;
            public Initialize(): void;
            public ClearUpdateZones(): void;
            public GetUpdateZones($updateZones: System.Collections.Generic.List$1<UnityEngine.CustomRenderTextureUpdateZone>): void;
            public GetDoubleBufferRenderTexture(): UnityEngine.RenderTexture;
            public EnsureDoubleBufferConsistency(): void;
            public SetUpdateZones($updateZones: System.Array$1<UnityEngine.CustomRenderTextureUpdateZone>): void;
        }

        class RenderTextureDescriptor {
            protected [__keep_incompatibility]: never;
            public width: number;
            public height: number;
            public msaaSamples: number;
            public volumeDepth: number;
            public mipCount: number;
            public graphicsFormat: UnityEngine.Experimental.Rendering.GraphicsFormat;
            public stencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat;
            public depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat;
            public colorFormat: UnityEngine.RenderTextureFormat;
            public sRGB: boolean;
            public depthBufferBits: number;
            public dimension: UnityEngine.Rendering.TextureDimension;
            public shadowSamplingMode: UnityEngine.Rendering.ShadowSamplingMode;
            public vrUsage: UnityEngine.VRTextureUsage;
            public get flags(): UnityEngine.RenderTextureCreationFlags;
            public memoryless: UnityEngine.RenderTextureMemoryless;
            public useMipMap: boolean;
            public autoGenerateMips: boolean;
            public enableRandomWrite: boolean;
            public bindMS: boolean;
            public useDynamicScale: boolean;
            public useDynamicScaleExplicit: boolean;
            public enableShadingRate: boolean;
            constructor($width: number, $height: number);
            constructor($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat);
            constructor($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat, $depthBufferBits: number);
            constructor($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthBufferBits: number);
            constructor($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat, $depthBufferBits: number, $mipCount: number);
            constructor($width: number, $height: number, $colorFormat: UnityEngine.RenderTextureFormat, $depthBufferBits: number, $mipCount: number, $readWrite: UnityEngine.RenderTextureReadWrite);
            constructor($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthBufferBits: number, $mipCount: number);
            constructor($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat);
            constructor($width: number, $height: number, $colorFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $depthStencilFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount: number);
        }

        class MipmapLimitDescriptor {
            protected [__keep_incompatibility]: never;
            public get useMipmapLimit(): boolean;
            public get groupName(): string;
            constructor($useMipmapLimit: boolean, $groupName: string);
        }

        class VulkanDeviceFilterData {
            protected [__keep_incompatibility]: never;
            public vendorName: string;
            public deviceName: string;
            public brandName: string;
            public productName: string;
            public androidOsVersionString: string;
            public vulkanApiVersionString: string;
            public driverVersionString: string;
        }

        class VulkanGraphicsJobsDeviceFilterData {
            protected [__keep_incompatibility]: never;
            public preferredMode: UnityEngine.GraphicsJobsFilterMode;
            public filter: UnityEngine.VulkanDeviceFilterData;
        }

        class VulkanDeviceFilterLists extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public vulkanDeviceAllowFilters: System.Array$1<UnityEngine.VulkanDeviceFilterData>;
            public vulkanDeviceDenyFilters: System.Array$1<UnityEngine.VulkanDeviceFilterData>;
            public vulkanGraphicsJobsDeviceFilters: System.Array$1<UnityEngine.VulkanGraphicsJobsDeviceFilterData>;
            constructor($name?: string);
            public EnsureValidOrThrow(): void;
        }

        enum FullScreenMovieControlMode {
            Full = 0,
            Minimal = 1,
            CancelOnInput = 2,
            Hidden = 3
        }

        enum FullScreenMovieScalingMode {
            None = 0,
            AspectFit = 1,
            AspectFill = 2,
            Fill = 3
        }

        enum AndroidActivityIndicatorStyle {
            Large = 0,
            InversedLarge = 1,
            Small = 2,
            InversedSmall = 3,
            DontShow = -1
        }

        class Handheld {
            protected [__keep_incompatibility]: never;
            public static use32BitDisplayBuffer: boolean;
            constructor();
            public static PlayFullScreenMovie($path: string, $bgColor: UnityEngine.Color, $controlMode: UnityEngine.FullScreenMovieControlMode, $scalingMode: UnityEngine.FullScreenMovieScalingMode): boolean;
            public static PlayFullScreenMovie($path: string, $bgColor: UnityEngine.Color, $controlMode: UnityEngine.FullScreenMovieControlMode): boolean;
            public static PlayFullScreenMovie($path: string, $bgColor: UnityEngine.Color): boolean;
            public static PlayFullScreenMovie($path: string): boolean;
            public static Vibrate(): void;
            public static SetActivityIndicatorStyle($style: UnityEngine.iOS.ActivityIndicatorStyle): void;
            public static SetActivityIndicatorStyle($style: UnityEngine.AndroidActivityIndicatorStyle): void;
            public static GetActivityIndicatorStyle(): number;
            public static StartActivityIndicator(): void;
            public static StopActivityIndicator(): void;
            public static ClearShaderCache(): void;
        }

        class Hash128 implements System.IEquatable$1<UnityEngine.Hash128>, System.IComparable, System.IComparable$1<UnityEngine.Hash128> {
            protected [__keep_incompatibility]: never;
            public get isValid(): boolean;
            constructor($u32_0: number, $u32_1: number, $u32_2: number, $u32_3: number);
            constructor($u64_0: bigint, $u64_1: bigint);
            public CompareTo($rhs: UnityEngine.Hash128): number;
            public ToString(): string;
            public static Parse($hashString: string): UnityEngine.Hash128;
            public static Compute($data: string): UnityEngine.Hash128;
            public static Compute<T>($data: Unity.Collections.NativeArray$1<T>): UnityEngine.Hash128;
            public static Compute<T>($data: Unity.Collections.NativeArray$1<T>, $start: number, $count: number): UnityEngine.Hash128;
            public static Compute<T>($data: System.Array$1<T>): UnityEngine.Hash128;
            public static Compute<T>($data: System.Array$1<T>, $start: number, $count: number): UnityEngine.Hash128;
            public static Compute<T>($data: System.Collections.Generic.List$1<T>): UnityEngine.Hash128;
            public static Compute<T>($data: System.Collections.Generic.List$1<T>, $start: number, $count: number): UnityEngine.Hash128;
            public static Compute<T>($val: $Ref<T>): UnityEngine.Hash128;
            public static Compute($val: number): UnityEngine.Hash128;
            public static Compute($val: number): UnityEngine.Hash128;
            public Append($data: string): void;
            public Append<T>($data: Unity.Collections.NativeArray$1<T>): void;
            public Append<T>($data: Unity.Collections.NativeArray$1<T>, $start: number, $count: number): void;
            public Append<T>($data: System.Array$1<T>): void;
            public Append<T>($data: System.Array$1<T>, $start: number, $count: number): void;
            public Append<T>($data: System.Collections.Generic.List$1<T>): void;
            public Append<T>($data: System.Collections.Generic.List$1<T>, $start: number, $count: number): void;
            public Append<T>($val: $Ref<T>): void;
            public Append($val: number): void;
            public Append($val: number): void;
            public Equals($obj: any): boolean;
            public Equals($obj: UnityEngine.Hash128): boolean;
            public GetHashCode(): number;
            public CompareTo($obj: any): number;
        }

        class HashUtilities {
            protected [__keep_incompatibility]: never;
            public static AppendHash($inHash: $Ref<UnityEngine.Hash128>, $outHash: $Ref<UnityEngine.Hash128>): void;
            public static QuantisedMatrixHash($value: $Ref<UnityEngine.Matrix4x4>, $hash: $Ref<UnityEngine.Hash128>): void;
            public static QuantisedVectorHash($value: $Ref<UnityEngine.Vector3>, $hash: $Ref<UnityEngine.Hash128>): void;
            public static ComputeHash128<T>($value: $Ref<T>, $hash: $Ref<UnityEngine.Hash128>): void;
            public static ComputeHash128($value: System.Array$1<number>, $hash: $Ref<UnityEngine.Hash128>): void;
        }

        class HashUnsafeUtilities {
            protected [__keep_incompatibility]: never;
        }

        class HmiPlatform {
            protected [__keep_incompatibility]: never;
            constructor();
            public static LogStartupTiming($tag: string): void;
        }

        enum CursorMode {
            Auto = 0,
            ForceSoftware = 1
        }

        enum CursorLockMode {
            None = 0,
            Locked = 1,
            Confined = 2
        }

        class Cursor {
            protected [__keep_incompatibility]: never;
            public static visible: boolean;
            public static lockState: UnityEngine.CursorLockMode;
            constructor();
            public static SetCursor($texture: UnityEngine.Texture2D, $hotspot: UnityEngine.Vector2, $cursorMode: UnityEngine.CursorMode): void;
        }

        enum EventModifiers {
            None = 0,
            Shift = 1,
            Control = 2,
            Alt = 4,
            Command = 8,
            Numeric = 16,
            CapsLock = 32,
            FunctionKey = 64
        }

        enum KeyCode {
            None = 0,
            Backspace = 8,
            Tab = 9,
            Clear = 12,
            Return = 13,
            Pause = 19,
            Escape = 27,
            Space = 32,
            Exclaim = 33,
            DoubleQuote = 34,
            Hash = 35,
            Dollar = 36,
            Percent = 37,
            Ampersand = 38,
            Quote = 39,
            LeftParen = 40,
            RightParen = 41,
            Asterisk = 42,
            Plus = 43,
            Comma = 44,
            Minus = 45,
            Period = 46,
            Slash = 47,
            Alpha0 = 48,
            Alpha1 = 49,
            Alpha2 = 50,
            Alpha3 = 51,
            Alpha4 = 52,
            Alpha5 = 53,
            Alpha6 = 54,
            Alpha7 = 55,
            Alpha8 = 56,
            Alpha9 = 57,
            Colon = 58,
            Semicolon = 59,
            Less = 60,
            Equals = 61,
            Greater = 62,
            Question = 63,
            At = 64,
            LeftBracket = 91,
            Backslash = 92,
            RightBracket = 93,
            Caret = 94,
            Underscore = 95,
            BackQuote = 96,
            A = 97,
            B = 98,
            C = 99,
            D = 100,
            E = 101,
            F = 102,
            G = 103,
            H = 104,
            I = 105,
            J = 106,
            K = 107,
            L = 108,
            M = 109,
            N = 110,
            O = 111,
            P = 112,
            Q = 113,
            R = 114,
            S = 115,
            T = 116,
            U = 117,
            V = 118,
            W = 119,
            X = 120,
            Y = 121,
            Z = 122,
            LeftCurlyBracket = 123,
            Pipe = 124,
            RightCurlyBracket = 125,
            Tilde = 126,
            Delete = 127,
            Keypad0 = 256,
            Keypad1 = 257,
            Keypad2 = 258,
            Keypad3 = 259,
            Keypad4 = 260,
            Keypad5 = 261,
            Keypad6 = 262,
            Keypad7 = 263,
            Keypad8 = 264,
            Keypad9 = 265,
            KeypadPeriod = 266,
            KeypadDivide = 267,
            KeypadMultiply = 268,
            KeypadMinus = 269,
            KeypadPlus = 270,
            KeypadEnter = 271,
            KeypadEquals = 272,
            UpArrow = 273,
            DownArrow = 274,
            RightArrow = 275,
            LeftArrow = 276,
            Insert = 277,
            Home = 278,
            End = 279,
            PageUp = 280,
            PageDown = 281,
            F1 = 282,
            F2 = 283,
            F3 = 284,
            F4 = 285,
            F5 = 286,
            F6 = 287,
            F7 = 288,
            F8 = 289,
            F9 = 290,
            F10 = 291,
            F11 = 292,
            F12 = 293,
            F13 = 294,
            F14 = 295,
            F15 = 296,
            Numlock = 300,
            CapsLock = 301,
            ScrollLock = 302,
            RightShift = 303,
            LeftShift = 304,
            RightControl = 305,
            LeftControl = 306,
            RightAlt = 307,
            LeftAlt = 308,
            RightCommand = 309,
            RightMeta = 309,
            RightApple = 309,
            LeftCommand = 310,
            LeftMeta = 310,
            LeftApple = 310,
            LeftWindows = 311,
            RightWindows = 312,
            AltGr = 313,
            Help = 315,
            Print = 316,
            SysReq = 317,
            Break = 318,
            Menu = 319,
            WheelUp = 321,
            WheelDown = 322,
            Mouse0 = 323,
            Mouse1 = 324,
            Mouse2 = 325,
            Mouse3 = 326,
            Mouse4 = 327,
            Mouse5 = 328,
            Mouse6 = 329,
            JoystickButton0 = 330,
            JoystickButton1 = 331,
            JoystickButton2 = 332,
            JoystickButton3 = 333,
            JoystickButton4 = 334,
            JoystickButton5 = 335,
            JoystickButton6 = 336,
            JoystickButton7 = 337,
            JoystickButton8 = 338,
            JoystickButton9 = 339,
            JoystickButton10 = 340,
            JoystickButton11 = 341,
            JoystickButton12 = 342,
            JoystickButton13 = 343,
            JoystickButton14 = 344,
            JoystickButton15 = 345,
            JoystickButton16 = 346,
            JoystickButton17 = 347,
            JoystickButton18 = 348,
            JoystickButton19 = 349,
            Joystick1Button0 = 350,
            Joystick1Button1 = 351,
            Joystick1Button2 = 352,
            Joystick1Button3 = 353,
            Joystick1Button4 = 354,
            Joystick1Button5 = 355,
            Joystick1Button6 = 356,
            Joystick1Button7 = 357,
            Joystick1Button8 = 358,
            Joystick1Button9 = 359,
            Joystick1Button10 = 360,
            Joystick1Button11 = 361,
            Joystick1Button12 = 362,
            Joystick1Button13 = 363,
            Joystick1Button14 = 364,
            Joystick1Button15 = 365,
            Joystick1Button16 = 366,
            Joystick1Button17 = 367,
            Joystick1Button18 = 368,
            Joystick1Button19 = 369,
            Joystick2Button0 = 370,
            Joystick2Button1 = 371,
            Joystick2Button2 = 372,
            Joystick2Button3 = 373,
            Joystick2Button4 = 374,
            Joystick2Button5 = 375,
            Joystick2Button6 = 376,
            Joystick2Button7 = 377,
            Joystick2Button8 = 378,
            Joystick2Button9 = 379,
            Joystick2Button10 = 380,
            Joystick2Button11 = 381,
            Joystick2Button12 = 382,
            Joystick2Button13 = 383,
            Joystick2Button14 = 384,
            Joystick2Button15 = 385,
            Joystick2Button16 = 386,
            Joystick2Button17 = 387,
            Joystick2Button18 = 388,
            Joystick2Button19 = 389,
            Joystick3Button0 = 390,
            Joystick3Button1 = 391,
            Joystick3Button2 = 392,
            Joystick3Button3 = 393,
            Joystick3Button4 = 394,
            Joystick3Button5 = 395,
            Joystick3Button6 = 396,
            Joystick3Button7 = 397,
            Joystick3Button8 = 398,
            Joystick3Button9 = 399,
            Joystick3Button10 = 400,
            Joystick3Button11 = 401,
            Joystick3Button12 = 402,
            Joystick3Button13 = 403,
            Joystick3Button14 = 404,
            Joystick3Button15 = 405,
            Joystick3Button16 = 406,
            Joystick3Button17 = 407,
            Joystick3Button18 = 408,
            Joystick3Button19 = 409,
            Joystick4Button0 = 410,
            Joystick4Button1 = 411,
            Joystick4Button2 = 412,
            Joystick4Button3 = 413,
            Joystick4Button4 = 414,
            Joystick4Button5 = 415,
            Joystick4Button6 = 416,
            Joystick4Button7 = 417,
            Joystick4Button8 = 418,
            Joystick4Button9 = 419,
            Joystick4Button10 = 420,
            Joystick4Button11 = 421,
            Joystick4Button12 = 422,
            Joystick4Button13 = 423,
            Joystick4Button14 = 424,
            Joystick4Button15 = 425,
            Joystick4Button16 = 426,
            Joystick4Button17 = 427,
            Joystick4Button18 = 428,
            Joystick4Button19 = 429,
            Joystick5Button0 = 430,
            Joystick5Button1 = 431,
            Joystick5Button2 = 432,
            Joystick5Button3 = 433,
            Joystick5Button4 = 434,
            Joystick5Button5 = 435,
            Joystick5Button6 = 436,
            Joystick5Button7 = 437,
            Joystick5Button8 = 438,
            Joystick5Button9 = 439,
            Joystick5Button10 = 440,
            Joystick5Button11 = 441,
            Joystick5Button12 = 442,
            Joystick5Button13 = 443,
            Joystick5Button14 = 444,
            Joystick5Button15 = 445,
            Joystick5Button16 = 446,
            Joystick5Button17 = 447,
            Joystick5Button18 = 448,
            Joystick5Button19 = 449,
            Joystick6Button0 = 450,
            Joystick6Button1 = 451,
            Joystick6Button2 = 452,
            Joystick6Button3 = 453,
            Joystick6Button4 = 454,
            Joystick6Button5 = 455,
            Joystick6Button6 = 456,
            Joystick6Button7 = 457,
            Joystick6Button8 = 458,
            Joystick6Button9 = 459,
            Joystick6Button10 = 460,
            Joystick6Button11 = 461,
            Joystick6Button12 = 462,
            Joystick6Button13 = 463,
            Joystick6Button14 = 464,
            Joystick6Button15 = 465,
            Joystick6Button16 = 466,
            Joystick6Button17 = 467,
            Joystick6Button18 = 468,
            Joystick6Button19 = 469,
            Joystick7Button0 = 470,
            Joystick7Button1 = 471,
            Joystick7Button2 = 472,
            Joystick7Button3 = 473,
            Joystick7Button4 = 474,
            Joystick7Button5 = 475,
            Joystick7Button6 = 476,
            Joystick7Button7 = 477,
            Joystick7Button8 = 478,
            Joystick7Button9 = 479,
            Joystick7Button10 = 480,
            Joystick7Button11 = 481,
            Joystick7Button12 = 482,
            Joystick7Button13 = 483,
            Joystick7Button14 = 484,
            Joystick7Button15 = 485,
            Joystick7Button16 = 486,
            Joystick7Button17 = 487,
            Joystick7Button18 = 488,
            Joystick7Button19 = 489,
            Joystick8Button0 = 490,
            Joystick8Button1 = 491,
            Joystick8Button2 = 492,
            Joystick8Button3 = 493,
            Joystick8Button4 = 494,
            Joystick8Button5 = 495,
            Joystick8Button6 = 496,
            Joystick8Button7 = 497,
            Joystick8Button8 = 498,
            Joystick8Button9 = 499,
            Joystick8Button10 = 500,
            Joystick8Button11 = 501,
            Joystick8Button12 = 502,
            Joystick8Button13 = 503,
            Joystick8Button14 = 504,
            Joystick8Button15 = 505,
            Joystick8Button16 = 506,
            Joystick8Button17 = 507,
            Joystick8Button18 = 508,
            Joystick8Button19 = 509,
            F16 = 670,
            F17 = 671,
            F18 = 672,
            F19 = 673,
            F20 = 674,
            F21 = 675,
            F22 = 676,
            F23 = 677,
            F24 = 678
        }

        enum iPhoneScreenOrientation {
            Unknown = 0,
            Portrait = 1,
            PortraitUpsideDown = 2,
            LandscapeLeft = 3,
            LandscapeRight = 4,
            AutoRotation = 5,
            Landscape = 6
        }

        enum iPhoneNetworkReachability {
            NotReachable = 0,
            ReachableViaCarrierDataNetwork = 1,
            ReachableViaWiFiNetwork = 2
        }

        enum iPhoneGeneration {
            Unknown = 0,
            iPhone = 1,
            iPhone3G = 2,
            iPhone3GS = 3,
            iPodTouch1Gen = 4,
            iPodTouch2Gen = 5,
            iPodTouch3Gen = 6,
            iPad1Gen = 7,
            iPhone4 = 8,
            iPodTouch4Gen = 9,
            iPad2Gen = 10,
            iPhone4S = 11,
            iPad3Gen = 12,
            iPhone5 = 13,
            iPodTouch5Gen = 14,
            iPadMini1Gen = 15,
            iPad4Gen = 16,
            iPhone5C = 17,
            iPhone5S = 18,
            iPhoneUnknown = 19,
            iPadUnknown = 20,
            iPodTouchUnknown = 21
        }

        class iPhoneSettings {
            protected [__keep_incompatibility]: never;
            public static get verticalOrientation(): boolean;
            public static get screenCanDarken(): boolean;
            constructor();
        }

        enum iPhoneTouchPhase {
            Began = 0,
            Moved = 1,
            Stationary = 2,
            Ended = 3,
            Canceled = 4
        }

        class iPhoneTouch {
            protected [__keep_incompatibility]: never;
            public get fingerId(): number;
            public get position(): UnityEngine.Vector2;
            public get deltaPosition(): UnityEngine.Vector2;
            public get deltaTime(): number;
            public get tapCount(): number;
            public get phase(): UnityEngine.iPhoneTouchPhase;
        }

        enum iPhoneMovieControlMode {
            Full = 0,
            Minimal = 1,
            CancelOnTouch = 2,
            Hidden = 3,
            VolumeOnly = 4
        }

        enum iPhoneMovieScalingMode {
            None = 0,
            AspectFit = 1,
            AspectFill = 2,
            Fill = 3
        }

        class iPhoneUtils {
            protected [__keep_incompatibility]: never;
            public static get isApplicationGenuine(): boolean;
            public static get isApplicationGenuineAvailable(): boolean;
            constructor();
            public static PlayMovie($path: string, $bgColor: UnityEngine.Color, $controlMode: UnityEngine.iPhoneMovieControlMode, $scalingMode: UnityEngine.iPhoneMovieScalingMode): void;
            public static PlayMovie($path: string, $bgColor: UnityEngine.Color, $controlMode: UnityEngine.iPhoneMovieControlMode): void;
            public static PlayMovie($path: string, $bgColor: UnityEngine.Color): void;
            public static PlayMovieURL($url: string, $bgColor: UnityEngine.Color, $controlMode: UnityEngine.iPhoneMovieControlMode, $scalingMode: UnityEngine.iPhoneMovieScalingMode): void;
            public static PlayMovieURL($url: string, $bgColor: UnityEngine.Color, $controlMode: UnityEngine.iPhoneMovieControlMode): void;
            public static PlayMovieURL($url: string, $bgColor: UnityEngine.Color): void;
            public static Vibrate(): void;
        }

        enum iPhoneKeyboardType {
            Default = 0,
            ASCIICapable = 1,
            NumbersAndPunctuation = 2,
            URL = 3,
            NumberPad = 4,
            PhonePad = 5,
            NamePhonePad = 6,
            EmailAddress = 7
        }

        class iPhoneKeyboard {
            protected [__keep_incompatibility]: never;
            public text: string;
            public static hideInput: boolean;
            public active: boolean;
            public get done(): boolean;
            public static get area(): UnityEngine.Rect;
            public static get visible(): boolean;
            constructor();
        }

        class iPhoneAccelerationEvent {
            protected [__keep_incompatibility]: never;
            public get acceleration(): UnityEngine.Vector3;
            public get deltaTime(): number;
        }

        enum iPhoneOrientation {
            Unknown = 0,
            Portrait = 1,
            PortraitUpsideDown = 2,
            LandscapeLeft = 3,
            LandscapeRight = 4,
            FaceUp = 5,
            FaceDown = 6
        }

        class iPhoneInput {
            protected [__keep_incompatibility]: never;
            public static get accelerationEvents(): System.Array$1<UnityEngine.iPhoneAccelerationEvent>;
            public static get touches(): System.Array$1<UnityEngine.iPhoneTouch>;
            public static get touchCount(): number;
            public static multiTouchEnabled: boolean;
            public static get accelerationEventCount(): number;
            public static get acceleration(): UnityEngine.Vector3;
            constructor();
            public static GetTouch($index: number): UnityEngine.iPhoneTouch;
            public static GetAccelerationEvent($index: number): UnityEngine.iPhoneAccelerationEvent;
        }

        class iPhone {
            protected [__keep_incompatibility]: never;
            public static get generation(): UnityEngine.iPhoneGeneration;
            public static get vendorIdentifier(): string;
            public static get advertisingIdentifier(): string;
            public static get advertisingTrackingEnabled(): boolean;
            constructor();
            public static SetNoBackupFlag($path: string): void;
            public static ResetNoBackupFlag($path: string): void;
        }

        class ADBannerView {
            protected [__keep_incompatibility]: never;
            public get loaded(): boolean;
            public visible: boolean;
            public layout: UnityEngine.ADBannerView.Layout;
            public position: UnityEngine.Vector2;
            public get size(): UnityEngine.Vector2;
            constructor($type: UnityEngine.ADBannerView.Type, $layout: UnityEngine.ADBannerView.Layout);
            public static IsAvailable($type: UnityEngine.ADBannerView.Type): boolean;
            public static add_onBannerWasClicked(handler: UnityEngine.ADBannerView.BannerWasClickedDelegate): void;
            public static remove_onBannerWasClicked(handler: UnityEngine.ADBannerView.BannerWasClickedDelegate): void;
            public static add_onBannerWasLoaded(handler: UnityEngine.ADBannerView.BannerWasLoadedDelegate): void;
            public static remove_onBannerWasLoaded(handler: UnityEngine.ADBannerView.BannerWasLoadedDelegate): void;
        }
        namespace ADBannerView {
            enum Layout {
                Top = 0,
                TopLeft = 0,
                Bottom = 1,
                BottomLeft = 1,
                CenterLeft = 2,
                TopRight = 4,
                BottomRight = 5,
                CenterRight = 6,
                TopCenter = 8,
                BottomCenter = 9,
                Center = 10,
                Manual = -1
            }

            enum Type {
                Banner = 0,
                MediumRect = 1
            }

            interface BannerWasClickedDelegate {
                (): void;
                Invoke?: () => void;
            }
            var BannerWasClickedDelegate: { new (func: () => void): BannerWasClickedDelegate; };

            interface BannerWasLoadedDelegate {
                (): void;
                Invoke?: () => void;
            }
            var BannerWasLoadedDelegate: { new (func: () => void): BannerWasLoadedDelegate; };

        }

        class ADInterstitialAd {
            protected [__keep_incompatibility]: never;
            public static get isAvailable(): boolean;
            public get loaded(): boolean;
            constructor($autoReload: boolean);
            constructor();
            public Show(): void;
            public ReloadAd(): void;
            public static add_onInterstitialWasLoaded(handler: UnityEngine.ADInterstitialAd.InterstitialWasLoadedDelegate): void;
            public static remove_onInterstitialWasLoaded(handler: UnityEngine.ADInterstitialAd.InterstitialWasLoadedDelegate): void;
        }
        namespace ADInterstitialAd {
            interface InterstitialWasLoadedDelegate {
                (): void;
                Invoke?: () => void;
            }
            var InterstitialWasLoadedDelegate: { new (func: () => void): InterstitialWasLoadedDelegate; };

        }

        interface ILogger extends UnityEngine.ILogHandler {
            logHandler: UnityEngine.ILogHandler;
            logEnabled: boolean;
            filterLogType: UnityEngine.LogType;
            IsLogTypeAllowed($logType: UnityEngine.LogType): boolean;
            Log($logType: UnityEngine.LogType, $message: any): void;
            Log($logType: UnityEngine.LogType, $message: any, $context: UnityEngine.Object): void;
            Log($logType: UnityEngine.LogType, $tag: string, $message: any): void;
            Log($logType: UnityEngine.LogType, $tag: string, $message: any, $context: UnityEngine.Object): void;
            Log($message: any): void;
            Log($tag: string, $message: any): void;
            Log($tag: string, $message: any, $context: UnityEngine.Object): void;
            LogWarning($tag: string, $message: any): void;
            LogWarning($tag: string, $message: any, $context: UnityEngine.Object): void;
            LogError($tag: string, $message: any): void;
            LogError($tag: string, $message: any, $context: UnityEngine.Object): void;
            LogFormat($logType: UnityEngine.LogType, $format: string, ...args: any[]): void;
            LogException($exception: System.Exception): void;
        }

        interface ILogHandler {
            LogFormat($logType: UnityEngine.LogType, $context: UnityEngine.Object, $format: string, ...args: any[]): void;
            LogException($exception: System.Exception, $context: UnityEngine.Object): void;
        }

        class Logger implements UnityEngine.ILogger, UnityEngine.ILogHandler {
            protected [__keep_incompatibility]: never;
            public logHandler: UnityEngine.ILogHandler;
            public logEnabled: boolean;
            public filterLogType: UnityEngine.LogType;
            constructor($logHandler: UnityEngine.ILogHandler);
            public IsLogTypeAllowed($logType: UnityEngine.LogType): boolean;
            public Log($logType: UnityEngine.LogType, $message: any): void;
            public Log($logType: UnityEngine.LogType, $message: any, $context: UnityEngine.Object): void;
            public Log($logType: UnityEngine.LogType, $tag: string, $message: any): void;
            public Log($logType: UnityEngine.LogType, $tag: string, $message: any, $context: UnityEngine.Object): void;
            public Log($message: any): void;
            public Log($tag: string, $message: any): void;
            public Log($tag: string, $message: any, $context: UnityEngine.Object): void;
            public LogWarning($tag: string, $message: any): void;
            public LogWarning($tag: string, $message: any, $context: UnityEngine.Object): void;
            public LogError($tag: string, $message: any): void;
            public LogError($tag: string, $message: any, $context: UnityEngine.Object): void;
            public LogException($exception: System.Exception): void;
            public LogException($exception: System.Exception, $context: UnityEngine.Object): void;
            public LogFormat($logType: UnityEngine.LogType, $format: string, ...args: any[]): void;
            public LogFormat($logType: UnityEngine.LogType, $context: UnityEngine.Object, $format: string, ...args: any[]): void;
        }

        class Color implements System.IEquatable$1<UnityEngine.Color>, System.IFormattable {
            protected [__keep_incompatibility]: never;
            public r: number;
            public g: number;
            public b: number;
            public a: number;
            public get grayscale(): number;
            public get linear(): UnityEngine.Color;
            public get gamma(): UnityEngine.Color;
            public get maxColorComponent(): number;
            public static get aliceBlue(): UnityEngine.Color;
            public static get antiqueWhite(): UnityEngine.Color;
            public static get aquamarine(): UnityEngine.Color;
            public static get azure(): UnityEngine.Color;
            public static get beige(): UnityEngine.Color;
            public static get bisque(): UnityEngine.Color;
            public static get black(): UnityEngine.Color;
            public static get blanchedAlmond(): UnityEngine.Color;
            public static get blue(): UnityEngine.Color;
            public static get blueViolet(): UnityEngine.Color;
            public static get brown(): UnityEngine.Color;
            public static get burlywood(): UnityEngine.Color;
            public static get cadetBlue(): UnityEngine.Color;
            public static get chartreuse(): UnityEngine.Color;
            public static get chocolate(): UnityEngine.Color;
            public static get clear(): UnityEngine.Color;
            public static get coral(): UnityEngine.Color;
            public static get cornflowerBlue(): UnityEngine.Color;
            public static get cornsilk(): UnityEngine.Color;
            public static get crimson(): UnityEngine.Color;
            public static get cyan(): UnityEngine.Color;
            public static get darkBlue(): UnityEngine.Color;
            public static get darkCyan(): UnityEngine.Color;
            public static get darkGoldenRod(): UnityEngine.Color;
            public static get darkGray(): UnityEngine.Color;
            public static get darkGreen(): UnityEngine.Color;
            public static get darkKhaki(): UnityEngine.Color;
            public static get darkMagenta(): UnityEngine.Color;
            public static get darkOliveGreen(): UnityEngine.Color;
            public static get darkOrange(): UnityEngine.Color;
            public static get darkOrchid(): UnityEngine.Color;
            public static get darkRed(): UnityEngine.Color;
            public static get darkSalmon(): UnityEngine.Color;
            public static get darkSeaGreen(): UnityEngine.Color;
            public static get darkSlateBlue(): UnityEngine.Color;
            public static get darkSlateGray(): UnityEngine.Color;
            public static get darkTurquoise(): UnityEngine.Color;
            public static get darkViolet(): UnityEngine.Color;
            public static get deepPink(): UnityEngine.Color;
            public static get deepSkyBlue(): UnityEngine.Color;
            public static get dimGray(): UnityEngine.Color;
            public static get dodgerBlue(): UnityEngine.Color;
            public static get firebrick(): UnityEngine.Color;
            public static get floralWhite(): UnityEngine.Color;
            public static get forestGreen(): UnityEngine.Color;
            public static get gainsboro(): UnityEngine.Color;
            public static get ghostWhite(): UnityEngine.Color;
            public static get gold(): UnityEngine.Color;
            public static get goldenRod(): UnityEngine.Color;
            public static get gray(): UnityEngine.Color;
            public static get grey(): UnityEngine.Color;
            public static get gray1(): UnityEngine.Color;
            public static get gray2(): UnityEngine.Color;
            public static get gray3(): UnityEngine.Color;
            public static get gray4(): UnityEngine.Color;
            public static get gray5(): UnityEngine.Color;
            public static get gray6(): UnityEngine.Color;
            public static get gray7(): UnityEngine.Color;
            public static get gray8(): UnityEngine.Color;
            public static get gray9(): UnityEngine.Color;
            public static get green(): UnityEngine.Color;
            public static get greenYellow(): UnityEngine.Color;
            public static get honeydew(): UnityEngine.Color;
            public static get hotPink(): UnityEngine.Color;
            public static get indianRed(): UnityEngine.Color;
            public static get indigo(): UnityEngine.Color;
            public static get ivory(): UnityEngine.Color;
            public static get khaki(): UnityEngine.Color;
            public static get lavender(): UnityEngine.Color;
            public static get lavenderBlush(): UnityEngine.Color;
            public static get lawnGreen(): UnityEngine.Color;
            public static get lemonChiffon(): UnityEngine.Color;
            public static get lightBlue(): UnityEngine.Color;
            public static get lightCoral(): UnityEngine.Color;
            public static get lightCyan(): UnityEngine.Color;
            public static get lightGoldenRod(): UnityEngine.Color;
            public static get lightGoldenRodYellow(): UnityEngine.Color;
            public static get lightGray(): UnityEngine.Color;
            public static get lightGreen(): UnityEngine.Color;
            public static get lightPink(): UnityEngine.Color;
            public static get lightSalmon(): UnityEngine.Color;
            public static get lightSeaGreen(): UnityEngine.Color;
            public static get lightSkyBlue(): UnityEngine.Color;
            public static get lightSlateBlue(): UnityEngine.Color;
            public static get lightSlateGray(): UnityEngine.Color;
            public static get lightSteelBlue(): UnityEngine.Color;
            public static get lightYellow(): UnityEngine.Color;
            public static get limeGreen(): UnityEngine.Color;
            public static get linen(): UnityEngine.Color;
            public static get magenta(): UnityEngine.Color;
            public static get maroon(): UnityEngine.Color;
            public static get mediumAquamarine(): UnityEngine.Color;
            public static get mediumBlue(): UnityEngine.Color;
            public static get mediumOrchid(): UnityEngine.Color;
            public static get mediumPurple(): UnityEngine.Color;
            public static get mediumSeaGreen(): UnityEngine.Color;
            public static get mediumSlateBlue(): UnityEngine.Color;
            public static get mediumSpringGreen(): UnityEngine.Color;
            public static get mediumTurquoise(): UnityEngine.Color;
            public static get mediumVioletRed(): UnityEngine.Color;
            public static get midnightBlue(): UnityEngine.Color;
            public static get mintCream(): UnityEngine.Color;
            public static get mistyRose(): UnityEngine.Color;
            public static get moccasin(): UnityEngine.Color;
            public static get navajoWhite(): UnityEngine.Color;
            public static get navyBlue(): UnityEngine.Color;
            public static get oldLace(): UnityEngine.Color;
            public static get olive(): UnityEngine.Color;
            public static get oliveDrab(): UnityEngine.Color;
            public static get orange(): UnityEngine.Color;
            public static get orangeRed(): UnityEngine.Color;
            public static get orchid(): UnityEngine.Color;
            public static get paleGoldenRod(): UnityEngine.Color;
            public static get paleGreen(): UnityEngine.Color;
            public static get paleTurquoise(): UnityEngine.Color;
            public static get paleVioletRed(): UnityEngine.Color;
            public static get papayaWhip(): UnityEngine.Color;
            public static get peachPuff(): UnityEngine.Color;
            public static get peru(): UnityEngine.Color;
            public static get pink(): UnityEngine.Color;
            public static get plum(): UnityEngine.Color;
            public static get powderBlue(): UnityEngine.Color;
            public static get purple(): UnityEngine.Color;
            public static get rebeccaPurple(): UnityEngine.Color;
            public static get red(): UnityEngine.Color;
            public static get rosyBrown(): UnityEngine.Color;
            public static get royalBlue(): UnityEngine.Color;
            public static get saddleBrown(): UnityEngine.Color;
            public static get salmon(): UnityEngine.Color;
            public static get sandyBrown(): UnityEngine.Color;
            public static get seaGreen(): UnityEngine.Color;
            public static get seashell(): UnityEngine.Color;
            public static get sienna(): UnityEngine.Color;
            public static get silver(): UnityEngine.Color;
            public static get skyBlue(): UnityEngine.Color;
            public static get slateBlue(): UnityEngine.Color;
            public static get slateGray(): UnityEngine.Color;
            public static get snow(): UnityEngine.Color;
            public static get softRed(): UnityEngine.Color;
            public static get softBlue(): UnityEngine.Color;
            public static get softGreen(): UnityEngine.Color;
            public static get softYellow(): UnityEngine.Color;
            public static get springGreen(): UnityEngine.Color;
            public static get steelBlue(): UnityEngine.Color;
            public static get tan(): UnityEngine.Color;
            public static get teal(): UnityEngine.Color;
            public static get thistle(): UnityEngine.Color;
            public static get tomato(): UnityEngine.Color;
            public static get turquoise(): UnityEngine.Color;
            public static get violet(): UnityEngine.Color;
            public static get violetRed(): UnityEngine.Color;
            public static get wheat(): UnityEngine.Color;
            public static get white(): UnityEngine.Color;
            public static get whiteSmoke(): UnityEngine.Color;
            public static get yellow(): UnityEngine.Color;
            public static get yellowGreen(): UnityEngine.Color;
            public static get yellowNice(): UnityEngine.Color;
            constructor($r: number, $g: number, $b: number, $a: number);
            constructor($r: number, $g: number, $b: number);
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
            public GetHashCode(): number;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.Color): boolean;
            public Equals($other: $Ref<UnityEngine.Color>): boolean;
            public static Lerp($a: UnityEngine.Color, $b: UnityEngine.Color, $t: number): UnityEngine.Color;
            public static Lerp($a: $Ref<UnityEngine.Color>, $b: $Ref<UnityEngine.Color>, $t: number): UnityEngine.Color;
            public static LerpUnclamped($a: UnityEngine.Color, $b: UnityEngine.Color, $t: number): UnityEngine.Color;
            public static LerpUnclamped($a: $Ref<UnityEngine.Color>, $b: $Ref<UnityEngine.Color>, $t: number): UnityEngine.Color;
            public static RGBToHSV($rgbColor: UnityEngine.Color, $H: $Out<number>, $S: $Out<number>, $V: $Out<number>): void;
            public static RGBToHSV($rgbColor: $Ref<UnityEngine.Color>, $H: $Out<number>, $S: $Out<number>, $V: $Out<number>): void;
            public static HSVToRGB($H: number, $S: number, $V: number): UnityEngine.Color;
            public static HSVToRGB($H: number, $S: number, $V: number, $hdr: boolean): UnityEngine.Color;
            public get_Item($index: number): number;
            public set_Item($index: number, value: number): void;
        }

        class Color32 implements System.IEquatable$1<UnityEngine.Color32>, System.IFormattable {
            protected [__keep_incompatibility]: never;
            public r: number;
            public g: number;
            public b: number;
            public a: number;
            constructor($r: number, $g: number, $b: number, $a: number);
            public static Lerp($a: UnityEngine.Color32, $b: UnityEngine.Color32, $t: number): UnityEngine.Color32;
            public static Lerp($a: $Ref<UnityEngine.Color32>, $b: $Ref<UnityEngine.Color32>, $t: number): UnityEngine.Color32;
            public static LerpUnclamped($a: UnityEngine.Color32, $b: UnityEngine.Color32, $t: number): UnityEngine.Color32;
            public static LerpUnclamped($a: $Ref<UnityEngine.Color32>, $b: $Ref<UnityEngine.Color32>, $t: number): UnityEngine.Color32;
            public GetHashCode(): number;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.Color32): boolean;
            public Equals($other: $Ref<UnityEngine.Color32>): boolean;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
            public get_Item($index: number): number;
            public set_Item($index: number, value: number): void;
        }

        class ColorUtility {
            protected [__keep_incompatibility]: never;
            constructor();
            public static TryParseHtmlString($htmlString: string, $color: $Out<UnityEngine.Color>): boolean;
            public static ToHtmlStringRGB($color: UnityEngine.Color): string;
            public static ToHtmlStringRGB($color: $Ref<UnityEngine.Color>): string;
            public static ToHtmlStringRGBA($color: UnityEngine.Color): string;
            public static ToHtmlStringRGBA($color: $Ref<UnityEngine.Color>): string;
        }

        class GradientColorKey {
            protected [__keep_incompatibility]: never;
            public color: UnityEngine.Color;
            public time: number;
            constructor($col: UnityEngine.Color, $time: number);
            constructor($col: $Ref<UnityEngine.Color>, $time: number);
        }

        class GradientAlphaKey {
            protected [__keep_incompatibility]: never;
            public alpha: number;
            public time: number;
            constructor($alpha: number, $time: number);
        }

        enum GradientMode {
            Blend = 0,
            Fixed = 1,
            PerceptualBlend = 2
        }

        class Gradient implements System.IEquatable$1<UnityEngine.Gradient> {
            protected [__keep_incompatibility]: never;
            public colorKeys: System.Array$1<UnityEngine.GradientColorKey>;
            public alphaKeys: System.Array$1<UnityEngine.GradientAlphaKey>;
            public get colorKeyCount(): number;
            public get alphaKeyCount(): number;
            public mode: UnityEngine.GradientMode;
            public colorSpace: UnityEngine.ColorSpace;
            constructor();
            public Evaluate($time: number): UnityEngine.Color;
            public GetColorKeys($keys: System.Span$1<UnityEngine.GradientColorKey>): void;
            public GetAlphaKeys($keys: System.Span$1<UnityEngine.GradientAlphaKey>): void;
            public SetColorKeys($keys: System.ReadOnlySpan$1<UnityEngine.GradientColorKey>): void;
            public SetAlphaKeys($keys: System.ReadOnlySpan$1<UnityEngine.GradientAlphaKey>): void;
            public SetKeys($colorKeys: System.Array$1<UnityEngine.GradientColorKey>, $alphaKeys: System.Array$1<UnityEngine.GradientAlphaKey>): void;
            public SetKeys($colorKeys: System.ReadOnlySpan$1<UnityEngine.GradientColorKey>, $alphaKeys: System.ReadOnlySpan$1<UnityEngine.GradientAlphaKey>): void;
            public Equals($o: any): boolean;
            public Equals($other: UnityEngine.Gradient): boolean;
            public GetHashCode(): number;
        }

        class FrustumPlanes {
            protected [__keep_incompatibility]: never;
            public left: number;
            public right: number;
            public bottom: number;
            public top: number;
            public zNear: number;
            public zFar: number;
        }

        class Matrix4x4 implements System.IEquatable$1<UnityEngine.Matrix4x4>, System.IFormattable {
            protected [__keep_incompatibility]: never;
            public m00: number;
            public m10: number;
            public m20: number;
            public m30: number;
            public m01: number;
            public m11: number;
            public m21: number;
            public m31: number;
            public m02: number;
            public m12: number;
            public m22: number;
            public m32: number;
            public m03: number;
            public m13: number;
            public m23: number;
            public m33: number;
            public get rotation(): UnityEngine.Quaternion;
            public get lossyScale(): UnityEngine.Vector3;
            public get isIdentity(): boolean;
            public get determinant(): number;
            public get decomposeProjection(): UnityEngine.FrustumPlanes;
            public get inverse(): UnityEngine.Matrix4x4;
            public get transpose(): UnityEngine.Matrix4x4;
            public static get zero(): UnityEngine.Matrix4x4;
            public static get identity(): UnityEngine.Matrix4x4;
            constructor($column0: UnityEngine.Vector4, $column1: UnityEngine.Vector4, $column2: UnityEngine.Vector4, $column3: UnityEngine.Vector4);
            constructor($column0: $Ref<UnityEngine.Vector4>, $column1: $Ref<UnityEngine.Vector4>, $column2: $Ref<UnityEngine.Vector4>, $column3: $Ref<UnityEngine.Vector4>);
            public ValidTRS(): boolean;
            public static Determinant($m: UnityEngine.Matrix4x4): number;
            public static Determinant($m: $Ref<UnityEngine.Matrix4x4>): number;
            public static TRS($pos: UnityEngine.Vector3, $q: UnityEngine.Quaternion, $s: UnityEngine.Vector3): UnityEngine.Matrix4x4;
            public static TRS($pos: $Ref<UnityEngine.Vector3>, $q: $Ref<UnityEngine.Quaternion>, $s: $Ref<UnityEngine.Vector3>): UnityEngine.Matrix4x4;
            public SetTRS($pos: UnityEngine.Vector3, $q: UnityEngine.Quaternion, $s: UnityEngine.Vector3): void;
            public SetTRS($pos: $Ref<UnityEngine.Vector3>, $q: $Ref<UnityEngine.Quaternion>, $s: $Ref<UnityEngine.Vector3>): void;
            public static Inverse3DAffine($input: UnityEngine.Matrix4x4, $result: $Ref<UnityEngine.Matrix4x4>): boolean;
            public static Inverse3DAffine($input: $Ref<UnityEngine.Matrix4x4>, $result: $Ref<UnityEngine.Matrix4x4>): boolean;
            public static Inverse($m: UnityEngine.Matrix4x4): UnityEngine.Matrix4x4;
            public static Inverse($m: $Ref<UnityEngine.Matrix4x4>): UnityEngine.Matrix4x4;
            public static Transpose($m: UnityEngine.Matrix4x4): UnityEngine.Matrix4x4;
            public static Transpose($m: $Ref<UnityEngine.Matrix4x4>): UnityEngine.Matrix4x4;
            public static Ortho($left: number, $right: number, $bottom: number, $top: number, $zNear: number, $zFar: number): UnityEngine.Matrix4x4;
            public static Perspective($fov: number, $aspect: number, $zNear: number, $zFar: number): UnityEngine.Matrix4x4;
            public static LookAt($from: UnityEngine.Vector3, $to: UnityEngine.Vector3, $up: UnityEngine.Vector3): UnityEngine.Matrix4x4;
            public static LookAt($from: $Ref<UnityEngine.Vector3>, $to: $Ref<UnityEngine.Vector3>, $up: $Ref<UnityEngine.Vector3>): UnityEngine.Matrix4x4;
            public static Frustum($left: number, $right: number, $bottom: number, $top: number, $zNear: number, $zFar: number): UnityEngine.Matrix4x4;
            public static Frustum($fp: UnityEngine.FrustumPlanes): UnityEngine.Matrix4x4;
            public static Frustum($fp: $Ref<UnityEngine.FrustumPlanes>): UnityEngine.Matrix4x4;
            public GetHashCode(): number;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.Matrix4x4): boolean;
            public Equals($other: $Ref<UnityEngine.Matrix4x4>): boolean;
            public GetColumn($index: number): UnityEngine.Vector4;
            public GetRow($index: number): UnityEngine.Vector4;
            public GetPosition(): UnityEngine.Vector3;
            public SetColumn($index: number, $column: UnityEngine.Vector4): void;
            public SetColumn($index: number, $column: $Ref<UnityEngine.Vector4>): void;
            public SetRow($index: number, $row: UnityEngine.Vector4): void;
            public SetRow($index: number, $row: $Ref<UnityEngine.Vector4>): void;
            public MultiplyPoint($point: UnityEngine.Vector3): UnityEngine.Vector3;
            public MultiplyPoint($point: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3;
            public MultiplyPoint3x4($point: UnityEngine.Vector3): UnityEngine.Vector3;
            public MultiplyPoint3x4($point: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3;
            public MultiplyVector($vector: UnityEngine.Vector3): UnityEngine.Vector3;
            public MultiplyVector($vector: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3;
            public TransformPlane($plane: UnityEngine.Plane): UnityEngine.Plane;
            public TransformPlane($plane: $Ref<UnityEngine.Plane>): UnityEngine.Plane;
            public static Scale($vector: UnityEngine.Vector3): UnityEngine.Matrix4x4;
            public static Scale($vector: $Ref<UnityEngine.Vector3>): UnityEngine.Matrix4x4;
            public static Translate($vector: UnityEngine.Vector3): UnityEngine.Matrix4x4;
            public static Translate($vector: $Ref<UnityEngine.Vector3>): UnityEngine.Matrix4x4;
            public static Rotate($q: UnityEngine.Quaternion): UnityEngine.Matrix4x4;
            public static Rotate($q: $Ref<UnityEngine.Quaternion>): UnityEngine.Matrix4x4;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
            public get_Item($row: number, $column: number): number;
            public set_Item($row: number, $column: number, value: number): void;
            public get_Item($index: number): number;
            public set_Item($index: number, value: number): void;
        }

        class Vector3 implements System.IEquatable$1<UnityEngine.Vector3>, System.IFormattable {
            protected [__keep_incompatibility]: never;
            public static readonly kEpsilon: number;
            public static readonly kEpsilonNormalSqrt: number;
            public x: number;
            public y: number;
            public z: number;
            public get normalized(): UnityEngine.Vector3;
            public get magnitude(): number;
            public get sqrMagnitude(): number;
            public static get zero(): UnityEngine.Vector3;
            public static get one(): UnityEngine.Vector3;
            public static get forward(): UnityEngine.Vector3;
            public static get back(): UnityEngine.Vector3;
            public static get up(): UnityEngine.Vector3;
            public static get down(): UnityEngine.Vector3;
            public static get left(): UnityEngine.Vector3;
            public static get right(): UnityEngine.Vector3;
            public static get positiveInfinity(): UnityEngine.Vector3;
            public static get negativeInfinity(): UnityEngine.Vector3;
            public static get fwd(): UnityEngine.Vector3;
            constructor($x: number, $y: number, $z: number);
            constructor($x: number, $y: number);
            public static Slerp($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number): UnityEngine.Vector3;
            public static Slerp($a: $Ref<UnityEngine.Vector3>, $b: $Ref<UnityEngine.Vector3>, $t: number): UnityEngine.Vector3;
            public static SlerpUnclamped($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number): UnityEngine.Vector3;
            public static SlerpUnclamped($a: $Ref<UnityEngine.Vector3>, $b: $Ref<UnityEngine.Vector3>, $t: number): UnityEngine.Vector3;
            public static OrthoNormalize($normal: $Ref<UnityEngine.Vector3>, $tangent: $Ref<UnityEngine.Vector3>): void;
            public static OrthoNormalize($normal: $Ref<UnityEngine.Vector3>, $tangent: $Ref<UnityEngine.Vector3>, $binormal: $Ref<UnityEngine.Vector3>): void;
            public static RotateTowards($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $maxRadiansDelta: number, $maxMagnitudeDelta: number): UnityEngine.Vector3;
            public static RotateTowards($current: $Ref<UnityEngine.Vector3>, $target: $Ref<UnityEngine.Vector3>, $maxRadiansDelta: number, $maxMagnitudeDelta: number): UnityEngine.Vector3;
            public static Lerp($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number): UnityEngine.Vector3;
            public static Lerp($a: $Ref<UnityEngine.Vector3>, $b: $Ref<UnityEngine.Vector3>, $t: number): UnityEngine.Vector3;
            public static LerpUnclamped($a: UnityEngine.Vector3, $b: UnityEngine.Vector3, $t: number): UnityEngine.Vector3;
            public static LerpUnclamped($a: $Ref<UnityEngine.Vector3>, $b: $Ref<UnityEngine.Vector3>, $t: number): UnityEngine.Vector3;
            public static MoveTowards($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $maxDistanceDelta: number): UnityEngine.Vector3;
            public static MoveTowards($current: $Ref<UnityEngine.Vector3>, $target: $Ref<UnityEngine.Vector3>, $maxDistanceDelta: number): UnityEngine.Vector3;
            public static SmoothDamp($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number, $maxSpeed: number): UnityEngine.Vector3;
            public static SmoothDamp($current: $Ref<UnityEngine.Vector3>, $target: $Ref<UnityEngine.Vector3>, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number, $maxSpeed: number): UnityEngine.Vector3;
            public static SmoothDamp($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number): UnityEngine.Vector3;
            public static SmoothDamp($current: $Ref<UnityEngine.Vector3>, $target: $Ref<UnityEngine.Vector3>, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number): UnityEngine.Vector3;
            public static SmoothDamp($current: UnityEngine.Vector3, $target: UnityEngine.Vector3, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number, $maxSpeed: number, $deltaTime: number): UnityEngine.Vector3;
            public static SmoothDamp($current: $Ref<UnityEngine.Vector3>, $target: $Ref<UnityEngine.Vector3>, $currentVelocity: $Ref<UnityEngine.Vector3>, $smoothTime: number, $maxSpeed: number, $deltaTime: number): UnityEngine.Vector3;
            public Set($newX: number, $newY: number, $newZ: number): void;
            public static Scale($a: UnityEngine.Vector3, $b: UnityEngine.Vector3): UnityEngine.Vector3;
            public static Scale($a: $Ref<UnityEngine.Vector3>, $b: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3;
            public Scale($scale: UnityEngine.Vector3): void;
            public Scale($scale: $Ref<UnityEngine.Vector3>): void;
            public static Cross($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3): UnityEngine.Vector3;
            public static Cross($lhs: $Ref<UnityEngine.Vector3>, $rhs: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3;
            public GetHashCode(): number;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.Vector3): boolean;
            public Equals($other: $Ref<UnityEngine.Vector3>): boolean;
            public static Reflect($inDirection: UnityEngine.Vector3, $inNormal: UnityEngine.Vector3): UnityEngine.Vector3;
            public static Reflect($inDirection: $Ref<UnityEngine.Vector3>, $inNormal: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3;
            public static Normalize($value: UnityEngine.Vector3): UnityEngine.Vector3;
            public static Normalize($value: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3;
            public Normalize(): void;
            public static Dot($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3): number;
            public static Dot($lhs: $Ref<UnityEngine.Vector3>, $rhs: $Ref<UnityEngine.Vector3>): number;
            public static Project($vector: UnityEngine.Vector3, $onNormal: UnityEngine.Vector3): UnityEngine.Vector3;
            public static Project($vector: $Ref<UnityEngine.Vector3>, $onNormal: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3;
            public static ProjectOnPlane($vector: UnityEngine.Vector3, $planeNormal: UnityEngine.Vector3): UnityEngine.Vector3;
            public static ProjectOnPlane($vector: $Ref<UnityEngine.Vector3>, $planeNormal: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3;
            public static Angle($from: UnityEngine.Vector3, $to: UnityEngine.Vector3): number;
            public static Angle($from: $Ref<UnityEngine.Vector3>, $to: $Ref<UnityEngine.Vector3>): number;
            public static SignedAngle($from: UnityEngine.Vector3, $to: UnityEngine.Vector3, $axis: UnityEngine.Vector3): number;
            public static SignedAngle($from: $Ref<UnityEngine.Vector3>, $to: $Ref<UnityEngine.Vector3>, $axis: $Ref<UnityEngine.Vector3>): number;
            public static Distance($a: UnityEngine.Vector3, $b: UnityEngine.Vector3): number;
            public static Distance($a: $Ref<UnityEngine.Vector3>, $b: $Ref<UnityEngine.Vector3>): number;
            public static ClampMagnitude($vector: UnityEngine.Vector3, $maxLength: number): UnityEngine.Vector3;
            public static ClampMagnitude($vector: $Ref<UnityEngine.Vector3>, $maxLength: number): UnityEngine.Vector3;
            public static Magnitude($vector: UnityEngine.Vector3): number;
            public static Magnitude($vector: $Ref<UnityEngine.Vector3>): number;
            public static SqrMagnitude($vector: UnityEngine.Vector3): number;
            public static SqrMagnitude($vector: $Ref<UnityEngine.Vector3>): number;
            public static Min($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3): UnityEngine.Vector3;
            public static Min($lhs: $Ref<UnityEngine.Vector3>, $rhs: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3;
            public static Max($lhs: UnityEngine.Vector3, $rhs: UnityEngine.Vector3): UnityEngine.Vector3;
            public static Max($lhs: $Ref<UnityEngine.Vector3>, $rhs: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
            public static AngleBetween($from: UnityEngine.Vector3, $to: UnityEngine.Vector3): number;
            public static Exclude($excludeThis: UnityEngine.Vector3, $fromThat: UnityEngine.Vector3): UnityEngine.Vector3;
            public get_Item($index: number): number;
            public set_Item($index: number, value: number): void;
        }

        class Quaternion implements System.IEquatable$1<UnityEngine.Quaternion>, System.IFormattable {
            protected [__keep_incompatibility]: never;
            public x: number;
            public y: number;
            public z: number;
            public w: number;
            public static readonly kEpsilon: number;
            public static get identity(): UnityEngine.Quaternion;
            public eulerAngles: UnityEngine.Vector3;
            public get normalized(): UnityEngine.Quaternion;
            constructor($x: number, $y: number, $z: number, $w: number);
            public static FromToRotation($fromDirection: UnityEngine.Vector3, $toDirection: UnityEngine.Vector3): UnityEngine.Quaternion;
            public static FromToRotation($fromDirection: $Ref<UnityEngine.Vector3>, $toDirection: $Ref<UnityEngine.Vector3>): UnityEngine.Quaternion;
            public static Inverse($rotation: UnityEngine.Quaternion): UnityEngine.Quaternion;
            public static Inverse($rotation: $Ref<UnityEngine.Quaternion>): UnityEngine.Quaternion;
            public static Slerp($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number): UnityEngine.Quaternion;
            public static SlerpUnclamped($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number): UnityEngine.Quaternion;
            public static Lerp($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number): UnityEngine.Quaternion;
            public static LerpUnclamped($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion, $t: number): UnityEngine.Quaternion;
            public static Slerp($a: $Ref<UnityEngine.Quaternion>, $b: $Ref<UnityEngine.Quaternion>, $t: number): UnityEngine.Quaternion;
            public static SlerpUnclamped($a: $Ref<UnityEngine.Quaternion>, $b: $Ref<UnityEngine.Quaternion>, $t: number): UnityEngine.Quaternion;
            public static Lerp($a: $Ref<UnityEngine.Quaternion>, $b: $Ref<UnityEngine.Quaternion>, $t: number): UnityEngine.Quaternion;
            public static LerpUnclamped($a: $Ref<UnityEngine.Quaternion>, $b: $Ref<UnityEngine.Quaternion>, $t: number): UnityEngine.Quaternion;
            public static AngleAxis($angle: number, $axis: UnityEngine.Vector3): UnityEngine.Quaternion;
            public static AngleAxis($angle: number, $axis: $Ref<UnityEngine.Vector3>): UnityEngine.Quaternion;
            public static LookRotation($forward: UnityEngine.Vector3, $upwards: UnityEngine.Vector3): UnityEngine.Quaternion;
            public static LookRotation($forward: $Ref<UnityEngine.Vector3>, $upwards: $Ref<UnityEngine.Vector3>): UnityEngine.Quaternion;
            public static LookRotation($forward: UnityEngine.Vector3): UnityEngine.Quaternion;
            public static LookRotation($forward: $Ref<UnityEngine.Vector3>): UnityEngine.Quaternion;
            public Set($newX: number, $newY: number, $newZ: number, $newW: number): void;
            public static Dot($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion): number;
            public static Dot($a: $Ref<UnityEngine.Quaternion>, $b: $Ref<UnityEngine.Quaternion>): number;
            public SetLookRotation($view: UnityEngine.Vector3): void;
            public SetLookRotation($view: $Ref<UnityEngine.Vector3>): void;
            public SetLookRotation($view: UnityEngine.Vector3, $up: UnityEngine.Vector3): void;
            public SetLookRotation($view: $Ref<UnityEngine.Vector3>, $up: $Ref<UnityEngine.Vector3>): void;
            public static Angle($a: UnityEngine.Quaternion, $b: UnityEngine.Quaternion): number;
            public static Angle($a: $Ref<UnityEngine.Quaternion>, $b: $Ref<UnityEngine.Quaternion>): number;
            public static Euler($x: number, $y: number, $z: number): UnityEngine.Quaternion;
            public static Euler($euler: UnityEngine.Vector3): UnityEngine.Quaternion;
            public static Euler($euler: $Ref<UnityEngine.Vector3>): UnityEngine.Quaternion;
            public ToAngleAxis($angle: $Out<number>, $axis: $Out<UnityEngine.Vector3>): void;
            public SetFromToRotation($fromDirection: UnityEngine.Vector3, $toDirection: UnityEngine.Vector3): void;
            public SetFromToRotation($fromDirection: $Ref<UnityEngine.Vector3>, $toDirection: $Ref<UnityEngine.Vector3>): void;
            public static RotateTowards($from: UnityEngine.Quaternion, $to: UnityEngine.Quaternion, $maxDegreesDelta: number): UnityEngine.Quaternion;
            public static RotateTowards($from: $Ref<UnityEngine.Quaternion>, $to: $Ref<UnityEngine.Quaternion>, $maxDegreesDelta: number): UnityEngine.Quaternion;
            public static Normalize($q: UnityEngine.Quaternion): UnityEngine.Quaternion;
            public static Normalize($q: $Ref<UnityEngine.Quaternion>): UnityEngine.Quaternion;
            public Normalize(): void;
            public GetHashCode(): number;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.Quaternion): boolean;
            public Equals($other: $Ref<UnityEngine.Quaternion>): boolean;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
            public static EulerRotation($x: number, $y: number, $z: number): UnityEngine.Quaternion;
            public static EulerRotation($euler: UnityEngine.Vector3): UnityEngine.Quaternion;
            public SetEulerRotation($x: number, $y: number, $z: number): void;
            public SetEulerRotation($euler: UnityEngine.Vector3): void;
            public ToEuler(): UnityEngine.Vector3;
            public static EulerAngles($x: number, $y: number, $z: number): UnityEngine.Quaternion;
            public static EulerAngles($euler: UnityEngine.Vector3): UnityEngine.Quaternion;
            public ToAxisAngle($axis: $Out<UnityEngine.Vector3>, $angle: $Out<number>): void;
            public SetEulerAngles($x: number, $y: number, $z: number): void;
            public SetEulerAngles($euler: UnityEngine.Vector3): void;
            public static ToEulerAngles($rotation: UnityEngine.Quaternion): UnityEngine.Vector3;
            public ToEulerAngles(): UnityEngine.Vector3;
            public SetAxisAngle($axis: UnityEngine.Vector3, $angle: number): void;
            public static AxisAngle($axis: UnityEngine.Vector3, $angle: number): UnityEngine.Quaternion;
            public get_Item($index: number): number;
            public set_Item($index: number, value: number): void;
        }

        class Mathf {
            protected [__keep_incompatibility]: never;
            public static readonly PI: number;
            public static readonly Infinity: number;
            public static readonly NegativeInfinity: number;
            public static readonly Deg2Rad: number;
            public static readonly Rad2Deg: number;
            public static readonly Epsilon: number;
            public static GammaToLinearSpace($value: number): number;
            public static LinearToGammaSpace($value: number): number;
            public static CorrelatedColorTemperatureToRGB($kelvin: number): UnityEngine.Color;
            public static FloatToHalf($val: number): number;
            public static HalfToFloat($val: number): number;
            public static PerlinNoise($x: number, $y: number): number;
            public static PerlinNoise1D($x: number): number;
            public static Sin($f: number): number;
            public static Cos($f: number): number;
            public static Tan($f: number): number;
            public static Asin($f: number): number;
            public static Acos($f: number): number;
            public static Atan($f: number): number;
            public static Atan2($y: number, $x: number): number;
            public static Sqrt($f: number): number;
            public static Abs($f: number): number;
            public static Abs($value: number): number;
            public static Min($a: number, $b: number): number;
            public static Min(...values: number[]): number;
            public static Min($a: number, $b: number): number;
            public static Min(...values: number[]): number;
            public static Max($a: number, $b: number): number;
            public static Max(...values: number[]): number;
            public static Max($a: number, $b: number): number;
            public static Max(...values: number[]): number;
            public static Pow($f: number, $p: number): number;
            public static Exp($power: number): number;
            public static Log($f: number, $p: number): number;
            public static Log($f: number): number;
            public static Log10($f: number): number;
            public static Ceil($f: number): number;
            public static Floor($f: number): number;
            public static Round($f: number): number;
            public static CeilToInt($f: number): number;
            public static FloorToInt($f: number): number;
            public static RoundToInt($f: number): number;
            public static Sign($f: number): number;
            public static Clamp($value: number, $min: number, $max: number): number;
            public static Clamp($value: number, $min: number, $max: number): number;
            public static Clamp01($value: number): number;
            public static Lerp($a: number, $b: number, $t: number): number;
            public static LerpUnclamped($a: number, $b: number, $t: number): number;
            public static LerpAngle($a: number, $b: number, $t: number): number;
            public static MoveTowards($current: number, $target: number, $maxDelta: number): number;
            public static MoveTowardsAngle($current: number, $target: number, $maxDelta: number): number;
            public static SmoothStep($from: number, $to: number, $t: number): number;
            public static Gamma($value: number, $absmax: number, $gamma: number): number;
            public static Approximately($a: number, $b: number): boolean;
            public static SmoothDamp($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number): number;
            public static SmoothDamp($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number): number;
            public static SmoothDamp($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number, $deltaTime: number): number;
            public static SmoothDampAngle($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number): number;
            public static SmoothDampAngle($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number): number;
            public static SmoothDampAngle($current: number, $target: number, $currentVelocity: $Ref<number>, $smoothTime: number, $maxSpeed: number, $deltaTime: number): number;
            public static Repeat($t: number, $length: number): number;
            public static PingPong($t: number, $length: number): number;
            public static InverseLerp($a: number, $b: number, $value: number): number;
            public static DeltaAngle($current: number, $target: number): number;
            public static NextPowerOfTwo($value: number): number;
            public static ClosestPowerOfTwo($value: number): number;
            public static IsPowerOfTwo($value: number): boolean;
        }

        class Vector2 implements System.IEquatable$1<UnityEngine.Vector2>, System.IFormattable {
            protected [__keep_incompatibility]: never;
            public x: number;
            public y: number;
            public static readonly kEpsilon: number;
            public static readonly kEpsilonNormalSqrt: number;
            public get normalized(): UnityEngine.Vector2;
            public get magnitude(): number;
            public get sqrMagnitude(): number;
            public static get zero(): UnityEngine.Vector2;
            public static get one(): UnityEngine.Vector2;
            public static get up(): UnityEngine.Vector2;
            public static get down(): UnityEngine.Vector2;
            public static get left(): UnityEngine.Vector2;
            public static get right(): UnityEngine.Vector2;
            public static get positiveInfinity(): UnityEngine.Vector2;
            public static get negativeInfinity(): UnityEngine.Vector2;
            constructor($x: number, $y: number);
            public Set($newX: number, $newY: number): void;
            public static Lerp($a: UnityEngine.Vector2, $b: UnityEngine.Vector2, $t: number): UnityEngine.Vector2;
            public static Lerp($a: $Ref<UnityEngine.Vector2>, $b: $Ref<UnityEngine.Vector2>, $t: number): UnityEngine.Vector2;
            public static LerpUnclamped($a: UnityEngine.Vector2, $b: UnityEngine.Vector2, $t: number): UnityEngine.Vector2;
            public static LerpUnclamped($a: $Ref<UnityEngine.Vector2>, $b: $Ref<UnityEngine.Vector2>, $t: number): UnityEngine.Vector2;
            public static MoveTowards($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $maxDistanceDelta: number): UnityEngine.Vector2;
            public static MoveTowards($current: $Ref<UnityEngine.Vector2>, $target: $Ref<UnityEngine.Vector2>, $maxDistanceDelta: number): UnityEngine.Vector2;
            public static Scale($a: UnityEngine.Vector2, $b: UnityEngine.Vector2): UnityEngine.Vector2;
            public static Scale($a: $Ref<UnityEngine.Vector2>, $b: $Ref<UnityEngine.Vector2>): UnityEngine.Vector2;
            public Scale($scale: UnityEngine.Vector2): void;
            public Scale($scale: $Ref<UnityEngine.Vector2>): void;
            public static Normalize($value: UnityEngine.Vector2): UnityEngine.Vector2;
            public static Normalize($value: $Ref<UnityEngine.Vector2>): UnityEngine.Vector2;
            public Normalize(): void;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
            public GetHashCode(): number;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.Vector2): boolean;
            public Equals($other: $Ref<UnityEngine.Vector2>): boolean;
            public static Reflect($inDirection: UnityEngine.Vector2, $inNormal: UnityEngine.Vector2): UnityEngine.Vector2;
            public static Reflect($inDirection: $Ref<UnityEngine.Vector2>, $inNormal: $Ref<UnityEngine.Vector2>): UnityEngine.Vector2;
            public static Perpendicular($inDirection: UnityEngine.Vector2): UnityEngine.Vector2;
            public static Perpendicular($inDirection: $Ref<UnityEngine.Vector2>): UnityEngine.Vector2;
            public static Dot($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2): number;
            public static Dot($lhs: $Ref<UnityEngine.Vector2>, $rhs: $Ref<UnityEngine.Vector2>): number;
            public static Angle($from: UnityEngine.Vector2, $to: UnityEngine.Vector2): number;
            public static Angle($from: $Ref<UnityEngine.Vector2>, $to: $Ref<UnityEngine.Vector2>): number;
            public static SignedAngle($from: UnityEngine.Vector2, $to: UnityEngine.Vector2): number;
            public static SignedAngle($from: $Ref<UnityEngine.Vector2>, $to: $Ref<UnityEngine.Vector2>): number;
            public static Distance($a: UnityEngine.Vector2, $b: UnityEngine.Vector2): number;
            public static Distance($a: $Ref<UnityEngine.Vector2>, $b: $Ref<UnityEngine.Vector2>): number;
            public static ClampMagnitude($vector: UnityEngine.Vector2, $maxLength: number): UnityEngine.Vector2;
            public static ClampMagnitude($vector: $Ref<UnityEngine.Vector2>, $maxLength: number): UnityEngine.Vector2;
            public static SqrMagnitude($a: UnityEngine.Vector2): number;
            public static SqrMagnitude($a: $Ref<UnityEngine.Vector2>): number;
            public SqrMagnitude(): number;
            public static Min($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2): UnityEngine.Vector2;
            public static Min($lhs: $Ref<UnityEngine.Vector2>, $rhs: $Ref<UnityEngine.Vector2>): UnityEngine.Vector2;
            public static Max($lhs: UnityEngine.Vector2, $rhs: UnityEngine.Vector2): UnityEngine.Vector2;
            public static Max($lhs: $Ref<UnityEngine.Vector2>, $rhs: $Ref<UnityEngine.Vector2>): UnityEngine.Vector2;
            public static SmoothDamp($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number, $maxSpeed: number): UnityEngine.Vector2;
            public static SmoothDamp($current: $Ref<UnityEngine.Vector2>, $target: $Ref<UnityEngine.Vector2>, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number, $maxSpeed: number): UnityEngine.Vector2;
            public static SmoothDamp($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number): UnityEngine.Vector2;
            public static SmoothDamp($current: $Ref<UnityEngine.Vector2>, $target: $Ref<UnityEngine.Vector2>, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number): UnityEngine.Vector2;
            public static SmoothDamp($current: UnityEngine.Vector2, $target: UnityEngine.Vector2, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number, $maxSpeed: number, $deltaTime: number): UnityEngine.Vector2;
            public static SmoothDamp($current: $Ref<UnityEngine.Vector2>, $target: $Ref<UnityEngine.Vector2>, $currentVelocity: $Ref<UnityEngine.Vector2>, $smoothTime: number, $maxSpeed: number, $deltaTime: number): UnityEngine.Vector2;
            public get_Item($index: number): number;
            public set_Item($index: number, value: number): void;
        }

        class Vector2Int implements System.IEquatable$1<UnityEngine.Vector2Int>, System.IFormattable {
            protected [__keep_incompatibility]: never;
            public x: number;
            public y: number;
            public get magnitude(): number;
            public get sqrMagnitude(): number;
            public static get zero(): UnityEngine.Vector2Int;
            public static get one(): UnityEngine.Vector2Int;
            public static get up(): UnityEngine.Vector2Int;
            public static get down(): UnityEngine.Vector2Int;
            public static get left(): UnityEngine.Vector2Int;
            public static get right(): UnityEngine.Vector2Int;
            constructor($x: number, $y: number);
            public Set($x: number, $y: number): void;
            public static Distance($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int): number;
            public static Distance($a: $Ref<UnityEngine.Vector2Int>, $b: $Ref<UnityEngine.Vector2Int>): number;
            public static Min($lhs: UnityEngine.Vector2Int, $rhs: UnityEngine.Vector2Int): UnityEngine.Vector2Int;
            public static Min($lhs: $Ref<UnityEngine.Vector2Int>, $rhs: $Ref<UnityEngine.Vector2Int>): UnityEngine.Vector2Int;
            public static Max($lhs: UnityEngine.Vector2Int, $rhs: UnityEngine.Vector2Int): UnityEngine.Vector2Int;
            public static Max($lhs: $Ref<UnityEngine.Vector2Int>, $rhs: $Ref<UnityEngine.Vector2Int>): UnityEngine.Vector2Int;
            public static Scale($a: UnityEngine.Vector2Int, $b: UnityEngine.Vector2Int): UnityEngine.Vector2Int;
            public static Scale($a: $Ref<UnityEngine.Vector2Int>, $b: $Ref<UnityEngine.Vector2Int>): UnityEngine.Vector2Int;
            public Scale($scale: UnityEngine.Vector2Int): void;
            public Scale($scale: $Ref<UnityEngine.Vector2Int>): void;
            public Clamp($min: UnityEngine.Vector2Int, $max: UnityEngine.Vector2Int): void;
            public Clamp($min: $Ref<UnityEngine.Vector2Int>, $max: $Ref<UnityEngine.Vector2Int>): void;
            public static FloorToInt($v: UnityEngine.Vector2): UnityEngine.Vector2Int;
            public static FloorToInt($v: $Ref<UnityEngine.Vector2>): UnityEngine.Vector2Int;
            public static CeilToInt($v: UnityEngine.Vector2): UnityEngine.Vector2Int;
            public static CeilToInt($v: $Ref<UnityEngine.Vector2>): UnityEngine.Vector2Int;
            public static RoundToInt($v: UnityEngine.Vector2): UnityEngine.Vector2Int;
            public static RoundToInt($v: $Ref<UnityEngine.Vector2>): UnityEngine.Vector2Int;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.Vector2Int): boolean;
            public Equals($other: $Ref<UnityEngine.Vector2Int>): boolean;
            public GetHashCode(): number;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
            public get_Item($index: number): number;
            public set_Item($index: number, value: number): void;
        }

        class Vector3Int implements System.IEquatable$1<UnityEngine.Vector3Int>, System.IFormattable {
            protected [__keep_incompatibility]: never;
            public x: number;
            public y: number;
            public z: number;
            public get magnitude(): number;
            public get sqrMagnitude(): number;
            public static get zero(): UnityEngine.Vector3Int;
            public static get one(): UnityEngine.Vector3Int;
            public static get up(): UnityEngine.Vector3Int;
            public static get down(): UnityEngine.Vector3Int;
            public static get left(): UnityEngine.Vector3Int;
            public static get right(): UnityEngine.Vector3Int;
            public static get forward(): UnityEngine.Vector3Int;
            public static get back(): UnityEngine.Vector3Int;
            constructor($x: number, $y: number);
            constructor($x: number, $y: number, $z: number);
            public Set($x: number, $y: number, $z: number): void;
            public static Distance($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int): number;
            public static Distance($a: $Ref<UnityEngine.Vector3Int>, $b: $Ref<UnityEngine.Vector3Int>): number;
            public static Min($lhs: UnityEngine.Vector3Int, $rhs: UnityEngine.Vector3Int): UnityEngine.Vector3Int;
            public static Min($lhs: $Ref<UnityEngine.Vector3Int>, $rhs: $Ref<UnityEngine.Vector3Int>): UnityEngine.Vector3Int;
            public static Max($lhs: UnityEngine.Vector3Int, $rhs: UnityEngine.Vector3Int): UnityEngine.Vector3Int;
            public static Max($lhs: $Ref<UnityEngine.Vector3Int>, $rhs: $Ref<UnityEngine.Vector3Int>): UnityEngine.Vector3Int;
            public static Scale($a: UnityEngine.Vector3Int, $b: UnityEngine.Vector3Int): UnityEngine.Vector3Int;
            public static Scale($a: $Ref<UnityEngine.Vector3Int>, $b: $Ref<UnityEngine.Vector3Int>): UnityEngine.Vector3Int;
            public Scale($scale: UnityEngine.Vector3Int): void;
            public Scale($scale: $Ref<UnityEngine.Vector3Int>): void;
            public Clamp($min: UnityEngine.Vector3Int, $max: UnityEngine.Vector3Int): void;
            public Clamp($min: $Ref<UnityEngine.Vector3Int>, $max: $Ref<UnityEngine.Vector3Int>): void;
            public static FloorToInt($v: UnityEngine.Vector3): UnityEngine.Vector3Int;
            public static FloorToInt($v: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3Int;
            public static CeilToInt($v: UnityEngine.Vector3): UnityEngine.Vector3Int;
            public static CeilToInt($v: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3Int;
            public static RoundToInt($v: UnityEngine.Vector3): UnityEngine.Vector3Int;
            public static RoundToInt($v: $Ref<UnityEngine.Vector3>): UnityEngine.Vector3Int;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.Vector3Int): boolean;
            public Equals($other: $Ref<UnityEngine.Vector3Int>): boolean;
            public GetHashCode(): number;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
            public get_Item($index: number): number;
            public set_Item($index: number, value: number): void;
        }

        class Vector4 implements System.IEquatable$1<UnityEngine.Vector4>, System.IFormattable {
            protected [__keep_incompatibility]: never;
            public static readonly kEpsilon: number;
            public x: number;
            public y: number;
            public z: number;
            public w: number;
            public get normalized(): UnityEngine.Vector4;
            public get magnitude(): number;
            public get sqrMagnitude(): number;
            public static get zero(): UnityEngine.Vector4;
            public static get one(): UnityEngine.Vector4;
            public static get positiveInfinity(): UnityEngine.Vector4;
            public static get negativeInfinity(): UnityEngine.Vector4;
            constructor($x: number, $y: number, $z: number, $w: number);
            constructor($x: number, $y: number, $z: number);
            constructor($x: number, $y: number);
            public Set($newX: number, $newY: number, $newZ: number, $newW: number): void;
            public static Lerp($a: UnityEngine.Vector4, $b: UnityEngine.Vector4, $t: number): UnityEngine.Vector4;
            public static Lerp($a: $Ref<UnityEngine.Vector4>, $b: $Ref<UnityEngine.Vector4>, $t: number): UnityEngine.Vector4;
            public static LerpUnclamped($a: UnityEngine.Vector4, $b: UnityEngine.Vector4, $t: number): UnityEngine.Vector4;
            public static LerpUnclamped($a: $Ref<UnityEngine.Vector4>, $b: $Ref<UnityEngine.Vector4>, $t: number): UnityEngine.Vector4;
            public static MoveTowards($current: UnityEngine.Vector4, $target: UnityEngine.Vector4, $maxDistanceDelta: number): UnityEngine.Vector4;
            public static MoveTowards($current: $Ref<UnityEngine.Vector4>, $target: $Ref<UnityEngine.Vector4>, $maxDistanceDelta: number): UnityEngine.Vector4;
            public static Scale($a: UnityEngine.Vector4, $b: UnityEngine.Vector4): UnityEngine.Vector4;
            public static Scale($a: $Ref<UnityEngine.Vector4>, $b: $Ref<UnityEngine.Vector4>): UnityEngine.Vector4;
            public Scale($scale: UnityEngine.Vector4): void;
            public Scale($scale: $Ref<UnityEngine.Vector4>): void;
            public GetHashCode(): number;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.Vector4): boolean;
            public Equals($other: $Ref<UnityEngine.Vector4>): boolean;
            public static Normalize($a: UnityEngine.Vector4): UnityEngine.Vector4;
            public static Normalize($a: $Ref<UnityEngine.Vector4>): UnityEngine.Vector4;
            public Normalize(): void;
            public static Dot($a: UnityEngine.Vector4, $b: UnityEngine.Vector4): number;
            public static Dot($a: $Ref<UnityEngine.Vector4>, $b: $Ref<UnityEngine.Vector4>): number;
            public static Project($a: UnityEngine.Vector4, $b: UnityEngine.Vector4): UnityEngine.Vector4;
            public static Project($a: $Ref<UnityEngine.Vector4>, $b: $Ref<UnityEngine.Vector4>): UnityEngine.Vector4;
            public static Distance($a: UnityEngine.Vector4, $b: UnityEngine.Vector4): number;
            public static Distance($a: $Ref<UnityEngine.Vector4>, $b: $Ref<UnityEngine.Vector4>): number;
            public static Magnitude($a: UnityEngine.Vector4): number;
            public static Magnitude($a: $Ref<UnityEngine.Vector4>): number;
            public static Min($lhs: UnityEngine.Vector4, $rhs: UnityEngine.Vector4): UnityEngine.Vector4;
            public static Min($lhs: $Ref<UnityEngine.Vector4>, $rhs: $Ref<UnityEngine.Vector4>): UnityEngine.Vector4;
            public static Max($lhs: UnityEngine.Vector4, $rhs: UnityEngine.Vector4): UnityEngine.Vector4;
            public static Max($lhs: $Ref<UnityEngine.Vector4>, $rhs: $Ref<UnityEngine.Vector4>): UnityEngine.Vector4;
            public ToString(): string;
            public ToString($format: string): string;
            public ToString($format: string, $formatProvider: System.IFormatProvider): string;
            public static SqrMagnitude($a: UnityEngine.Vector4): number;
            public static SqrMagnitude($a: $Ref<UnityEngine.Vector4>): number;
            public SqrMagnitude(): number;
            public get_Item($index: number): number;
            public set_Item($index: number, value: number): void;
        }

        class Ping {
            protected [__keep_incompatibility]: never;
            public get isDone(): boolean;
            public get time(): number;
            public get ip(): string;
            constructor($address: string);
            public DestroyPing(): void;
        }

        class PlayerPrefsException extends System.Exception {
            protected [__keep_incompatibility]: never;
            constructor($error: string);
        }

        class PlayerPrefs {
            protected [__keep_incompatibility]: never;
            constructor();
            public static SetInt($key: string, $value: number): void;
            public static GetInt($key: string, $defaultValue: number): number;
            public static GetInt($key: string): number;
            public static SetFloat($key: string, $value: number): void;
            public static GetFloat($key: string, $defaultValue: number): number;
            public static GetFloat($key: string): number;
            public static SetString($key: string, $value: string): void;
            public static GetString($key: string, $defaultValue: string): string;
            public static GetString($key: string): string;
            public static HasKey($key: string): boolean;
            public static DeleteKey($key: string): void;
            public static DeleteAll(): void;
            public static Save(): void;
        }

        class PropertyAttribute extends System.Attribute {
            protected [__keep_incompatibility]: never;
            public order: number;
            public get applyToCollection(): boolean;
        }

        class PropertyCollectionAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
        }

        class ContextMenuItemAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            public readonly name: string;
            public readonly function: string;
            constructor($name: string, $function: string);
        }

        class InspectorNameAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            public readonly displayName: string;
            constructor($displayName: string);
        }

        class TooltipAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            public readonly tooltip: string;
            constructor($tooltip: string);
        }

        class SpaceAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            public readonly height: number;
            constructor();
            constructor($height: number);
        }

        class HeaderAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            public readonly header: string;
            constructor($header: string);
        }

        class RangeAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            public readonly min: number;
            public readonly max: number;
            constructor($min: number, $max: number);
        }

        class MinAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            public readonly min: number;
            constructor($min: number);
        }

        class MultilineAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            public readonly lines: number;
            constructor();
            constructor($lines: number);
        }

        class TextAreaAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            public readonly minLines: number;
            public readonly maxLines: number;
            constructor();
            constructor($minLines: number, $maxLines: number);
        }

        class ColorUsageAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            public readonly showAlpha: boolean;
            public readonly hdr: boolean;
            public readonly minBrightness: number;
            public readonly maxBrightness: number;
            public readonly minExposureValue: number;
            public readonly maxExposureValue: number;
            constructor($showAlpha: boolean);
            constructor($showAlpha: boolean, $hdr: boolean);
            constructor($showAlpha: boolean, $hdr: boolean, $minBrightness: number, $maxBrightness: number, $minExposureValue: number, $maxExposureValue: number);
        }

        class GradientUsageAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            public readonly hdr: boolean;
            public readonly colorSpace: UnityEngine.ColorSpace;
            constructor($hdr: boolean);
            constructor($hdr: boolean, $colorSpace: UnityEngine.ColorSpace);
        }

        class DelayedAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class NonReorderableAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class EnumButtonsAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            public includeObsolete: boolean;
            constructor($includeObsolete?: boolean);
        }

        class PropertyName implements System.IEquatable$1<UnityEngine.PropertyName> {
            protected [__keep_incompatibility]: never;
            constructor($name: string);
            constructor($other: UnityEngine.PropertyName);
            constructor($id: number);
            public static IsNullOrEmpty($prop: UnityEngine.PropertyName): boolean;
            public GetHashCode(): number;
            public Equals($other: any): boolean;
            public Equals($other: UnityEngine.PropertyName): boolean;
            public ToString(): string;
        }

        class Random {
            protected [__keep_incompatibility]: never;
            public static state: UnityEngine.Random.State;
            public static get value(): number;
            public static get insideUnitSphere(): UnityEngine.Vector3;
            public static get insideUnitCircle(): UnityEngine.Vector2;
            public static get onUnitSphere(): UnityEngine.Vector3;
            public static get rotation(): UnityEngine.Quaternion;
            public static get rotationUniform(): UnityEngine.Quaternion;
            public static seed: number;
            public static InitState($seed: number): void;
            public static Range($minInclusive: number, $maxInclusive: number): number;
            public static Range($minInclusive: number, $maxExclusive: number): number;
            public static RandomRange($min: number, $max: number): number;
            public static RandomRange($min: number, $max: number): number;
            public static ColorHSV(): UnityEngine.Color;
            public static ColorHSV($hueMin: number, $hueMax: number): UnityEngine.Color;
            public static ColorHSV($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number): UnityEngine.Color;
            public static ColorHSV($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number, $valueMin: number, $valueMax: number): UnityEngine.Color;
            public static ColorHSV($hueMin: number, $hueMax: number, $saturationMin: number, $saturationMax: number, $valueMin: number, $valueMax: number, $alphaMin: number, $alphaMax: number): UnityEngine.Color;
        }
        namespace Random {
            class State {
                protected [__keep_incompatibility]: never;
            }

        }

        class RenderingLayerMask {
            protected [__keep_incompatibility]: never;
            public static get defaultRenderingLayerMask(): UnityEngine.RenderingLayerMask;
            public value: number;
            public static RenderingLayerToName($layer: number): string;
            public static NameToRenderingLayer($layerName: string): number;
            public static GetMask(...renderingLayerNames: string[]): number;
            public static GetMask($renderingLayerNames: System.ReadOnlySpan$1<string>): number;
            public static GetDefinedRenderingLayerCount(): number;
            public static GetLastDefinedRenderingLayerIndex(): number;
            public static GetDefinedRenderingLayersCombinedMaskValue(): number;
            public static GetDefinedRenderingLayerNames(): System.Array$1<string>;
            public static GetDefinedRenderingLayerValues(): System.Array$1<number>;
            public static GetRenderingLayerCount(): number;
        }

        class IconAttribute extends System.Attribute {
            protected [__keep_incompatibility]: never;
            public get path(): string;
            constructor($path: string);
        }

        class ResourceRequest extends UnityEngine.AsyncOperation {
            protected [__keep_incompatibility]: never;
            public get asset(): UnityEngine.Object;
            constructor();
        }

        class ResourcesAPI {
            protected [__keep_incompatibility]: never;
            public static overrideAPI: UnityEngine.ResourcesAPI;
        }

        class Resources {
            protected [__keep_incompatibility]: never;
            constructor();
            public static FindObjectsOfTypeAll($type: System.Type): System.Array$1<UnityEngine.Object>;
            public static FindObjectsOfTypeAll<T extends UnityEngine.Object>(): System.Array$1<T>;
            public static Load($path: string): UnityEngine.Object;
            public static Load<T extends UnityEngine.Object>($path: string): T;
            public static Load($path: string, $systemTypeInstance: System.Type): UnityEngine.Object;
            public static LoadAsync($path: string): UnityEngine.ResourceRequest;
            public static LoadAsync<T extends UnityEngine.Object>($path: string): UnityEngine.ResourceRequest;
            public static LoadAsync($path: string, $type: System.Type): UnityEngine.ResourceRequest;
            public static LoadAll($path: string, $systemTypeInstance: System.Type): System.Array$1<UnityEngine.Object>;
            public static LoadAll($path: string): System.Array$1<UnityEngine.Object>;
            public static LoadAll<T extends UnityEngine.Object>($path: string): System.Array$1<T>;
            public static GetBuiltinResource($type: System.Type, $path: string): UnityEngine.Object;
            public static GetBuiltinResource<T extends UnityEngine.Object>($path: string): T;
            public static UnloadAsset($assetToUnload: UnityEngine.Object): void;
            public static UnloadUnusedAssets(): UnityEngine.AsyncOperation;
            public static EntityIdToObject($entityId: UnityEngine.EntityId): UnityEngine.Object;
            public static InstanceIDToObject($instanceID: number): UnityEngine.Object;
            public static EntityIdsToObjectList($entityIds: Unity.Collections.NativeArray$1<UnityEngine.EntityId>, $objects: System.Collections.Generic.List$1<UnityEngine.Object>): void;
            public static InstanceIDToObjectList($instanceIDs: Unity.Collections.NativeArray$1<number>, $objects: System.Collections.Generic.List$1<UnityEngine.Object>): void;
            public static EntityIdIsValid($entityId: UnityEngine.EntityId): boolean;
            public static InstanceIDIsValid($instanceId: number): boolean;
            public static InstanceIDsToValidArray($instanceIDs: Unity.Collections.NativeArray$1<number>, $validArray: Unity.Collections.NativeArray$1<boolean>): void;
            public static EntityIdsToValidArray($entityIDs: Unity.Collections.NativeArray$1<UnityEngine.EntityId>, $validArray: Unity.Collections.NativeArray$1<boolean>): void;
            public static InstanceIDsToValidArray($instanceIDs: System.ReadOnlySpan$1<number>, $validArray: System.Span$1<boolean>): void;
            public static EntityIdsToValidArray($entityIds: System.ReadOnlySpan$1<UnityEngine.EntityId>, $validArray: System.Span$1<boolean>): void;
        }

        class AsyncInstantiateOperation extends UnityEngine.AsyncOperation {
            protected [__keep_incompatibility]: never;
            public get Result(): System.Array$1<UnityEngine.Object>;
            constructor();
            public IsWaitingForSceneActivation(): boolean;
            public WaitForCompletion(): void;
            public Cancel(): void;
            public static GetIntegrationTimeMS(): number;
            public static SetIntegrationTimeMS($integrationTimeMS: number): void;
        }

        class AsyncInstantiateOperation<T> extends UnityEngine.AsyncInstantiateOperation {
            protected [__keep_incompatibility]: never;
            public get Result(): System.Array$1<T>;
            public GetAwaiter(): UnityEngine.AsyncInstantiateOperation$1.Awaiter$1<T>;
        }
        namespace AsyncInstantiateOperation {
            class Awaiter<T> implements System.Runtime.CompilerServices.INotifyCompletion {
                protected [__keep_incompatibility]: never;
                public get IsCompleted(): boolean;
                constructor($op: UnityEngine.AsyncInstantiateOperation$1<T>);
                public OnCompleted($continuation: System.Action): void;
                public GetResult(): System.Array$1<T>;
            }

        }

        class AsyncOperation extends UnityEngine.YieldInstruction {
            protected [__keep_incompatibility]: never;
            public get isDone(): boolean;
            public get progress(): number;
            public priority: number;
            public allowSceneActivation: boolean;
            constructor();
            public add_completed(handler: System.Action$1<UnityEngine.AsyncOperation>): void;
            public remove_completed(handler: System.Action$1<UnityEngine.AsyncOperation>): void;
        }

        class DisallowMultipleComponent extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class RequireComponent extends System.Attribute {
            protected [__keep_incompatibility]: never;
            public m_Type0: System.Type;
            public m_Type1: System.Type;
            public m_Type2: System.Type;
            constructor($requiredComponent: System.Type);
            constructor($requiredComponent: System.Type, $requiredComponent2: System.Type);
            constructor($requiredComponent: System.Type, $requiredComponent2: System.Type, $requiredComponent3: System.Type);
        }

        class AddComponentMenu extends System.Attribute {
            protected [__keep_incompatibility]: never;
            public get componentMenu(): string;
            public get componentOrder(): number;
            constructor($menuName: string);
            constructor($menuName: string, $order: number);
        }

        class CreateAssetMenuAttribute extends System.Attribute {
            protected [__keep_incompatibility]: never;
            public menuName: string;
            public fileName: string;
            public order: number;
            constructor();
        }

        class ContextMenu extends System.Attribute {
            protected [__keep_incompatibility]: never;
            public readonly menuItem: string;
            public readonly validate: boolean;
            public readonly priority: number;
            constructor($itemName: string);
            constructor($itemName: string, $isValidateFunction: boolean);
            constructor($itemName: string, $isValidateFunction: boolean, $priority: number);
        }

        class ExecuteInEditMode extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class ExecuteAlways extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class HideInInspector extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class HideInCallstackAttribute extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class HelpURLAttribute extends System.Attribute {
            protected [__keep_incompatibility]: never;
            public get URL(): string;
            constructor($url: string);
        }

        class DefaultExecutionOrder extends System.Attribute {
            protected [__keep_incompatibility]: never;
            public get order(): number;
            constructor($order: number);
        }

        class AssemblyIsEditorAssembly extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class ExcludeFromPresetAttribute extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class Awaitable implements System.Collections.IEnumerator {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public static FromAsyncOperation($op: UnityEngine.AsyncOperation, $cancellationToken?: System.Threading.CancellationToken): UnityEngine.Awaitable;
            public GetAwaiter(): UnityEngine.Awaitable.Awaiter;
            public Cancel(): void;
            public static NextFrameAsync($cancellationToken?: System.Threading.CancellationToken): UnityEngine.Awaitable;
            public static WaitForSecondsAsync($seconds: number, $cancellationToken?: System.Threading.CancellationToken): UnityEngine.Awaitable;
            public static FixedUpdateAsync($cancellationToken?: System.Threading.CancellationToken): UnityEngine.Awaitable;
            public static EndOfFrameAsync($cancellationToken?: System.Threading.CancellationToken): UnityEngine.Awaitable;
            public static MainThreadAsync(): UnityEngine.MainThreadAwaitable;
            public static BackgroundThreadAsync(): UnityEngine.BackgroundThreadAwaitable;
        }
        namespace Awaitable {
            class AwaitableAsyncMethodBuilder {
                protected [__keep_incompatibility]: never;
                public get Task(): UnityEngine.Awaitable;
                public static Create(): UnityEngine.Awaitable.AwaitableAsyncMethodBuilder;
                public Start<TStateMachine extends System.Runtime.CompilerServices.IAsyncStateMachine>($stateMachine: $Ref<TStateMachine>): void;
                public SetStateMachine($stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine): void;
                public AwaitOnCompleted<TAwaiter extends System.Runtime.CompilerServices.INotifyCompletion, TStateMachine extends System.Runtime.CompilerServices.IAsyncStateMachine>($awaiter: $Ref<TAwaiter>, $stateMachine: $Ref<TStateMachine>): void;
                public AwaitUnsafeOnCompleted<TAwaiter extends System.Runtime.CompilerServices.ICriticalNotifyCompletion, TStateMachine extends System.Runtime.CompilerServices.IAsyncStateMachine>($awaiter: $Ref<TAwaiter>, $stateMachine: $Ref<TStateMachine>): void;
                public SetException($e: System.Exception): void;
                public SetResult(): void;
            }

            class AwaitableAsyncMethodBuilder<T> {
                protected [__keep_incompatibility]: never;
                public get Task(): UnityEngine.Awaitable$1<T>;
                public static Create(): UnityEngine.Awaitable.AwaitableAsyncMethodBuilder$1<T>;
                public SetResult($value: T): void;
                public SetException($e: System.Exception): void;
                public Start<TStateMachine extends System.Runtime.CompilerServices.IAsyncStateMachine>($stateMachine: $Ref<TStateMachine>): void;
                public SetStateMachine($stateMachine: System.Runtime.CompilerServices.IAsyncStateMachine): void;
                public AwaitOnCompleted<TAwaiter extends System.Runtime.CompilerServices.INotifyCompletion, TStateMachine extends System.Runtime.CompilerServices.IAsyncStateMachine>($awaiter: $Ref<TAwaiter>, $stateMachine: $Ref<TStateMachine>): void;
                public AwaitUnsafeOnCompleted<TAwaiter extends System.Runtime.CompilerServices.ICriticalNotifyCompletion, TStateMachine extends System.Runtime.CompilerServices.IAsyncStateMachine>($awaiter: $Ref<TAwaiter>, $stateMachine: $Ref<TStateMachine>): void;
            }

            class Awaiter implements System.Runtime.CompilerServices.INotifyCompletion {
                protected [__keep_incompatibility]: never;
                public get IsCompleted(): boolean;
                public OnCompleted($continuation: System.Action): void;
                public GetResult(): void;
            }

        }

        class AsyncOperationAwaitableExtensions {
            protected [__keep_incompatibility]: never;
            public static GetAwaiter(): UnityEngine.Awaitable.Awaiter;
        }

        class MainThreadAwaitable implements System.Runtime.CompilerServices.INotifyCompletion {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public GetAwaiter(): UnityEngine.MainThreadAwaitable;
            public GetResult(): void;
            public OnCompleted($continuation: System.Action): void;
        }

        class BackgroundThreadAwaitable implements System.Runtime.CompilerServices.INotifyCompletion {
            protected [__keep_incompatibility]: never;
            public get IsCompleted(): boolean;
            public GetAwaiter(): UnityEngine.BackgroundThreadAwaitable;
            public GetResult(): void;
            public OnCompleted($continuation: System.Action): void;
        }

        class UnityEventAwaitableExtensions {
            protected [__keep_incompatibility]: never;
            public static GetAwaiter(): UnityEngine.Awaitable.Awaiter;
            public static GetAwaiter<T>(): UnityEngine.Awaitable$1.Awaiter$1<T>;
            public static GetAwaiter<T0, T1>(): UnityEngine.Awaitable$1.Awaiter$1<System.ValueTuple$2<T0, T1>>;
            public static GetAwaiter<T0, T1, T2>(): UnityEngine.Awaitable$1.Awaiter$1<System.ValueTuple$3<T0, T1, T2>>;
            public static GetAwaiter<T0, T1, T2, T3>(): UnityEngine.Awaitable$1.Awaiter$1<System.ValueTuple$4<T0, T1, T2, T3>>;
        }

        class AwaitableCompletionSource {
            protected [__keep_incompatibility]: never;
            public get Awaitable(): UnityEngine.Awaitable;
            constructor();
            public SetResult(): void;
            public SetCanceled(): void;
            public SetException($exception: System.Exception): void;
            public TrySetResult(): boolean;
            public TrySetCanceled(): boolean;
            public TrySetException($exception: System.Exception): boolean;
            public Reset(): void;
        }

        class AwaitableCompletionSource<T> {
            protected [__keep_incompatibility]: never;
            public get Awaitable(): UnityEngine.Awaitable$1<T>;
            constructor();
            public SetResult($value: $Ref<T>): void;
            public SetCanceled(): void;
            public SetException($exception: System.Exception): void;
            public TrySetResult($value: $Ref<T>): boolean;
            public TrySetCanceled(): boolean;
            public TrySetException($exception: System.Exception): boolean;
            public Reset(): void;
        }

        class Awaitable<T> {
            protected [__keep_incompatibility]: never;
            public Cancel(): void;
            public GetAwaiter(): UnityEngine.Awaitable$1.Awaiter$1<T>;
        }
        namespace Awaitable {
            class Awaiter<T> implements System.Runtime.CompilerServices.INotifyCompletion {
                protected [__keep_incompatibility]: never;
                public get IsCompleted(): boolean;
                constructor($coroutine: UnityEngine.Awaitable$1<T>);
                public OnCompleted($continuation: System.Action): void;
                public GetResult(): T;
            }

        }

        class Behaviour extends UnityEngine.Component {
            protected [__keep_incompatibility]: never;
            public enabled: boolean;
            public get isActiveAndEnabled(): boolean;
            constructor();
        }

        class Component extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public get transform(): UnityEngine.Transform;
            public get transformHandle(): UnityEngine.TransformHandle;
            public get gameObject(): UnityEngine.GameObject;
            public tag: string;
            constructor();
            public GetComponent($type: System.Type): UnityEngine.Component;
            public GetComponent<T>(): T;
            public TryGetComponent($type: System.Type, $component: $Out<UnityEngine.Component>): boolean;
            public TryGetComponent<T>($component: $Out<T>): boolean;
            public GetComponent($type: string): UnityEngine.Component;
            public GetComponentInChildren($t: System.Type, $includeInactive: boolean): UnityEngine.Component;
            public GetComponentInChildren($t: System.Type): UnityEngine.Component;
            public GetComponentInChildren<T>($includeInactive: boolean): T;
            public GetComponentInChildren<T>(): T;
            public GetComponentsInChildren($t: System.Type, $includeInactive: boolean): System.Array$1<UnityEngine.Component>;
            public GetComponentsInChildren($t: System.Type): System.Array$1<UnityEngine.Component>;
            public GetComponentsInChildren<T>($includeInactive: boolean): System.Array$1<T>;
            public GetComponentsInChildren<T>($includeInactive: boolean, $result: System.Collections.Generic.List$1<T>): void;
            public GetComponentsInChildren<T>(): System.Array$1<T>;
            public GetComponentsInChildren<T>($results: System.Collections.Generic.List$1<T>): void;
            public GetComponentInParent($t: System.Type, $includeInactive: boolean): UnityEngine.Component;
            public GetComponentInParent($t: System.Type): UnityEngine.Component;
            public GetComponentInParent<T>($includeInactive: boolean): T;
            public GetComponentInParent<T>(): T;
            public GetComponentsInParent($t: System.Type, $includeInactive: boolean): System.Array$1<UnityEngine.Component>;
            public GetComponentsInParent($t: System.Type): System.Array$1<UnityEngine.Component>;
            public GetComponentsInParent<T>($includeInactive: boolean): System.Array$1<T>;
            public GetComponentsInParent<T>($includeInactive: boolean, $results: System.Collections.Generic.List$1<T>): void;
            public GetComponentsInParent<T>(): System.Array$1<T>;
            public GetComponents($type: System.Type): System.Array$1<UnityEngine.Component>;
            public GetComponents($type: System.Type, $results: System.Collections.Generic.List$1<UnityEngine.Component>): void;
            public GetComponents<T>($results: System.Collections.Generic.List$1<T>): void;
            public GetComponents<T>(): System.Array$1<T>;
            public GetComponentIndex(): number;
            public CompareTag($tag: string): boolean;
            public CompareTag($tag: UnityEngine.TagHandle): boolean;
            public SendMessageUpwards($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions): void;
            public SendMessageUpwards($methodName: string, $value: any): void;
            public SendMessageUpwards($methodName: string): void;
            public SendMessageUpwards($methodName: string, $options: UnityEngine.SendMessageOptions): void;
            public SendMessage($methodName: string, $value: any): void;
            public SendMessage($methodName: string): void;
            public SendMessage($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions): void;
            public SendMessage($methodName: string, $options: UnityEngine.SendMessageOptions): void;
            public BroadcastMessage($methodName: string, $parameter: any, $options: UnityEngine.SendMessageOptions): void;
            public BroadcastMessage($methodName: string, $parameter: any): void;
            public BroadcastMessage($methodName: string): void;
            public BroadcastMessage($methodName: string, $options: UnityEngine.SendMessageOptions): void;
        }

        class Coroutine extends UnityEngine.YieldInstruction {
            protected [__keep_incompatibility]: never;
        }

        class CustomYieldInstruction implements System.Collections.IEnumerator {
            protected [__keep_incompatibility]: never;
            public get keepWaiting(): boolean;
            public get Current(): any;
            public MoveNext(): boolean;
            public Reset(): void;
        }

        class ExcludeFromObjectFactoryAttribute extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class GameObject extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public get transform(): UnityEngine.Transform;
            public get transformHandle(): UnityEngine.TransformHandle;
            public layer: number;
            public active: boolean;
            public get activeSelf(): boolean;
            public get activeInHierarchy(): boolean;
            public isStatic: boolean;
            public tag: string;
            public get scene(): UnityEngine.SceneManagement.Scene;
            public get sceneCullingMask(): bigint;
            public get gameObject(): UnityEngine.GameObject;
            constructor($name: string);
            constructor();
            constructor($name: string, ...components: System.Type[]);
            public static CreatePrimitive($type: UnityEngine.PrimitiveType): UnityEngine.GameObject;
            public GetComponent<T>(): T;
            public GetComponent($type: System.Type): UnityEngine.Component;
            public GetComponent($type: string): UnityEngine.Component;
            public GetComponentInChildren($type: System.Type, $includeInactive: boolean): UnityEngine.Component;
            public GetComponentInChildren($type: System.Type): UnityEngine.Component;
            public GetComponentInChildren<T>(): T;
            public GetComponentInChildren<T>($includeInactive: boolean): T;
            public GetComponentInParent($type: System.Type, $includeInactive: boolean): UnityEngine.Component;
            public GetComponentInParent($type: System.Type): UnityEngine.Component;
            public GetComponentInParent<T>(): T;
            public GetComponentInParent<T>($includeInactive: boolean): T;
            public GetComponents($type: System.Type): System.Array$1<UnityEngine.Component>;
            public GetComponents<T>(): System.Array$1<T>;
            public GetComponents($type: System.Type, $results: System.Collections.Generic.List$1<UnityEngine.Component>): void;
            public GetComponents<T>($results: System.Collections.Generic.List$1<T>): void;
            public GetComponentsInChildren($type: System.Type): System.Array$1<UnityEngine.Component>;
            public GetComponentsInChildren($type: System.Type, $includeInactive: boolean): System.Array$1<UnityEngine.Component>;
            public GetComponentsInChildren<T>($includeInactive: boolean): System.Array$1<T>;
            public GetComponentsInChildren<T>($includeInactive: boolean, $results: System.Collections.Generic.List$1<T>): void;
            public GetComponentsInChildren<T>(): System.Array$1<T>;
            public GetComponentsInChildren<T>($results: System.Collections.Generic.List$1<T>): void;
            public GetComponentsInParent($type: System.Type): System.Array$1<UnityEngine.Component>;
            public GetComponentsInParent($type: System.Type, $includeInactive: boolean): System.Array$1<UnityEngine.Component>;
            public GetComponentsInParent<T>($includeInactive: boolean, $results: System.Collections.Generic.List$1<T>): void;
            public GetComponentsInParent<T>($includeInactive: boolean): System.Array$1<T>;
            public GetComponentsInParent<T>(): System.Array$1<T>;
            public TryGetComponent<T>($component: $Out<T>): boolean;
            public TryGetComponent($type: System.Type, $component: $Out<UnityEngine.Component>): boolean;
            public static FindWithTag($tag: string): UnityEngine.GameObject;
            public static FindGameObjectsWithTag($tag: string, $results: System.Collections.Generic.List$1<UnityEngine.GameObject>): void;
            public SendMessageUpwards($methodName: string, $options: UnityEngine.SendMessageOptions): void;
            public SendMessage($methodName: string, $options: UnityEngine.SendMessageOptions): void;
            public BroadcastMessage($methodName: string, $options: UnityEngine.SendMessageOptions): void;
            public AddComponent($componentType: System.Type): UnityEngine.Component;
            public AddComponent<T extends UnityEngine.Component>(): T;
            public GetComponentCount(): number;
            public GetComponentAtIndex($index: number): UnityEngine.Component;
            public GetComponentAtIndex<T extends UnityEngine.Component>($index: number): T;
            public GetComponentIndex($component: UnityEngine.Component): number;
            public SetActive($value: boolean): void;
            public SetActiveRecursively($state: boolean): void;
            public CompareTag($tag: string): boolean;
            public CompareTag($tag: UnityEngine.TagHandle): boolean;
            public static FindGameObjectWithTag($tag: string): UnityEngine.GameObject;
            public static FindGameObjectsWithTag($tag: string): System.Array$1<UnityEngine.GameObject>;
            public SendMessageUpwards($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions): void;
            public SendMessageUpwards($methodName: string, $value: any): void;
            public SendMessageUpwards($methodName: string): void;
            public SendMessage($methodName: string, $value: any, $options: UnityEngine.SendMessageOptions): void;
            public SendMessage($methodName: string, $value: any): void;
            public SendMessage($methodName: string): void;
            public BroadcastMessage($methodName: string, $parameter: any, $options: UnityEngine.SendMessageOptions): void;
            public BroadcastMessage($methodName: string, $parameter: any): void;
            public BroadcastMessage($methodName: string): void;
            public static Find($name: string): UnityEngine.GameObject;
            public static SetGameObjectsActive($instanceIDs: Unity.Collections.NativeArray$1<number>, $active: boolean): void;
            public static SetGameObjectsActive($entityIds: Unity.Collections.NativeArray$1<UnityEngine.EntityId>, $active: boolean): void;
            public static SetGameObjectsActive($instanceIDs: System.ReadOnlySpan$1<number>, $active: boolean): void;
            public static SetGameObjectsActive($entityIds: System.ReadOnlySpan$1<UnityEngine.EntityId>, $active: boolean): void;
            public static InstantiateGameObjects($sourceInstanceID: number, $count: number, $newInstanceIDs: Unity.Collections.NativeArray$1<number>, $newTransformInstanceIDs: Unity.Collections.NativeArray$1<number>, $destinationScene?: UnityEngine.SceneManagement.Scene): void;
            public static InstantiateGameObjects($sourceEntityId: UnityEngine.EntityId, $count: number, $newEntityIds: Unity.Collections.NativeArray$1<UnityEngine.EntityId>, $newTransformEntityIds: Unity.Collections.NativeArray$1<UnityEngine.EntityId>, $destinationScene?: UnityEngine.SceneManagement.Scene): void;
            public static GetScene($instanceID: number): UnityEngine.SceneManagement.Scene;
            public static GetScene($entityId: UnityEngine.EntityId): UnityEngine.SceneManagement.Scene;
        }

        class InspectorOrderAttribute extends UnityEngine.PropertyAttribute {
            protected [__keep_incompatibility]: never;
            constructor($inspectorSort?: UnityEngine.InspectorSort, $sortDirection?: UnityEngine.InspectorSortDirection);
        }

        enum InspectorSort {
            ByName = 0,
            ByValue = 1
        }

        enum InspectorSortDirection {
            Ascending = 0,
            Descending = 1
        }

        class LayerMask {
            protected [__keep_incompatibility]: never;
            public value: number;
            public static LayerToName($layer: number): string;
            public static NameToLayer($layerName: string): number;
            public static GetMask(...layerNames: string[]): number;
        }

        class LazyLoadReference<T extends UnityEngine.Object> {
            protected [__keep_incompatibility]: never;
            public get isSet(): boolean;
            public get isBroken(): boolean;
            public asset: T;
            public entityId: UnityEngine.EntityId;
            public instanceID: number;
            constructor($asset: T);
            constructor($entityId: UnityEngine.EntityId);
            constructor($instanceID: number);
        }

        class MonoBehaviour extends UnityEngine.Behaviour {
            protected [__keep_incompatibility]: never;
            public get destroyCancellationToken(): System.Threading.CancellationToken;
            public useGUILayout: boolean;
            public get didStart(): boolean;
            public get didAwake(): boolean;
            public runInEditMode: boolean;
            constructor();
            public IsInvoking(): boolean;
            public CancelInvoke(): void;
            public Invoke($methodName: string, $time: number): void;
            public InvokeRepeating($methodName: string, $time: number, $repeatRate: number): void;
            public CancelInvoke($methodName: string): void;
            public IsInvoking($methodName: string): boolean;
            public StartCoroutine($methodName: string): UnityEngine.Coroutine;
            public StartCoroutine($methodName: string, $value: any): UnityEngine.Coroutine;
            public StartCoroutine($routine: System.Collections.IEnumerator): UnityEngine.Coroutine;
            public StartCoroutine_Auto($routine: System.Collections.IEnumerator): UnityEngine.Coroutine;
            public StopCoroutine($routine: System.Collections.IEnumerator): void;
            public StopCoroutine($routine: UnityEngine.Coroutine): void;
            public StopCoroutine($methodName: string): void;
            public StopAllCoroutines(): void;
            public static print($message: any): void;
        }

        class RangeInt {
            protected [__keep_incompatibility]: never;
            public start: number;
            public length: number;
            public get end(): number;
            constructor($start: number, $length: number);
        }

        enum RuntimeInitializeLoadType {
            AfterSceneLoad = 0,
            BeforeSceneLoad = 1,
            AfterAssembliesLoaded = 2,
            BeforeSplashScreen = 3,
            SubsystemRegistration = 4
        }

        class RuntimeInitializeOnLoadMethodAttribute extends UnityEngine.Scripting.PreserveAttribute {
            protected [__keep_incompatibility]: never;
            public get loadType(): UnityEngine.RuntimeInitializeLoadType;
            constructor();
            constructor($loadType: UnityEngine.RuntimeInitializeLoadType);
        }

        class ScriptableObject extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            constructor();
            public SetDirty(): void;
            public static CreateInstance($className: string): UnityEngine.ScriptableObject;
            public static CreateInstance($type: System.Type): UnityEngine.ScriptableObject;
            public static CreateInstance<T extends UnityEngine.ScriptableObject>(): T;
        }

        class SelectionBaseAttribute extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class StackTraceUtility {
            protected [__keep_incompatibility]: never;
            public static ExtractStackTrace(): string;
            public static ExtractStringFromException($exception: any): string;
        }

        class UnityException extends System.SystemException {
            protected [__keep_incompatibility]: never;
            constructor();
            constructor($message: string);
            constructor($message: string, $innerException: System.Exception);
        }

        class MissingComponentException extends System.SystemException {
            protected [__keep_incompatibility]: never;
            constructor();
            constructor($message: string);
            constructor($message: string, $innerException: System.Exception);
        }

        class UnassignedReferenceException extends System.SystemException {
            protected [__keep_incompatibility]: never;
            constructor();
            constructor($message: string);
            constructor($message: string, $innerException: System.Exception);
        }

        class MissingReferenceException extends System.SystemException {
            protected [__keep_incompatibility]: never;
            constructor();
            constructor($message: string);
            constructor($message: string, $innerException: System.Exception);
        }

        class TagHandle {
            protected [__keep_incompatibility]: never;
            public static GetExistingTag($tagName: string): UnityEngine.TagHandle;
            public ToString(): string;
        }

        class TextAsset extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public get bytes(): System.Array$1<number>;
            public get text(): string;
            public get dataSize(): bigint;
            constructor();
            constructor($text: string);
            constructor($bytes: System.ReadOnlySpan$1<number>);
            public ToString(): string;
            public GetData<T>(): Unity.Collections.NativeArray$1<T>;
        }

        class TrackedReference {
            protected [__keep_incompatibility]: never;
            public Equals($o: any): boolean;
            public GetHashCode(): number;
        }

        class UnityAPICompatibilityVersionAttribute extends System.Attribute {
            protected [__keep_incompatibility]: never;
            public get version(): string;
            constructor($version: string, $checkOnlyUnityVersion: boolean);
            constructor($version: string, $configurationAssembliesHashes: System.Array$1<string>);
        }

        enum HideFlags {
            None = 0,
            HideInHierarchy = 1,
            HideInInspector = 2,
            DontSaveInEditor = 4,
            NotEditable = 8,
            DontSaveInBuild = 16,
            DontUnloadUnusedAsset = 32,
            DontSave = 52,
            HideAndDontSave = 61
        }

        enum FindObjectsSortMode {
            None = 0,
            InstanceID = 1
        }

        enum FindObjectsInactive {
            Exclude = 0,
            Include = 1
        }

        class InstantiateParameters {
            protected [__keep_incompatibility]: never;
            public parent: UnityEngine.Transform;
            public scene: UnityEngine.SceneManagement.Scene;
            public worldSpace: boolean;
            public originalImmutable: boolean;
        }

        class InstanceID implements System.IEquatable$1<UnityEngine.InstanceID>, System.IComparable$1<UnityEngine.InstanceID> {
            protected [__keep_incompatibility]: never;
            public static get None(): UnityEngine.InstanceID;
            public Equals($obj: any): boolean;
            public Equals($other: UnityEngine.InstanceID): boolean;
            public CompareTo($other: UnityEngine.InstanceID): number;
            public GetHashCode(): number;
            public IsValid(): boolean;
            public Equals($other: number): boolean;
            public ToString(): string;
            public ToString($format: string): string;
        }

        class EntityId implements System.IEquatable$1<UnityEngine.EntityId>, System.IComparable$1<UnityEngine.EntityId> {
            protected [__keep_incompatibility]: never;
            public static get None(): UnityEngine.EntityId;
            public Equals($obj: any): boolean;
            public Equals($other: UnityEngine.EntityId): boolean;
            public CompareTo($other: UnityEngine.EntityId): number;
            public GetHashCode(): number;
            public IsValid(): boolean;
            public Equals($other: number): boolean;
            public ToString(): string;
            public ToString($format: string): string;
        }

        class Object {
            protected [__keep_incompatibility]: never;
            public name: string;
            public hideFlags: UnityEngine.HideFlags;
            constructor();
            public GetEntityId(): UnityEngine.EntityId;
            public GetInstanceID(): number;
            public GetHashCode(): number;
            public Equals($other: any): boolean;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $parent: UnityEngine.Transform): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $parent: UnityEngine.Transform, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $count: number): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $count: number, $parent: UnityEngine.Transform): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $count: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $count: number, $positions: System.ReadOnlySpan$1<UnityEngine.Vector3>, $rotations: System.ReadOnlySpan$1<UnityEngine.Quaternion>): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $count: number, $parent: UnityEngine.Transform, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $count: number, $parent: UnityEngine.Transform, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $cancellationToken: System.Threading.CancellationToken): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $count: number, $parent: UnityEngine.Transform, $positions: System.ReadOnlySpan$1<UnityEngine.Vector3>, $rotations: System.ReadOnlySpan$1<UnityEngine.Quaternion>): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $count: number, $parent: UnityEngine.Transform, $positions: System.ReadOnlySpan$1<UnityEngine.Vector3>, $rotations: System.ReadOnlySpan$1<UnityEngine.Quaternion>, $cancellationToken: System.Threading.CancellationToken): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $parameters: UnityEngine.InstantiateParameters, $cancellationToken?: System.Threading.CancellationToken): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $count: number, $parameters: UnityEngine.InstantiateParameters, $cancellationToken?: System.Threading.CancellationToken): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $parameters: UnityEngine.InstantiateParameters, $cancellationToken?: System.Threading.CancellationToken): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $count: number, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $parameters: UnityEngine.InstantiateParameters, $cancellationToken?: System.Threading.CancellationToken): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static InstantiateAsync<T extends UnityEngine.Object>($original: T, $count: number, $positions: System.ReadOnlySpan$1<UnityEngine.Vector3>, $rotations: System.ReadOnlySpan$1<UnityEngine.Quaternion>, $parameters: UnityEngine.InstantiateParameters, $cancellationToken?: System.Threading.CancellationToken): UnityEngine.AsyncInstantiateOperation$1<T>;
            public static Instantiate($original: UnityEngine.Object, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion): UnityEngine.Object;
            public static Instantiate($original: UnityEngine.Object, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $parent: UnityEngine.Transform): UnityEngine.Object;
            public static Instantiate($original: UnityEngine.Object): UnityEngine.Object;
            public static Instantiate($original: UnityEngine.Object, $scene: UnityEngine.SceneManagement.Scene): UnityEngine.Object;
            public static Instantiate<T extends UnityEngine.Object>($original: T, $parameters: UnityEngine.InstantiateParameters): T;
            public static Instantiate<T extends UnityEngine.Object>($original: T, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $parameters: UnityEngine.InstantiateParameters): T;
            public static Instantiate($original: UnityEngine.Object, $parent: UnityEngine.Transform): UnityEngine.Object;
            public static Instantiate($original: UnityEngine.Object, $parent: UnityEngine.Transform, $instantiateInWorldSpace: boolean): UnityEngine.Object;
            public static Instantiate<T extends UnityEngine.Object>($original: T): T;
            public static Instantiate<T extends UnityEngine.Object>($original: T, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion): T;
            public static Instantiate<T extends UnityEngine.Object>($original: T, $position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion, $parent: UnityEngine.Transform): T;
            public static Instantiate<T extends UnityEngine.Object>($original: T, $parent: UnityEngine.Transform): T;
            public static Instantiate<T extends UnityEngine.Object>($original: T, $parent: UnityEngine.Transform, $worldPositionStays: boolean): T;
            public static Destroy($obj: UnityEngine.Object, $t: number): void;
            public static Destroy($obj: UnityEngine.Object): void;
            public static DestroyImmediate($obj: UnityEngine.Object, $allowDestroyingAssets: boolean): void;
            public static DestroyImmediate($obj: UnityEngine.Object): void;
            public static FindObjectsOfType($type: System.Type): System.Array$1<UnityEngine.Object>;
            public static FindObjectsOfType($type: System.Type, $includeInactive: boolean): System.Array$1<UnityEngine.Object>;
            public static FindObjectsByType($type: System.Type, $sortMode: UnityEngine.FindObjectsSortMode): System.Array$1<UnityEngine.Object>;
            public static FindObjectsByType($type: System.Type, $findObjectsInactive: UnityEngine.FindObjectsInactive, $sortMode: UnityEngine.FindObjectsSortMode): System.Array$1<UnityEngine.Object>;
            public static DontDestroyOnLoad($target: UnityEngine.Object): void;
            public static DestroyObject($obj: UnityEngine.Object, $t: number): void;
            public static DestroyObject($obj: UnityEngine.Object): void;
            public static FindSceneObjectsOfType($type: System.Type): System.Array$1<UnityEngine.Object>;
            public static FindObjectsOfTypeIncludingAssets($type: System.Type): System.Array$1<UnityEngine.Object>;
            public static FindObjectsOfType<T extends UnityEngine.Object>(): System.Array$1<T>;
            public static FindObjectsByType<T extends UnityEngine.Object>($sortMode: UnityEngine.FindObjectsSortMode): System.Array$1<T>;
            public static FindObjectsOfType<T extends UnityEngine.Object>($includeInactive: boolean): System.Array$1<T>;
            public static FindObjectsByType<T extends UnityEngine.Object>($findObjectsInactive: UnityEngine.FindObjectsInactive, $sortMode: UnityEngine.FindObjectsSortMode): System.Array$1<T>;
            public static FindObjectOfType<T extends UnityEngine.Object>(): T;
            public static FindObjectOfType<T extends UnityEngine.Object>($includeInactive: boolean): T;
            public static FindFirstObjectByType<T extends UnityEngine.Object>(): T;
            public static FindAnyObjectByType<T extends UnityEngine.Object>(): T;
            public static FindFirstObjectByType<T extends UnityEngine.Object>($findObjectsInactive: UnityEngine.FindObjectsInactive): T;
            public static FindAnyObjectByType<T extends UnityEngine.Object>($findObjectsInactive: UnityEngine.FindObjectsInactive): T;
            public static FindObjectsOfTypeAll($type: System.Type): System.Array$1<UnityEngine.Object>;
            public static FindObjectOfType($type: System.Type): UnityEngine.Object;
            public static FindFirstObjectByType($type: System.Type): UnityEngine.Object;
            public static FindAnyObjectByType($type: System.Type): UnityEngine.Object;
            public static FindObjectOfType($type: System.Type, $includeInactive: boolean): UnityEngine.Object;
            public static FindFirstObjectByType($type: System.Type, $findObjectsInactive: UnityEngine.FindObjectsInactive): UnityEngine.Object;
            public static FindAnyObjectByType($type: System.Type, $findObjectsInactive: UnityEngine.FindObjectsInactive): UnityEngine.Object;
            public ToString(): string;
        }

        class WaitForEndOfFrame extends UnityEngine.YieldInstruction {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class WaitForFixedUpdate extends UnityEngine.YieldInstruction {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class WaitForSeconds extends UnityEngine.YieldInstruction {
            protected [__keep_incompatibility]: never;
            constructor($seconds: number);
        }

        class WaitForSecondsRealtime extends UnityEngine.CustomYieldInstruction {
            protected [__keep_incompatibility]: never;
            public waitTime: number;
            public get keepWaiting(): boolean;
            constructor($time: number);
            public Reset(): void;
        }

        enum WaitTimeoutMode {
            Realtime = 0,
            InGameTime = 1
        }

        class WaitUntil extends UnityEngine.CustomYieldInstruction {
            protected [__keep_incompatibility]: never;
            public get keepWaiting(): boolean;
            constructor($predicate: System.Func$1<boolean>);
            constructor($predicate: System.Func$1<boolean>, $timeout: System.TimeSpan, $onTimeout: System.Action, $timeoutMode?: UnityEngine.WaitTimeoutMode);
        }

        class WaitWhile extends UnityEngine.CustomYieldInstruction {
            protected [__keep_incompatibility]: never;
            public get keepWaiting(): boolean;
            constructor($predicate: System.Func$1<boolean>);
            constructor($predicate: System.Func$1<boolean>, $timeout: System.TimeSpan, $onTimeout: System.Action, $timeoutMode?: UnityEngine.WaitTimeoutMode);
        }

        class YieldInstruction {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class Security {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class Types {
            protected [__keep_incompatibility]: never;
        }

        class MakeSerializableAttribute extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor($type: System.Type);
        }

        class SerializeField extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class SerializeReference extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        class PreferBinarySerialization extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor();
        }

        interface ISerializationCallbackReceiver {
            OnBeforeSerialize(): void;
            OnAfterDeserialize(): void;
        }

        class ComputeBuffer implements System.IDisposable {
            protected [__keep_incompatibility]: never;
            public get count(): number;
            public get stride(): number;
            public set name(value: string);
            constructor($count: number, $stride: number);
            constructor($count: number, $stride: number, $type: UnityEngine.ComputeBufferType);
            constructor($count: number, $stride: number, $type: UnityEngine.ComputeBufferType, $usage: UnityEngine.ComputeBufferMode);
            public Dispose(): void;
            public Release(): void;
            public IsValid(): boolean;
            public SetData($data: System.Array): void;
            public SetData<T>($data: System.Collections.Generic.List$1<T>): void;
            public SetData<T>($data: Unity.Collections.NativeArray$1<T>): void;
            public SetData($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number): void;
            public SetData<T>($data: System.Collections.Generic.List$1<T>, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number): void;
            public SetData<T>($data: Unity.Collections.NativeArray$1<T>, $nativeBufferStartIndex: number, $computeBufferStartIndex: number, $count: number): void;
            public GetData($data: System.Array): void;
            public GetData($data: System.Array, $managedBufferStartIndex: number, $computeBufferStartIndex: number, $count: number): void;
            public BeginWrite<T>($computeBufferStartIndex: number, $count: number): Unity.Collections.NativeArray$1<T>;
            public EndWrite<T>($countWritten: number): void;
            public SetCounterValue($counterValue: number): void;
            public static CopyCount($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number): void;
            public GetNativeBufferPtr(): number;
        }

        class ComputeShader extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public get keywordSpace(): UnityEngine.Rendering.LocalKeywordSpace;
            public shaderKeywords: System.Array$1<string>;
            public enabledKeywords: System.Array$1<UnityEngine.Rendering.LocalKeyword>;
            public FindKernel($name: string): number;
            public HasKernel($name: string): boolean;
            public SetFloat($nameID: number, $val: number): void;
            public SetInt($nameID: number, $val: number): void;
            public SetVector($nameID: number, $val: UnityEngine.Vector4): void;
            public SetMatrix($nameID: number, $val: UnityEngine.Matrix4x4): void;
            public SetVectorArray($nameID: number, $values: System.Array$1<UnityEngine.Vector4>): void;
            public SetMatrixArray($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>): void;
            public SetTexture($kernelIndex: number, $nameID: number, $texture: UnityEngine.Texture, $mipLevel: number): void;
            public SetTextureFromGlobal($kernelIndex: number, $nameID: number, $globalTextureNameID: number): void;
            public SetRayTracingAccelerationStructure($kernelIndex: number, $nameID: number, $accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure): void;
            public SetBuffer($kernelIndex: number, $nameID: number, $buffer: UnityEngine.ComputeBuffer): void;
            public SetBuffer($kernelIndex: number, $nameID: number, $buffer: UnityEngine.GraphicsBuffer): void;
            public GetKernelThreadGroupSizes($kernelIndex: number, $x: $Out<number>, $y: $Out<number>, $z: $Out<number>): void;
            public Dispatch($kernelIndex: number, $threadGroupsX: number, $threadGroupsY: number, $threadGroupsZ: number): void;
            public EnableKeyword($keyword: string): void;
            public DisableKeyword($keyword: string): void;
            public IsKeywordEnabled($keyword: string): boolean;
            public EnableKeyword($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): void;
            public DisableKeyword($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): void;
            public SetKeyword($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>, $value: boolean): void;
            public IsKeywordEnabled($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): boolean;
            public IsSupported($kernelIndex: number): boolean;
            public SetFloat($name: string, $val: number): void;
            public SetInt($name: string, $val: number): void;
            public SetVector($name: string, $val: UnityEngine.Vector4): void;
            public SetMatrix($name: string, $val: UnityEngine.Matrix4x4): void;
            public SetVectorArray($name: string, $values: System.Array$1<UnityEngine.Vector4>): void;
            public SetMatrixArray($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>): void;
            public SetFloats($name: string, ...values: number[]): void;
            public SetFloats($nameID: number, ...values: number[]): void;
            public SetInts($name: string, ...values: number[]): void;
            public SetInts($nameID: number, ...values: number[]): void;
            public SetBool($name: string, $val: boolean): void;
            public SetBool($nameID: number, $val: boolean): void;
            public SetTexture($kernelIndex: number, $nameID: number, $texture: UnityEngine.Texture): void;
            public SetTexture($kernelIndex: number, $name: string, $texture: UnityEngine.Texture): void;
            public SetTexture($kernelIndex: number, $name: string, $texture: UnityEngine.Texture, $mipLevel: number): void;
            public SetTexture($kernelIndex: number, $nameID: number, $texture: UnityEngine.RenderTexture, $mipLevel: number, $element: UnityEngine.Rendering.RenderTextureSubElement): void;
            public SetTexture($kernelIndex: number, $name: string, $texture: UnityEngine.RenderTexture, $mipLevel: number, $element: UnityEngine.Rendering.RenderTextureSubElement): void;
            public SetTextureFromGlobal($kernelIndex: number, $name: string, $globalTextureName: string): void;
            public SetBuffer($kernelIndex: number, $name: string, $buffer: UnityEngine.ComputeBuffer): void;
            public SetBuffer($kernelIndex: number, $name: string, $buffer: UnityEngine.GraphicsBuffer): void;
            public SetRayTracingAccelerationStructure($kernelIndex: number, $name: string, $accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure): void;
            public SetConstantBuffer($nameID: number, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number): void;
            public SetConstantBuffer($name: string, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number): void;
            public SetConstantBuffer($nameID: number, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number): void;
            public SetConstantBuffer($name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number): void;
            public DispatchIndirect($kernelIndex: number, $argsBuffer: UnityEngine.ComputeBuffer, $argsOffset: number): void;
            public DispatchIndirect($kernelIndex: number, $argsBuffer: UnityEngine.ComputeBuffer): void;
            public DispatchIndirect($kernelIndex: number, $argsBuffer: UnityEngine.GraphicsBuffer, $argsOffset: number): void;
            public DispatchIndirect($kernelIndex: number, $argsBuffer: UnityEngine.GraphicsBuffer): void;
        }

        enum MaterialPropertyType {
            Float = 0,
            Int = 1,
            Vector = 2,
            Matrix = 3,
            Texture = 4,
            ConstantBuffer = 5,
            ComputeBuffer = 6
        }

        class ShaderVariantCollection extends UnityEngine.Object {
            protected [__keep_incompatibility]: never;
            public get shaderCount(): number;
            public get variantCount(): number;
            public get warmedUpVariantCount(): number;
            public get isWarmedUp(): boolean;
            constructor();
            public Clear(): void;
            public WarmUp(): void;
            public WarmUpProgressively($variantCount: number): boolean;
            public Add($variant: UnityEngine.ShaderVariantCollection.ShaderVariant): boolean;
            public Remove($variant: UnityEngine.ShaderVariantCollection.ShaderVariant): boolean;
            public Contains($variant: UnityEngine.ShaderVariantCollection.ShaderVariant): boolean;
        }
        namespace ShaderVariantCollection {
            class ShaderVariant {
                protected [__keep_incompatibility]: never;
                public shader: UnityEngine.Shader;
                public passType: UnityEngine.Rendering.PassType;
                public keywords: System.Array$1<string>;
                constructor($shader: UnityEngine.Shader, $passType: UnityEngine.Rendering.PassType, ...keywords: string[]);
            }

        }

        enum SnapAxis {
            None = 0,
            X = 1,
            Y = 2,
            Z = 4,
            All = 7
        }

        class Snapping {
            protected [__keep_incompatibility]: never;
            public static Snap($val: number, $snap: number): number;
            public static Snap($val: UnityEngine.Vector2, $snap: UnityEngine.Vector2): UnityEngine.Vector2;
            public static Snap($val: UnityEngine.Vector3, $snap: UnityEngine.Vector3, $axis?: UnityEngine.SnapAxis): UnityEngine.Vector3;
        }

        class StaticBatchingUtility {
            protected [__keep_incompatibility]: never;
            constructor();
            public static Combine($staticBatchRoot: UnityEngine.GameObject): void;
            public static Combine($gos: System.Array$1<UnityEngine.GameObject>, $staticBatchRoot: UnityEngine.GameObject): void;
        }

        enum BatteryStatus {
            Unknown = 0,
            Charging = 1,
            Discharging = 2,
            NotCharging = 3,
            Full = 4
        }

        enum OperatingSystemFamily {
            Other = 0,
            MacOSX = 1,
            Windows = 2,
            Linux = 3
        }

        enum DeviceType {
            Unknown = 0,
            Handheld = 1,
            Console = 2,
            Desktop = 3
        }

        class SystemInfo {
            protected [__keep_incompatibility]: never;
            public static readonly unsupportedIdentifier: string;
            public static get batteryLevel(): number;
            public static get batteryStatus(): UnityEngine.BatteryStatus;
            public static get operatingSystem(): string;
            public static get operatingSystemFamily(): UnityEngine.OperatingSystemFamily;
            public static get processorType(): string;
            public static get processorModel(): string;
            public static get processorManufacturer(): string;
            public static get processorFrequency(): number;
            public static get processorCount(): number;
            public static get systemMemorySize(): number;
            public static get deviceUniqueIdentifier(): string;
            public static get deviceName(): string;
            public static get deviceModel(): string;
            public static get supportsAccelerometer(): boolean;
            public static get supportsGyroscope(): boolean;
            public static get supportsLocationService(): boolean;
            public static get supportsVibration(): boolean;
            public static get supportsAudio(): boolean;
            public static get supportsRendering(): boolean;
            public static get deviceType(): UnityEngine.DeviceType;
            public static get graphicsMemorySize(): number;
            public static get graphicsDeviceName(): string;
            public static get graphicsDeviceVendor(): string;
            public static get graphicsDeviceID(): number;
            public static get graphicsDeviceVendorID(): number;
            public static get graphicsDeviceType(): UnityEngine.Rendering.GraphicsDeviceType;
            public static get graphicsUVStartsAtTop(): boolean;
            public static get graphicsDeviceVersion(): string;
            public static get graphicsShaderLevel(): number;
            public static get graphicsMultiThreaded(): boolean;
            public static get renderingThreadingMode(): UnityEngine.Rendering.RenderingThreadingMode;
            public static get foveatedRenderingCaps(): UnityEngine.Rendering.FoveatedRenderingCaps;
            public static get hasTiledGPU(): boolean;
            public static get hasHiddenSurfaceRemovalOnGPU(): boolean;
            public static get hasDynamicUniformArrayIndexingInFragmentShaders(): boolean;
            public static get supportsShadows(): boolean;
            public static get supportsRawShadowDepthSampling(): boolean;
            public static get supportsRenderTextures(): boolean;
            public static get supportsMotionVectors(): boolean;
            public static get supportsRenderToCubemap(): boolean;
            public static get supportsImageEffects(): boolean;
            public static get supports3DTextures(): boolean;
            public static get supportsCompressed3DTextures(): boolean;
            public static get supports2DArrayTextures(): boolean;
            public static get supports3DRenderTextures(): boolean;
            public static get supportsCubemapArrayTextures(): boolean;
            public static get supportsAnisotropicFilter(): boolean;
            public static get copyTextureSupport(): UnityEngine.Rendering.CopyTextureSupport;
            public static get supportsComputeShaders(): boolean;
            public static get supportsGeometryShaders(): boolean;
            public static get supportsTessellationShaders(): boolean;
            public static get supportsRenderTargetArrayIndexFromVertexShader(): boolean;
            public static get supportsInstancing(): boolean;
            public static get supportsHardwareQuadTopology(): boolean;
            public static get supports32bitsIndexBuffer(): boolean;
            public static get supportsSparseTextures(): boolean;
            public static get supportedRenderTargetCount(): number;
            public static get supportsSeparatedRenderTargetsBlend(): boolean;
            public static get supportedRandomWriteTargetCount(): number;
            public static get supportsMultisampledTextures(): number;
            public static get supportsMultisampled2DArrayTextures(): boolean;
            public static get supportsMultisampledBackBuffer(): boolean;
            public static get supportsMemorylessTextures(): boolean;
            public static get supportsMultisampleAutoResolve(): boolean;
            public static get supportsMultisampledShaderResolve(): boolean;
            public static get supportsTextureWrapMirrorOnce(): number;
            public static get usesReversedZBuffer(): boolean;
            public static get supportsVariableRateShading(): boolean;
            public static get maxTiledPixelStorageSize(): number;
            public static get supportsDynamicResolution(): boolean;
            public static get npotSupport(): UnityEngine.NPOTSupport;
            public static get maxTextureSize(): number;
            public static get maxTexture3DSize(): number;
            public static get maxTextureArraySlices(): number;
            public static get maxCubemapSize(): number;
            public static get maxAnisotropyLevel(): number;
            public static get maxComputeBufferInputsVertex(): number;
            public static get maxComputeBufferInputsFragment(): number;
            public static get maxComputeBufferInputsGeometry(): number;
            public static get maxComputeBufferInputsDomain(): number;
            public static get maxComputeBufferInputsHull(): number;
            public static get maxComputeBufferInputsCompute(): number;
            public static get maxComputeWorkGroupSize(): number;
            public static get maxComputeWorkGroupSizeX(): number;
            public static get maxComputeWorkGroupSizeY(): number;
            public static get maxComputeWorkGroupSizeZ(): number;
            public static get computeSubGroupSize(): number;
            public static get supportsAsyncCompute(): boolean;
            public static get supportsGpuRecorder(): boolean;
            public static get supportsGraphicsFence(): boolean;
            public static get supportsAsyncGPUReadback(): boolean;
            public static get supportsParallelPSOCreation(): boolean;
            public static get supportsRayTracingShaders(): boolean;
            public static get supportsRayTracing(): boolean;
            public static get supportsInlineRayTracing(): boolean;
            public static get supportsIndirectDispatchRays(): boolean;
            public static get supportsMachineLearning(): boolean;
            public static get supportsSetConstantBuffer(): boolean;
            public static get constantBufferOffsetAlignment(): number;
            public static get maxConstantBufferSize(): number;
            public static get maxGraphicsBufferSize(): bigint;
            public static get hasMipMaxLevel(): boolean;
            public static get supportsMipStreaming(): boolean;
            public static get graphicsPixelFillrate(): number;
            public static get usesLoadStoreActions(): boolean;
            public static get hdrDisplaySupportFlags(): UnityEngine.HDRDisplaySupportFlags;
            public static get supportsConservativeRaster(): boolean;
            public static get supportsMultiview(): boolean;
            public static get supportsStoreAndResolveAction(): boolean;
            public static get supportsMultisampleResolveDepth(): boolean;
            public static get supportsMultisampleResolveStencil(): boolean;
            public static get supportsIndirectArgumentsBuffer(): boolean;
            public static get supportsDepthFetchInRenderPass(): boolean;
            constructor();
            public static SupportsRenderTextureFormat($format: UnityEngine.RenderTextureFormat): boolean;
            public static SupportsBlendingOnRenderTextureFormat($format: UnityEngine.RenderTextureFormat): boolean;
            public static SupportsRandomWriteOnRenderTextureFormat($format: UnityEngine.RenderTextureFormat): boolean;
            public static SupportsTextureFormat($format: UnityEngine.TextureFormat): boolean;
            public static SupportsVertexAttributeFormat($format: UnityEngine.Rendering.VertexAttributeFormat, $dimension: number): boolean;
            public static IsFormatSupported($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.FormatUsage): boolean;
            public static IsFormatSupported($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.GraphicsFormatUsage): boolean;
            public static GetCompatibleFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.FormatUsage): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public static GetCompatibleFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.GraphicsFormatUsage): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public static GetGraphicsFormat($format: UnityEngine.Experimental.Rendering.DefaultFormat): UnityEngine.Experimental.Rendering.GraphicsFormat;
            public static GetRenderTextureSupportedMSAASampleCount($desc: UnityEngine.RenderTextureDescriptor): number;
            public static GetTiledRenderTargetStorageSize($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $sampleCount: number): number;
        }

        class Time {
            protected [__keep_incompatibility]: never;
            public static get time(): number;
            public static get timeAsDouble(): number;
            public static get timeAsRational(): Unity.IntegerTime.RationalTime;
            public static get timeSinceLevelLoad(): number;
            public static get timeSinceLevelLoadAsDouble(): number;
            public static get deltaTime(): number;
            public static get fixedTime(): number;
            public static get fixedTimeAsDouble(): number;
            public static get unscaledTime(): number;
            public static get unscaledTimeAsDouble(): number;
            public static get fixedUnscaledTime(): number;
            public static get fixedUnscaledTimeAsDouble(): number;
            public static get unscaledDeltaTime(): number;
            public static get fixedUnscaledDeltaTime(): number;
            public static fixedDeltaTime: number;
            public static maximumDeltaTime: number;
            public static get smoothDeltaTime(): number;
            public static maximumParticleDeltaTime: number;
            public static timeScale: number;
            public static get frameCount(): number;
            public static get renderedFrameCount(): number;
            public static get realtimeSinceStartup(): number;
            public static get realtimeSinceStartupAsDouble(): number;
            public static captureDeltaTime: number;
            public static captureDeltaTimeRational: Unity.IntegerTime.RationalTime;
            public static captureFramerate: number;
            public static get inFixedTimeStep(): boolean;
            constructor();
        }

        class TouchScreenKeyboard {
            protected [__keep_incompatibility]: never;
            public static get isSupported(): boolean;
            public static get isInPlaceEditingAllowed(): boolean;
            public text: string;
            public static hideInput: boolean;
            public static get inputFieldAppearance(): UnityEngine.TouchScreenKeyboard.InputFieldAppearance;
            public active: boolean;
            public get done(): boolean;
            public get wasCanceled(): boolean;
            public get status(): UnityEngine.TouchScreenKeyboard.Status;
            public characterLimit: number;
            public get canGetSelection(): boolean;
            public get canSetSelection(): boolean;
            public selection: UnityEngine.RangeInt;
            public get type(): UnityEngine.TouchScreenKeyboardType;
            public targetDisplay: number;
            public static get area(): UnityEngine.Rect;
            public static get visible(): boolean;
            constructor($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $characterLimit: number);
            public static Open($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string, $characterLimit: number): UnityEngine.TouchScreenKeyboard;
            public static Open($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean, $textPlaceholder: string): UnityEngine.TouchScreenKeyboard;
            public static Open($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean, $alert: boolean): UnityEngine.TouchScreenKeyboard;
            public static Open($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean, $secure: boolean): UnityEngine.TouchScreenKeyboard;
            public static Open($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean, $multiline: boolean): UnityEngine.TouchScreenKeyboard;
            public static Open($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType, $autocorrection: boolean): UnityEngine.TouchScreenKeyboard;
            public static Open($text: string, $keyboardType: UnityEngine.TouchScreenKeyboardType): UnityEngine.TouchScreenKeyboard;
            public static Open($text: string): UnityEngine.TouchScreenKeyboard;
        }
        namespace TouchScreenKeyboard {
            enum Status {
                Visible = 0,
                Done = 1,
                Canceled = 2,
                LostFocus = 3
            }

            enum InputFieldAppearance {
                Customizable = 0,
                AlwaysVisible = 1,
                AlwaysHidden = 2
            }

            class Android {
                protected [__keep_incompatibility]: never;
                public static closeKeyboardOnOutsideTap: boolean;
                public static consumesOutsideTouches: boolean;
                constructor();
            }

        }

        enum TouchScreenKeyboardType {
            Default = 0,
            ASCIICapable = 1,
            NumbersAndPunctuation = 2,
            URL = 3,
            NumberPad = 4,
            PhonePad = 5,
            NamePhonePad = 6,
            EmailAddress = 7,
            NintendoNetworkAccount = 8,
            Social = 9,
            Search = 10,
            DecimalPad = 11,
            OneTimeCode = 12
        }

        class UnityEventQueueSystem {
            protected [__keep_incompatibility]: never;
            constructor();
            public static GenerateEventIdForPayload($eventPayloadName: string): string;
            public static GetGlobalEventQueue(): number;
        }

        class Pose implements System.IEquatable$1<UnityEngine.Pose> {
            protected [__keep_incompatibility]: never;
            public position: UnityEngine.Vector3;
            public rotation: UnityEngine.Quaternion;
            public get forward(): UnityEngine.Vector3;
            public get right(): UnityEngine.Vector3;
            public get up(): UnityEngine.Vector3;
            public static get identity(): UnityEngine.Pose;
            constructor($position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion);
            public ToString(): string;
            public ToString($format: string): string;
            public GetTransformedBy($lhs: UnityEngine.Pose): UnityEngine.Pose;
            public GetTransformedBy($lhs: UnityEngine.Transform): UnityEngine.Pose;
            public Equals($obj: any): boolean;
            public Equals($other: UnityEngine.Pose): boolean;
            public GetHashCode(): number;
        }

        class FrameDebugger {
            protected [__keep_incompatibility]: never;
            public static get enabled(): boolean;
        }

        enum DrivenTransformProperties {
            None = 0,
            AnchoredPositionX = 2,
            AnchoredPositionY = 4,
            AnchoredPosition = 6,
            AnchoredPositionZ = 8,
            AnchoredPosition3D = 14,
            Rotation = 16,
            ScaleX = 32,
            ScaleY = 64,
            ScaleZ = 128,
            Scale = 224,
            AnchorMinX = 256,
            AnchorMinY = 512,
            AnchorMin = 768,
            AnchorMaxX = 1024,
            AnchorMaxY = 2048,
            AnchorMax = 3072,
            Anchors = 3840,
            SizeDeltaX = 4096,
            SizeDeltaY = 8192,
            SizeDelta = 12288,
            PivotX = 16384,
            PivotY = 32768,
            Pivot = 49152,
            All = -1
        }

        class DrivenRectTransformTracker {
            protected [__keep_incompatibility]: never;
            public static StopRecordingUndo(): void;
            public static StartRecordingUndo(): void;
            public Add($driver: UnityEngine.Object, $rectTransform: UnityEngine.RectTransform, $drivenProperties: UnityEngine.DrivenTransformProperties): void;
            public Clear($revertValues: boolean): void;
            public Clear(): void;
        }

        class RectTransform extends UnityEngine.Transform {
            protected [__keep_incompatibility]: never;
            public get rect(): UnityEngine.Rect;
            public anchorMin: UnityEngine.Vector2;
            public anchorMax: UnityEngine.Vector2;
            public anchoredPosition: UnityEngine.Vector2;
            public sizeDelta: UnityEngine.Vector2;
            public pivot: UnityEngine.Vector2;
            public anchoredPosition3D: UnityEngine.Vector3;
            public offsetMin: UnityEngine.Vector2;
            public offsetMax: UnityEngine.Vector2;
            public get drivenByObject(): UnityEngine.Object;
            public sendChildDimensionsChange: boolean;
            constructor();
            public ForceUpdateRectTransforms(): void;
            public GetLocalCorners($fourCornersArray: System.Array$1<UnityEngine.Vector3>): void;
            public GetWorldCorners($fourCornersArray: System.Array$1<UnityEngine.Vector3>): void;
            public SetInsetAndSizeFromParentEdge($edge: UnityEngine.RectTransform.Edge, $inset: number, $size: number): void;
            public SetSizeWithCurrentAnchors($axis: UnityEngine.RectTransform.Axis, $size: number): void;
            public static add_reapplyDrivenProperties(handler: UnityEngine.RectTransform.ReapplyDrivenProperties): void;
            public static remove_reapplyDrivenProperties(handler: UnityEngine.RectTransform.ReapplyDrivenProperties): void;
        }
        namespace RectTransform {
            enum Edge {
                Left = 0,
                Right = 1,
                Top = 2,
                Bottom = 3
            }

            enum Axis {
                Horizontal = 0,
                Vertical = 1
            }

            interface ReapplyDrivenProperties {
                ($driven: UnityEngine.RectTransform): void;
                Invoke?: ($driven: UnityEngine.RectTransform) => void;
            }
            var ReapplyDrivenProperties: { new (func: ($driven: UnityEngine.RectTransform) => void): ReapplyDrivenProperties; };

        }

        class Transform extends UnityEngine.Component implements System.Collections.IEnumerable {
            protected [__keep_incompatibility]: never;
            public position: UnityEngine.Vector3;
            public localPosition: UnityEngine.Vector3;
            public eulerAngles: UnityEngine.Vector3;
            public localEulerAngles: UnityEngine.Vector3;
            public right: UnityEngine.Vector3;
            public up: UnityEngine.Vector3;
            public forward: UnityEngine.Vector3;
            public rotation: UnityEngine.Quaternion;
            public localRotation: UnityEngine.Quaternion;
            public localScale: UnityEngine.Vector3;
            public parent: UnityEngine.Transform;
            public get worldToLocalMatrix(): UnityEngine.Matrix4x4;
            public get localToWorldMatrix(): UnityEngine.Matrix4x4;
            public get root(): UnityEngine.Transform;
            public get childCount(): number;
            public get lossyScale(): UnityEngine.Vector3;
            public hasChanged: boolean;
            public hierarchyCapacity: number;
            public get hierarchyCount(): number;
            public SetParent($p: UnityEngine.Transform): void;
            public SetParent($parent: UnityEngine.Transform, $worldPositionStays: boolean): void;
            public SetPositionAndRotation($position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion): void;
            public SetLocalPositionAndRotation($localPosition: UnityEngine.Vector3, $localRotation: UnityEngine.Quaternion): void;
            public GetPositionAndRotation($position: $Out<UnityEngine.Vector3>, $rotation: $Out<UnityEngine.Quaternion>): void;
            public GetLocalPositionAndRotation($localPosition: $Out<UnityEngine.Vector3>, $localRotation: $Out<UnityEngine.Quaternion>): void;
            public Translate($translation: UnityEngine.Vector3, $relativeTo: UnityEngine.Space): void;
            public Translate($translation: UnityEngine.Vector3): void;
            public Translate($x: number, $y: number, $z: number, $relativeTo: UnityEngine.Space): void;
            public Translate($x: number, $y: number, $z: number): void;
            public Translate($translation: UnityEngine.Vector3, $relativeTo: UnityEngine.Transform): void;
            public Translate($x: number, $y: number, $z: number, $relativeTo: UnityEngine.Transform): void;
            public Rotate($eulers: UnityEngine.Vector3, $relativeTo: UnityEngine.Space): void;
            public Rotate($eulers: UnityEngine.Vector3): void;
            public Rotate($xAngle: number, $yAngle: number, $zAngle: number, $relativeTo: UnityEngine.Space): void;
            public Rotate($xAngle: number, $yAngle: number, $zAngle: number): void;
            public Rotate($axis: UnityEngine.Vector3, $angle: number, $relativeTo: UnityEngine.Space): void;
            public Rotate($axis: UnityEngine.Vector3, $angle: number): void;
            public RotateAround($point: UnityEngine.Vector3, $axis: UnityEngine.Vector3, $angle: number): void;
            public LookAt($target: UnityEngine.Transform, $worldUp: UnityEngine.Vector3): void;
            public LookAt($target: UnityEngine.Transform): void;
            public LookAt($worldPosition: UnityEngine.Vector3, $worldUp: UnityEngine.Vector3): void;
            public LookAt($worldPosition: UnityEngine.Vector3): void;
            public TransformDirection($direction: UnityEngine.Vector3): UnityEngine.Vector3;
            public TransformDirection($x: number, $y: number, $z: number): UnityEngine.Vector3;
            public TransformDirections($directions: System.ReadOnlySpan$1<UnityEngine.Vector3>, $transformedDirections: System.Span$1<UnityEngine.Vector3>): void;
            public TransformDirections($directions: System.Span$1<UnityEngine.Vector3>): void;
            public InverseTransformDirection($direction: UnityEngine.Vector3): UnityEngine.Vector3;
            public InverseTransformDirection($x: number, $y: number, $z: number): UnityEngine.Vector3;
            public InverseTransformDirections($directions: System.ReadOnlySpan$1<UnityEngine.Vector3>, $transformedDirections: System.Span$1<UnityEngine.Vector3>): void;
            public InverseTransformDirections($directions: System.Span$1<UnityEngine.Vector3>): void;
            public TransformVector($vector: UnityEngine.Vector3): UnityEngine.Vector3;
            public TransformVector($x: number, $y: number, $z: number): UnityEngine.Vector3;
            public TransformVectors($vectors: System.ReadOnlySpan$1<UnityEngine.Vector3>, $transformedVectors: System.Span$1<UnityEngine.Vector3>): void;
            public TransformVectors($vectors: System.Span$1<UnityEngine.Vector3>): void;
            public InverseTransformVector($vector: UnityEngine.Vector3): UnityEngine.Vector3;
            public InverseTransformVector($x: number, $y: number, $z: number): UnityEngine.Vector3;
            public InverseTransformVectors($vectors: System.ReadOnlySpan$1<UnityEngine.Vector3>, $transformedVectors: System.Span$1<UnityEngine.Vector3>): void;
            public InverseTransformVectors($vectors: System.Span$1<UnityEngine.Vector3>): void;
            public TransformPoint($position: UnityEngine.Vector3): UnityEngine.Vector3;
            public TransformPoint($x: number, $y: number, $z: number): UnityEngine.Vector3;
            public TransformPoints($positions: System.ReadOnlySpan$1<UnityEngine.Vector3>, $transformedPositions: System.Span$1<UnityEngine.Vector3>): void;
            public TransformPoints($positions: System.Span$1<UnityEngine.Vector3>): void;
            public InverseTransformPoint($position: UnityEngine.Vector3): UnityEngine.Vector3;
            public InverseTransformPoint($x: number, $y: number, $z: number): UnityEngine.Vector3;
            public InverseTransformPoints($positions: System.ReadOnlySpan$1<UnityEngine.Vector3>, $transformedPositions: System.Span$1<UnityEngine.Vector3>): void;
            public InverseTransformPoints($positions: System.Span$1<UnityEngine.Vector3>): void;
            public DetachChildren(): void;
            public SetAsFirstSibling(): void;
            public SetAsLastSibling(): void;
            public SetSiblingIndex($index: number): void;
            public GetSiblingIndex(): number;
            public Find($n: string): UnityEngine.Transform;
            public IsChildOf($parent: UnityEngine.Transform): boolean;
            public FindChild($n: string): UnityEngine.Transform;
            public GetEnumerator(): System.Collections.IEnumerator;
            public RotateAround($axis: UnityEngine.Vector3, $angle: number): void;
            public RotateAroundLocal($axis: UnityEngine.Vector3, $angle: number): void;
            public GetChild($index: number): UnityEngine.Transform;
            public GetChildCount(): number;
        }

        class TransformHandle implements System.IEquatable$1<UnityEngine.TransformHandle>, System.IComparable$1<UnityEngine.TransformHandle> {
            protected [__keep_incompatibility]: never;
            public static get None(): UnityEngine.TransformHandle;
            public get DirectChildren(): UnityEngine.TransformHandle.DirectChildrenEnumerable;
            public position: UnityEngine.Vector3;
            public rotation: UnityEngine.Quaternion;
            public get lossyScale(): UnityEngine.Vector3;
            public localPosition: UnityEngine.Vector3;
            public localRotation: UnityEngine.Quaternion;
            public localScale: UnityEngine.Vector3;
            public eulerAngles: UnityEngine.Vector3;
            public localEulerAngles: UnityEngine.Vector3;
            public right: UnityEngine.Vector3;
            public up: UnityEngine.Vector3;
            public forward: UnityEngine.Vector3;
            public get worldToLocalMatrix(): UnityEngine.Matrix4x4;
            public get localToWorldMatrix(): UnityEngine.Matrix4x4;
            public get root(): UnityEngine.TransformHandle;
            public parent: UnityEngine.TransformHandle;
            public get childCount(): number;
            public hierarchyCapacity: number;
            public get hierarchyCount(): number;
            public Equals($obj: any): boolean;
            public Equals($other: UnityEngine.TransformHandle): boolean;
            public CompareTo($other: UnityEngine.TransformHandle): number;
            public GetDirectChildrenEnumerator(): UnityEngine.TransformHandle.DirectChildrenEnumerator;
            public GetHashCode(): number;
            public IsValid(): boolean;
            public SetParent($p: UnityEngine.TransformHandle): void;
            public SetParent($parent: UnityEngine.TransformHandle, $worldPositionStays: boolean): void;
            public GetChild($index: number): UnityEngine.TransformHandle;
            public HasParent(): boolean;
            public IsChildOf($parent: UnityEngine.TransformHandle): boolean;
            public DetachChildren(): void;
            public SetPositionAndRotation($position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion): void;
            public SetLocalPositionAndRotation($localPosition: UnityEngine.Vector3, $localRotation: UnityEngine.Quaternion): void;
            public GetPositionAndRotation($position: $Out<UnityEngine.Vector3>, $rotation: $Out<UnityEngine.Quaternion>): void;
            public GetLocalPositionAndRotation($localPosition: $Out<UnityEngine.Vector3>, $localRotation: $Out<UnityEngine.Quaternion>): void;
            public Translate($translation: UnityEngine.Vector3, $relativeTo: UnityEngine.Space): void;
            public Translate($translation: UnityEngine.Vector3): void;
            public Translate($x: number, $y: number, $z: number, $relativeTo: UnityEngine.Space): void;
            public Translate($x: number, $y: number, $z: number): void;
            public Translate($translation: UnityEngine.Vector3, $relativeTo: UnityEngine.TransformHandle): void;
            public Translate($x: number, $y: number, $z: number, $relativeTo: UnityEngine.TransformHandle): void;
            public Rotate($eulers: UnityEngine.Vector3, $relativeTo: UnityEngine.Space): void;
            public Rotate($eulers: UnityEngine.Vector3): void;
            public Rotate($xAngle: number, $yAngle: number, $zAngle: number, $relativeTo: UnityEngine.Space): void;
            public Rotate($xAngle: number, $yAngle: number, $zAngle: number): void;
            public Rotate($axis: UnityEngine.Vector3, $angle: number, $relativeTo: UnityEngine.Space): void;
            public RotateAround($point: UnityEngine.Vector3, $axis: UnityEngine.Vector3, $angle: number): void;
            public Rotate($axis: UnityEngine.Vector3, $angle: number): void;
            public LookAt($target: UnityEngine.TransformHandle, $worldUp: UnityEngine.Vector3): void;
            public LookAt($target: UnityEngine.TransformHandle): void;
            public LookAt($worldPosition: UnityEngine.Vector3, $worldUp: UnityEngine.Vector3): void;
            public LookAt($worldPosition: UnityEngine.Vector3): void;
            public TransformPoint($x: number, $y: number, $z: number): UnityEngine.Vector3;
            public TransformPoint($point: UnityEngine.Vector3): UnityEngine.Vector3;
            public TransformPoints($positions: System.ReadOnlySpan$1<UnityEngine.Vector3>, $transformedPositions: System.Span$1<UnityEngine.Vector3>): void;
            public TransformPoints($positions: System.Span$1<UnityEngine.Vector3>): void;
            public TransformDirection($x: number, $y: number, $z: number): UnityEngine.Vector3;
            public TransformDirection($direction: UnityEngine.Vector3): UnityEngine.Vector3;
            public TransformDirections($directions: System.ReadOnlySpan$1<UnityEngine.Vector3>, $transformedDirections: System.Span$1<UnityEngine.Vector3>): void;
            public TransformDirections($directions: System.Span$1<UnityEngine.Vector3>): void;
            public TransformVector($x: number, $y: number, $z: number): UnityEngine.Vector3;
            public TransformVector($vector: UnityEngine.Vector3): UnityEngine.Vector3;
            public TransformVectors($vectors: System.ReadOnlySpan$1<UnityEngine.Vector3>, $transformedVectors: System.Span$1<UnityEngine.Vector3>): void;
            public TransformVectors($vectors: System.Span$1<UnityEngine.Vector3>): void;
            public InverseTransformPoint($x: number, $y: number, $z: number): UnityEngine.Vector3;
            public InverseTransformPoint($point: UnityEngine.Vector3): UnityEngine.Vector3;
            public InverseTransformPoints($positions: System.ReadOnlySpan$1<UnityEngine.Vector3>, $transformedPositions: System.Span$1<UnityEngine.Vector3>): void;
            public InverseTransformPoints($positions: System.Span$1<UnityEngine.Vector3>): void;
            public InverseTransformDirection($x: number, $y: number, $z: number): UnityEngine.Vector3;
            public InverseTransformDirection($direction: UnityEngine.Vector3): UnityEngine.Vector3;
            public InverseTransformDirections($directions: System.ReadOnlySpan$1<UnityEngine.Vector3>, $transformedDirections: System.Span$1<UnityEngine.Vector3>): void;
            public InverseTransformDirections($directions: System.Span$1<UnityEngine.Vector3>): void;
            public InverseTransformVector($x: number, $y: number, $z: number): UnityEngine.Vector3;
            public InverseTransformVector($vector: UnityEngine.Vector3): UnityEngine.Vector3;
            public InverseTransformVectors($vectors: System.ReadOnlySpan$1<UnityEngine.Vector3>, $transformedVectors: System.Span$1<UnityEngine.Vector3>): void;
            public InverseTransformVectors($vectors: System.Span$1<UnityEngine.Vector3>): void;
        }
        namespace TransformHandle {
            class DirectChildrenEnumerable implements System.Collections.Generic.IEnumerable$1<UnityEngine.TransformHandle>, System.Collections.IEnumerable {
                protected [__keep_incompatibility]: never;
                constructor($root: UnityEngine.TransformHandle);
                public GetEnumerator(): System.Collections.Generic.IEnumerator$1<UnityEngine.TransformHandle>;
            }

            class DirectChildrenEnumerator implements System.Collections.Generic.IEnumerator$1<UnityEngine.TransformHandle>, System.Collections.IEnumerator, System.IDisposable {
                protected [__keep_incompatibility]: never;
                public get Current(): UnityEngine.TransformHandle;
                public MoveNext(): boolean;
                public Reset(): void;
                public Dispose(): void;
            }

        }

    }
    namespace UnityEngine {
        namespace Analytics {
            enum SendEventOptions {
                kAppendNone = 0,
                kAppendBuildGuid = 1,
                kAppendBuildTarget = 2
            }

            class AnalyticsEventBase {
                protected [__keep_incompatibility]: never;
                constructor($eventName: string, $eventVersion: number, $sendEventOptions?: UnityEngine.Analytics.SendEventOptions, $eventPrefix?: string);
                constructor($e: UnityEngine.Analytics.AnalyticsEventBase);
                constructor();
                public EventName(): string;
                public EventVersion(): number;
                public EventPrefix(): string;
            }

        }
    }
    namespace UnityEngine {
        namespace Apple {
            enum FrameCaptureDestination {
                DevTools = 1,
                GPUTraceDocument = 2
            }

            class FrameCapture {
                protected [__keep_incompatibility]: never;
                public static IsDestinationSupported($dest: UnityEngine.Apple.FrameCaptureDestination): boolean;
                public static BeginCaptureToXcode(): void;
                public static BeginCaptureToFile($path: string): void;
                public static EndCapture(): void;
                public static CaptureNextFrameToXcode(): void;
                public static CaptureNextFrameToFile($path: string): void;
            }

        }
    }
    namespace UnityEngine {
        namespace Apple {
            namespace ReplayKit {
                class ReplayKit {
                    protected [__keep_incompatibility]: never;
                    public static get APIAvailable(): boolean;
                    public static get broadcastingAPIAvailable(): boolean;
                    public static get recordingAvailable(): boolean;
                    public static get isRecording(): boolean;
                    public static get isBroadcasting(): boolean;
                    public static get isBroadcastingPaused(): boolean;
                    public static get isPreviewControllerActive(): boolean;
                    public static cameraEnabled: boolean;
                    public static microphoneEnabled: boolean;
                    public static get broadcastURL(): string;
                    public static get lastError(): string;
                    public static StartRecording($enableMicrophone: boolean, $enableCamera: boolean): boolean;
                    public static StartRecording($enableMicrophone: boolean): boolean;
                    public static StartRecording(): boolean;
                    public static StartBroadcasting($callback: UnityEngine.Apple.ReplayKit.ReplayKit.BroadcastStatusCallback, $enableMicrophone: boolean, $enableCamera: boolean): void;
                    public static StartBroadcasting($callback: UnityEngine.Apple.ReplayKit.ReplayKit.BroadcastStatusCallback, $enableMicrophone: boolean): void;
                    public static StartBroadcasting($callback: UnityEngine.Apple.ReplayKit.ReplayKit.BroadcastStatusCallback): void;
                    public static StopRecording(): boolean;
                    public static StopBroadcasting(): void;
                    public static PauseBroadcasting(): void;
                    public static ResumeBroadcasting(): void;
                    public static Preview(): boolean;
                    public static Discard(): boolean;
                    public static ShowCameraPreviewAt($posX: number, $posY: number): boolean;
                    public static ShowCameraPreviewAt($posX: number, $posY: number, $width: number, $height: number): boolean;
                    public static HideCameraPreview(): void;
                }
                namespace ReplayKit {
                    interface BroadcastStatusCallback {
                        ($hasStarted: boolean, $errorMessage: string): void;
                        Invoke?: ($hasStarted: boolean, $errorMessage: string) => void;
                    }
                    var BroadcastStatusCallback: { new (func: ($hasStarted: boolean, $errorMessage: string) => void): BroadcastStatusCallback; };

                }

            }
        }
    }
    namespace UnityEngine {
        namespace Apple {
            namespace TV {
                class Remote {
                    protected [__keep_incompatibility]: never;
                    public static allowExitToHome: boolean;
                    public static allowRemoteRotation: boolean;
                    public static reportAbsoluteDpadValues: boolean;
                    public static touchesEnabled: boolean;
                    constructor();
                }

            }
        }
    }
    namespace UnityEngine {
        namespace Assertions {
            class Assert {
                protected [__keep_incompatibility]: never;
                public static raiseExceptions: boolean;
                public static IsTrue($condition: boolean): void;
                public static IsTrue($condition: boolean, $message: string): void;
                public static IsFalse($condition: boolean): void;
                public static IsFalse($condition: boolean, $message: string): void;
                public static AreApproximatelyEqual($expected: number, $actual: number): void;
                public static AreApproximatelyEqual($expected: number, $actual: number, $message: string): void;
                public static AreApproximatelyEqual($expected: number, $actual: number, $tolerance: number): void;
                public static AreApproximatelyEqual($expected: number, $actual: number, $tolerance: number, $message: string): void;
                public static AreNotApproximatelyEqual($expected: number, $actual: number): void;
                public static AreNotApproximatelyEqual($expected: number, $actual: number, $message: string): void;
                public static AreNotApproximatelyEqual($expected: number, $actual: number, $tolerance: number): void;
                public static AreNotApproximatelyEqual($expected: number, $actual: number, $tolerance: number, $message: string): void;
                public static AreEqual<T>($expected: T, $actual: T): void;
                public static AreEqual<T>($expected: T, $actual: T, $message: string): void;
                public static AreEqual<T>($expected: T, $actual: T, $message: string, $comparer: System.Collections.Generic.IEqualityComparer$1<T>): void;
                public static AreEqual($expected: UnityEngine.Object, $actual: UnityEngine.Object, $message: string): void;
                public static AreNotEqual<T>($expected: T, $actual: T): void;
                public static AreNotEqual<T>($expected: T, $actual: T, $message: string): void;
                public static AreNotEqual<T>($expected: T, $actual: T, $message: string, $comparer: System.Collections.Generic.IEqualityComparer$1<T>): void;
                public static AreNotEqual($expected: UnityEngine.Object, $actual: UnityEngine.Object, $message: string): void;
                public static IsNull<T extends object>($value: T): void;
                public static IsNull<T extends object>($value: T, $message: string): void;
                public static IsNull($value: UnityEngine.Object, $message: string): void;
                public static IsNotNull<T extends object>($value: T): void;
                public static IsNotNull<T extends object>($value: T, $message: string): void;
                public static IsNotNull($value: UnityEngine.Object, $message: string): void;
                public static AreEqual($expected: number, $actual: number): void;
                public static AreEqual($expected: number, $actual: number, $message: string): void;
                public static AreNotEqual($expected: number, $actual: number): void;
                public static AreNotEqual($expected: number, $actual: number, $message: string): void;
                public static AreEqual($expected: number, $actual: number): void;
                public static AreEqual($expected: number, $actual: number, $message: string): void;
                public static AreNotEqual($expected: number, $actual: number): void;
                public static AreNotEqual($expected: number, $actual: number, $message: string): void;
                public static AreEqual($expected: number, $actual: number): void;
                public static AreEqual($expected: number, $actual: number, $message: string): void;
                public static AreNotEqual($expected: number, $actual: number): void;
                public static AreNotEqual($expected: number, $actual: number, $message: string): void;
                public static AreEqual($expected: number, $actual: number): void;
                public static AreEqual($expected: number, $actual: number, $message: string): void;
                public static AreNotEqual($expected: number, $actual: number): void;
                public static AreNotEqual($expected: number, $actual: number, $message: string): void;
                public static AreEqual($expected: number, $actual: number): void;
                public static AreEqual($expected: number, $actual: number, $message: string): void;
                public static AreNotEqual($expected: number, $actual: number): void;
                public static AreNotEqual($expected: number, $actual: number, $message: string): void;
                public static AreEqual($expected: number, $actual: number): void;
                public static AreEqual($expected: number, $actual: number, $message: string): void;
                public static AreNotEqual($expected: number, $actual: number): void;
                public static AreNotEqual($expected: number, $actual: number, $message: string): void;
                public static AreEqual($expected: number, $actual: number): void;
                public static AreEqual($expected: number, $actual: number, $message: string): void;
                public static AreNotEqual($expected: number, $actual: number): void;
                public static AreNotEqual($expected: number, $actual: number, $message: string): void;
                public static AreEqual($expected: bigint, $actual: bigint): void;
                public static AreEqual($expected: bigint, $actual: bigint, $message: string): void;
                public static AreNotEqual($expected: bigint, $actual: bigint): void;
                public static AreNotEqual($expected: bigint, $actual: bigint, $message: string): void;
                public static AreEqual($expected: bigint, $actual: bigint): void;
                public static AreEqual($expected: bigint, $actual: bigint, $message: string): void;
                public static AreNotEqual($expected: bigint, $actual: bigint): void;
                public static AreNotEqual($expected: bigint, $actual: bigint, $message: string): void;
            }

            class AssertionException extends System.Exception {
                protected [__keep_incompatibility]: never;
                public get Message(): string;
                constructor($message: string, $userMessage: string);
            }

        }
    }
    namespace UnityEngine {
        namespace Assertions {
            namespace Comparers {
                class FloatComparer implements System.Collections.Generic.IEqualityComparer$1<number> {
                    protected [__keep_incompatibility]: never;
                    public static readonly s_ComparerWithDefaultTolerance: UnityEngine.Assertions.Comparers.FloatComparer;
                    public static readonly kEpsilon: number;
                    constructor();
                    constructor($relative: boolean);
                    constructor($error: number);
                    constructor($error: number, $relative: boolean);
                    public Equals($a: number, $b: number): boolean;
                    public GetHashCode($obj: number): number;
                    public static AreEqual($expected: number, $actual: number, $error: number): boolean;
                    public static AreEqualRelative($expected: number, $actual: number, $error: number): boolean;
                }

            }
        }
    }
    namespace UnityEngine {
        namespace Assertions {
            namespace Must {
                class MustExtensions {
                    protected [__keep_incompatibility]: never;
                    public static MustBeTrue(): void;
                    public static MustBeTrue($message: string): void;
                    public static MustBeFalse(): void;
                    public static MustBeFalse($message: string): void;
                    public static MustBeApproximatelyEqual($expected: number): void;
                    public static MustBeApproximatelyEqual($expected: number, $message: string): void;
                    public static MustBeApproximatelyEqual($expected: number, $tolerance: number): void;
                    public static MustBeApproximatelyEqual($expected: number, $tolerance: number, $message: string): void;
                    public static MustNotBeApproximatelyEqual($expected: number): void;
                    public static MustNotBeApproximatelyEqual($expected: number, $message: string): void;
                    public static MustNotBeApproximatelyEqual($expected: number, $tolerance: number): void;
                    public static MustNotBeApproximatelyEqual($expected: number, $tolerance: number, $message: string): void;
                    public static MustBeEqual<T>($expected: T): void;
                    public static MustBeEqual<T>($expected: T, $message: string): void;
                    public static MustNotBeEqual<T>($expected: T): void;
                    public static MustNotBeEqual<T>($expected: T, $message: string): void;
                    public static MustBeNull<T extends object>(): void;
                    public static MustBeNull<T extends object>($message: string): void;
                    public static MustNotBeNull<T extends object>(): void;
                    public static MustNotBeNull<T extends object>($message: string): void;
                }

            }
        }
    }
    namespace UnityEngine {
        namespace Categorization {
            class ElementInfoAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public Order: number;
                public Name: string;
                constructor();
            }

            class CategoryInfoAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public Order: number;
                public Name: string;
                constructor();
            }

        }
    }
    namespace UnityEngine {
        namespace DedicatedServer {
            class Arguments {
                protected [__keep_incompatibility]: never;
                public static Port: number | null;
                public static TargetFramerate: number | null;
                public static LogLevel: number | null;
                public static LogPath: string;
                public static QueryPort: number | null;
                public static QueryType: string;
                public static ErrorPolicy: UnityEngine.DedicatedServer.Arguments.ArgumentErrorPolicy;
            }
            namespace Arguments {
                enum ArgumentErrorPolicy {
                    Ignore = 0,
                    Warn = 1,
                    Fatal = 2
                }

            }

        }
    }
    namespace UnityEngine {
        namespace Device {
            class Application {
                protected [__keep_incompatibility]: never;
                public static get absoluteURL(): string;
                public static backgroundLoadingPriority: UnityEngine.ThreadPriority;
                public static get buildGUID(): string;
                public static get cloudProjectId(): string;
                public static get companyName(): string;
                public static get consoleLogPath(): string;
                public static get dataPath(): string;
                public static get genuine(): boolean;
                public static get genuineCheckAvailable(): boolean;
                public static get identifier(): string;
                public static get installerName(): string;
                public static get installMode(): UnityEngine.ApplicationInstallMode;
                public static get internetReachability(): UnityEngine.NetworkReachability;
                public static get isBatchMode(): boolean;
                public static get isConsolePlatform(): boolean;
                public static get isEditor(): boolean;
                public static get isFocused(): boolean;
                public static get isMobilePlatform(): boolean;
                public static get isPlaying(): boolean;
                public static get persistentDataPath(): string;
                public static get platform(): UnityEngine.RuntimePlatform;
                public static get productName(): string;
                public static runInBackground: boolean;
                public static get sandboxType(): UnityEngine.ApplicationSandboxType;
                public static get streamingAssetsPath(): string;
                public static get systemLanguage(): UnityEngine.SystemLanguage;
                public static targetFrameRate: number;
                public static get temporaryCachePath(): string;
                public static get unityVersion(): string;
                public static get version(): string;
                public static get exitCancellationToken(): System.Threading.CancellationToken;
                public static CanStreamedLevelBeLoaded($levelIndex: number): boolean;
                public static CanStreamedLevelBeLoaded($levelName: string): boolean;
                public static GetBuildTags(): System.Array$1<string>;
                public static GetStackTraceLogType($logType: UnityEngine.LogType): UnityEngine.StackTraceLogType;
                public static HasProLicense(): boolean;
                public static HasUserAuthorization($mode: UnityEngine.UserAuthorization): boolean;
                public static IsPlaying($obj: UnityEngine.Object): boolean;
                public static OpenURL($url: string): void;
                public static Quit(): void;
                public static Quit($exitCode: number): void;
                public static RequestAdvertisingIdentifierAsync($delegateMethod: UnityEngine.Application.AdvertisingIdentifierCallback): boolean;
                public static RequestUserAuthorization($mode: UnityEngine.UserAuthorization): UnityEngine.AsyncOperation;
                public static SetBuildTags($buildTags: System.Array$1<string>): void;
                public static SetStackTraceLogType($logType: UnityEngine.LogType, $stackTraceType: UnityEngine.StackTraceLogType): void;
                public static Unload(): void;
                public static add_deepLinkActivated(handler: System.Action$1<string>): void;
                public static remove_deepLinkActivated(handler: System.Action$1<string>): void;
                public static add_focusChanged(handler: System.Action$1<boolean>): void;
                public static remove_focusChanged(handler: System.Action$1<boolean>): void;
                public static add_logMessageReceived(handler: UnityEngine.Application.LogCallback): void;
                public static remove_logMessageReceived(handler: UnityEngine.Application.LogCallback): void;
                public static add_logMessageReceivedThreaded(handler: UnityEngine.Application.LogCallback): void;
                public static remove_logMessageReceivedThreaded(handler: UnityEngine.Application.LogCallback): void;
                public static add_lowMemory(handler: UnityEngine.Application.LowMemoryCallback): void;
                public static remove_lowMemory(handler: UnityEngine.Application.LowMemoryCallback): void;
                public static add_memoryUsageChanged(handler: UnityEngine.Application.MemoryUsageChangedCallback): void;
                public static remove_memoryUsageChanged(handler: UnityEngine.Application.MemoryUsageChangedCallback): void;
                public static add_onBeforeRender(handler: UnityEngine.Events.UnityAction): void;
                public static remove_onBeforeRender(handler: UnityEngine.Events.UnityAction): void;
                public static add_quitting(handler: System.Action): void;
                public static remove_quitting(handler: System.Action): void;
                public static add_wantsToQuit(handler: System.Func$1<boolean>): void;
                public static remove_wantsToQuit(handler: System.Func$1<boolean>): void;
                public static add_unloading(handler: System.Action): void;
                public static remove_unloading(handler: System.Action): void;
            }

            class Screen {
                protected [__keep_incompatibility]: never;
                public static autorotateToLandscapeLeft: boolean;
                public static autorotateToLandscapeRight: boolean;
                public static autorotateToPortrait: boolean;
                public static autorotateToPortraitUpsideDown: boolean;
                public static get currentResolution(): UnityEngine.Resolution;
                public static get cutouts(): System.Array$1<UnityEngine.Rect>;
                public static get dpi(): number;
                public static fullScreen: boolean;
                public static fullScreenMode: UnityEngine.FullScreenMode;
                public static get height(): number;
                public static get width(): number;
                public static orientation: UnityEngine.ScreenOrientation;
                public static get resolutions(): System.Array$1<UnityEngine.Resolution>;
                public static get safeArea(): UnityEngine.Rect;
                public static sleepTimeout: number;
                public static brightness: number;
                public static get mainWindowPosition(): UnityEngine.Vector2Int;
                public static get mainWindowDisplayInfo(): UnityEngine.DisplayInfo;
                public static get msaaSamples(): number;
                public static SetResolution($width: number, $height: number, $fullscreenMode: UnityEngine.FullScreenMode, $preferredRefreshRate: UnityEngine.RefreshRate): void;
                public static SetResolution($width: number, $height: number, $fullscreenMode: UnityEngine.FullScreenMode, $preferredRefreshRate: number): void;
                public static SetResolution($width: number, $height: number, $fullscreenMode: UnityEngine.FullScreenMode): void;
                public static SetResolution($width: number, $height: number, $fullscreen: boolean, $preferredRefreshRate: number): void;
                public static SetResolution($width: number, $height: number, $fullscreen: boolean): void;
                public static GetDisplayLayout($displayLayout: System.Collections.Generic.List$1<UnityEngine.DisplayInfo>): void;
                public static MoveMainWindowTo($display: $Ref<UnityEngine.DisplayInfo>, $position: UnityEngine.Vector2Int): UnityEngine.AsyncOperation;
                public static SetMSAASamples($numSamples: number): void;
            }

            class SystemInfo {
                protected [__keep_incompatibility]: never;
                public static readonly unsupportedIdentifier: string;
                public static get batteryLevel(): number;
                public static get batteryStatus(): UnityEngine.BatteryStatus;
                public static get operatingSystem(): string;
                public static get operatingSystemFamily(): UnityEngine.OperatingSystemFamily;
                public static get processorType(): string;
                public static get processorModel(): string;
                public static get processorManufacturer(): string;
                public static get processorFrequency(): number;
                public static get processorCount(): number;
                public static get systemMemorySize(): number;
                public static get deviceUniqueIdentifier(): string;
                public static get deviceName(): string;
                public static get deviceModel(): string;
                public static get supportsAccelerometer(): boolean;
                public static get supportsGyroscope(): boolean;
                public static get supportsLocationService(): boolean;
                public static get supportsVibration(): boolean;
                public static get supportsAudio(): boolean;
                public static get supportsRendering(): boolean;
                public static get deviceType(): UnityEngine.DeviceType;
                public static get graphicsMemorySize(): number;
                public static get graphicsDeviceName(): string;
                public static get graphicsDeviceVendor(): string;
                public static get graphicsDeviceID(): number;
                public static get graphicsDeviceVendorID(): number;
                public static get graphicsDeviceType(): UnityEngine.Rendering.GraphicsDeviceType;
                public static get graphicsUVStartsAtTop(): boolean;
                public static get graphicsDeviceVersion(): string;
                public static get graphicsShaderLevel(): number;
                public static get graphicsMultiThreaded(): boolean;
                public static get renderingThreadingMode(): UnityEngine.Rendering.RenderingThreadingMode;
                public static get foveatedRenderingCaps(): UnityEngine.Rendering.FoveatedRenderingCaps;
                public static get supportsVariableRateShading(): boolean;
                public static get maxTiledPixelStorageSize(): number;
                public static get hasTiledGPU(): boolean;
                public static get hasHiddenSurfaceRemovalOnGPU(): boolean;
                public static get hasDynamicUniformArrayIndexingInFragmentShaders(): boolean;
                public static get supportsShadows(): boolean;
                public static get supportsRawShadowDepthSampling(): boolean;
                public static get supportsMotionVectors(): boolean;
                public static get supports3DTextures(): boolean;
                public static get supportsCompressed3DTextures(): boolean;
                public static get supports2DArrayTextures(): boolean;
                public static get supports3DRenderTextures(): boolean;
                public static get supportsCubemapArrayTextures(): boolean;
                public static get supportsAnisotropicFilter(): boolean;
                public static get copyTextureSupport(): UnityEngine.Rendering.CopyTextureSupport;
                public static get supportsComputeShaders(): boolean;
                public static get supportsGeometryShaders(): boolean;
                public static get supportsTessellationShaders(): boolean;
                public static get supportsRenderTargetArrayIndexFromVertexShader(): boolean;
                public static get supportsInstancing(): boolean;
                public static get supportsHardwareQuadTopology(): boolean;
                public static get supports32bitsIndexBuffer(): boolean;
                public static get supportsSparseTextures(): boolean;
                public static get supportedRenderTargetCount(): number;
                public static get supportsSeparatedRenderTargetsBlend(): boolean;
                public static get supportedRandomWriteTargetCount(): number;
                public static get supportsMultisampledTextures(): number;
                public static get supportsMultisampled2DArrayTextures(): boolean;
                public static get supportsMultisampledBackBuffer(): boolean;
                public static get supportsMultisampleAutoResolve(): boolean;
                public static get supportsMultisampledShaderResolve(): boolean;
                public static get supportsTextureWrapMirrorOnce(): number;
                public static get usesReversedZBuffer(): boolean;
                public static get npotSupport(): UnityEngine.NPOTSupport;
                public static get maxTextureSize(): number;
                public static get maxTexture3DSize(): number;
                public static get maxTextureArraySlices(): number;
                public static get maxCubemapSize(): number;
                public static get maxAnisotropyLevel(): number;
                public static get maxComputeBufferInputsVertex(): number;
                public static get maxComputeBufferInputsFragment(): number;
                public static get maxComputeBufferInputsGeometry(): number;
                public static get maxComputeBufferInputsDomain(): number;
                public static get maxComputeBufferInputsHull(): number;
                public static get maxComputeBufferInputsCompute(): number;
                public static get maxComputeWorkGroupSize(): number;
                public static get maxComputeWorkGroupSizeX(): number;
                public static get maxComputeWorkGroupSizeY(): number;
                public static get maxComputeWorkGroupSizeZ(): number;
                public static get computeSubGroupSize(): number;
                public static get supportsAsyncCompute(): boolean;
                public static get supportsGpuRecorder(): boolean;
                public static get supportsGraphicsFence(): boolean;
                public static get supportsAsyncGPUReadback(): boolean;
                public static get supportsParallelPSOCreation(): boolean;
                public static get supportsRayTracingShaders(): boolean;
                public static get supportsRayTracing(): boolean;
                public static get supportsInlineRayTracing(): boolean;
                public static get supportsIndirectDispatchRays(): boolean;
                public static get supportsMachineLearning(): boolean;
                public static get supportsMemorylessTextures(): boolean;
                public static get supportsSetConstantBuffer(): boolean;
                public static get constantBufferOffsetAlignment(): number;
                public static get maxConstantBufferSize(): number;
                public static get maxGraphicsBufferSize(): bigint;
                public static get hasMipMaxLevel(): boolean;
                public static get supportsMipStreaming(): boolean;
                public static get usesLoadStoreActions(): boolean;
                public static get hdrDisplaySupportFlags(): UnityEngine.HDRDisplaySupportFlags;
                public static get supportsConservativeRaster(): boolean;
                public static get supportsMultiview(): boolean;
                public static get supportsStoreAndResolveAction(): boolean;
                public static get supportsMultisampleResolveDepth(): boolean;
                public static get supportsMultisampleResolveStencil(): boolean;
                public static get supportsIndirectArgumentsBuffer(): boolean;
                public static get supportsDepthFetchInRenderPass(): boolean;
                public static get supportsDynamicResolution(): boolean;
                public static SupportsRenderTextureFormat($format: UnityEngine.RenderTextureFormat): boolean;
                public static SupportsBlendingOnRenderTextureFormat($format: UnityEngine.RenderTextureFormat): boolean;
                public static SupportsTextureFormat($format: UnityEngine.TextureFormat): boolean;
                public static SupportsVertexAttributeFormat($format: UnityEngine.Rendering.VertexAttributeFormat, $dimension: number): boolean;
                public static IsFormatSupported($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.FormatUsage): boolean;
                public static IsFormatSupported($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.GraphicsFormatUsage): boolean;
                public static GetCompatibleFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.FormatUsage): UnityEngine.Experimental.Rendering.GraphicsFormat;
                public static GetCompatibleFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $usage: UnityEngine.Experimental.Rendering.GraphicsFormatUsage): UnityEngine.Experimental.Rendering.GraphicsFormat;
                public static GetGraphicsFormat($format: UnityEngine.Experimental.Rendering.DefaultFormat): UnityEngine.Experimental.Rendering.GraphicsFormat;
                public static GetRenderTextureSupportedMSAASampleCount($desc: UnityEngine.RenderTextureDescriptor): number;
                public static SupportsRandomWriteOnRenderTextureFormat($format: UnityEngine.RenderTextureFormat): boolean;
                public static GetTiledRenderTargetStorageSize($format: UnityEngine.Experimental.Rendering.GraphicsFormat, $sampleCount: number): number;
            }

        }
    }
    namespace UnityEngine {
        namespace Diagnostics {
            enum ForcedCrashCategory {
                AccessViolation = 0,
                FatalError = 1,
                Abort = 2,
                PureVirtualFunction = 3,
                MonoAbort = 4
            }

            class Utils {
                protected [__keep_incompatibility]: never;
                public static ForceCrash($crashCategory: UnityEngine.Diagnostics.ForcedCrashCategory): void;
                public static NativeAssert($message: string): void;
                public static NativeError($message: string): void;
                public static NativeWarning($message: string): void;
                public static ValidateHeap(): void;
            }

            class PlayerConnection {
                protected [__keep_incompatibility]: never;
                public static get connected(): boolean;
            }

        }
    }
    namespace UnityEngine {
        namespace Events {
            enum PersistentListenerMode {
                EventDefined = 0,
                Void = 1,
                Object = 2,
                Int = 3,
                Float = 4,
                String = 5,
                Bool = 6
            }

            enum UnityEventCallState {
                Off = 0,
                EditorAndRuntime = 1,
                RuntimeOnly = 2
            }

            class UnityEventBase implements UnityEngine.ISerializationCallbackReceiver {
                protected [__keep_incompatibility]: never;
                public GetPersistentEventCount(): number;
                public GetPersistentTarget($index: number): UnityEngine.Object;
                public GetPersistentMethodName($index: number): string;
                public SetPersistentListenerState($index: number, $state: UnityEngine.Events.UnityEventCallState): void;
                public GetPersistentListenerState($index: number): UnityEngine.Events.UnityEventCallState;
                public RemoveAllListeners(): void;
                public ToString(): string;
                public static GetValidMethodInfo($obj: any, $functionName: string, $argumentTypes: System.Array$1<System.Type>): System.Reflection.MethodInfo;
                public static GetValidMethodInfo($objectType: System.Type, $functionName: string, $argumentTypes: System.Array$1<System.Type>): System.Reflection.MethodInfo;
            }

            interface UnityAction {
                (): void;
                Invoke?: () => void;
            }
            var UnityAction: { new (func: () => void): UnityAction; };

            class UnityEvent extends UnityEngine.Events.UnityEventBase {
                protected [__keep_incompatibility]: never;
                constructor();
                public AddListener($call: UnityEngine.Events.UnityAction): void;
                public RemoveListener($call: UnityEngine.Events.UnityAction): void;
                public Invoke(): void;
            }

            interface UnityAction<T0> {
                ($arg0: T0): void;
                Invoke?: ($arg0: T0) => void;
            }

            class UnityEvent<T0> extends UnityEngine.Events.UnityEventBase {
                protected [__keep_incompatibility]: never;
                constructor();
                public AddListener($call: UnityEngine.Events.UnityAction$1<T0>): void;
                public RemoveListener($call: UnityEngine.Events.UnityAction$1<T0>): void;
                public Invoke($arg0: T0): void;
            }

            interface UnityAction<T0, T1> {
                ($arg0: T0, $arg1: T1): void;
                Invoke?: ($arg0: T0, $arg1: T1) => void;
            }

            class UnityEvent<T0, T1> extends UnityEngine.Events.UnityEventBase {
                protected [__keep_incompatibility]: never;
                constructor();
                public AddListener($call: UnityEngine.Events.UnityAction$2<T0, T1>): void;
                public RemoveListener($call: UnityEngine.Events.UnityAction$2<T0, T1>): void;
                public Invoke($arg0: T0, $arg1: T1): void;
            }

            interface UnityAction<T0, T1, T2> {
                ($arg0: T0, $arg1: T1, $arg2: T2): void;
                Invoke?: ($arg0: T0, $arg1: T1, $arg2: T2) => void;
            }

            class UnityEvent<T0, T1, T2> extends UnityEngine.Events.UnityEventBase {
                protected [__keep_incompatibility]: never;
                constructor();
                public AddListener($call: UnityEngine.Events.UnityAction$3<T0, T1, T2>): void;
                public RemoveListener($call: UnityEngine.Events.UnityAction$3<T0, T1, T2>): void;
                public Invoke($arg0: T0, $arg1: T1, $arg2: T2): void;
            }

            interface UnityAction<T0, T1, T2, T3> {
                ($arg0: T0, $arg1: T1, $arg2: T2, $arg3: T3): void;
                Invoke?: ($arg0: T0, $arg1: T1, $arg2: T2, $arg3: T3) => void;
            }

            class UnityEvent<T0, T1, T2, T3> extends UnityEngine.Events.UnityEventBase {
                protected [__keep_incompatibility]: never;
                constructor();
                public AddListener($call: UnityEngine.Events.UnityAction$4<T0, T1, T2, T3>): void;
                public RemoveListener($call: UnityEngine.Events.UnityAction$4<T0, T1, T2, T3>): void;
                public Invoke($arg0: T0, $arg1: T1, $arg2: T2, $arg3: T3): void;
            }

        }
    }
    namespace UnityEngine {
        namespace Experimental {
            namespace GlobalIllumination {
                enum LightType {
                    Directional = 0,
                    Point = 1,
                    Spot = 2,
                    Rectangle = 3,
                    Disc = 4,
                    SpotPyramidShape = 5,
                    SpotBoxShape = 6
                }

                enum LightMode {
                    Realtime = 0,
                    Mixed = 1,
                    Baked = 2,
                    Unknown = 3
                }

                enum FalloffType {
                    InverseSquared = 0,
                    InverseSquaredNoRangeAttenuation = 1,
                    Linear = 2,
                    Legacy = 3,
                    Undefined = 4
                }

                enum AngularFalloffType {
                    LUT = 0,
                    AnalyticAndInnerAngle = 1
                }

                class LinearColor {
                    protected [__keep_incompatibility]: never;
                    public red: number;
                    public green: number;
                    public blue: number;
                    public intensity: number;
                    public static Convert($color: UnityEngine.Color, $intensity: number): UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public static Black(): UnityEngine.Experimental.GlobalIllumination.LinearColor;
                }

                class DirectionalLight {
                    protected [__keep_incompatibility]: never;
                    public entityId: UnityEngine.EntityId;
                    public shadow: boolean;
                    public mode: UnityEngine.Experimental.GlobalIllumination.LightMode;
                    public position: UnityEngine.Vector3;
                    public orientation: UnityEngine.Quaternion;
                    public color: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public indirectColor: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public penumbraWidthRadian: number;
                    public instanceID: number;
                }

                class PointLight {
                    protected [__keep_incompatibility]: never;
                    public entityId: UnityEngine.EntityId;
                    public shadow: boolean;
                    public mode: UnityEngine.Experimental.GlobalIllumination.LightMode;
                    public position: UnityEngine.Vector3;
                    public orientation: UnityEngine.Quaternion;
                    public color: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public indirectColor: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public range: number;
                    public sphereRadius: number;
                    public falloff: UnityEngine.Experimental.GlobalIllumination.FalloffType;
                    public instanceID: number;
                }

                class SpotLight {
                    protected [__keep_incompatibility]: never;
                    public entityId: UnityEngine.EntityId;
                    public shadow: boolean;
                    public mode: UnityEngine.Experimental.GlobalIllumination.LightMode;
                    public position: UnityEngine.Vector3;
                    public orientation: UnityEngine.Quaternion;
                    public color: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public indirectColor: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public range: number;
                    public sphereRadius: number;
                    public coneAngle: number;
                    public innerConeAngle: number;
                    public falloff: UnityEngine.Experimental.GlobalIllumination.FalloffType;
                    public angularFalloff: UnityEngine.Experimental.GlobalIllumination.AngularFalloffType;
                    public instanceID: number;
                }

                class RectangleLight {
                    protected [__keep_incompatibility]: never;
                    public entityId: UnityEngine.EntityId;
                    public shadow: boolean;
                    public mode: UnityEngine.Experimental.GlobalIllumination.LightMode;
                    public position: UnityEngine.Vector3;
                    public orientation: UnityEngine.Quaternion;
                    public color: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public indirectColor: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public range: number;
                    public width: number;
                    public height: number;
                    public falloff: UnityEngine.Experimental.GlobalIllumination.FalloffType;
                    public instanceID: number;
                }

                class DiscLight {
                    protected [__keep_incompatibility]: never;
                    public entityId: UnityEngine.EntityId;
                    public shadow: boolean;
                    public mode: UnityEngine.Experimental.GlobalIllumination.LightMode;
                    public position: UnityEngine.Vector3;
                    public orientation: UnityEngine.Quaternion;
                    public color: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public indirectColor: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public range: number;
                    public radius: number;
                    public falloff: UnityEngine.Experimental.GlobalIllumination.FalloffType;
                    public instanceID: number;
                }

                class SpotLightBoxShape {
                    protected [__keep_incompatibility]: never;
                    public entityId: UnityEngine.EntityId;
                    public shadow: boolean;
                    public mode: UnityEngine.Experimental.GlobalIllumination.LightMode;
                    public position: UnityEngine.Vector3;
                    public orientation: UnityEngine.Quaternion;
                    public color: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public indirectColor: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public range: number;
                    public width: number;
                    public height: number;
                    public instanceID: number;
                }

                class SpotLightPyramidShape {
                    protected [__keep_incompatibility]: never;
                    public entityId: UnityEngine.EntityId;
                    public shadow: boolean;
                    public mode: UnityEngine.Experimental.GlobalIllumination.LightMode;
                    public position: UnityEngine.Vector3;
                    public orientation: UnityEngine.Quaternion;
                    public color: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public indirectColor: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public range: number;
                    public angle: number;
                    public aspectRatio: number;
                    public falloff: UnityEngine.Experimental.GlobalIllumination.FalloffType;
                    public instanceID: number;
                }

                class Cookie {
                    protected [__keep_incompatibility]: never;
                    public entityId: UnityEngine.EntityId;
                    public scale: number;
                    public sizes: UnityEngine.Vector2;
                    public instanceID: number;
                    public static Defaults(): UnityEngine.Experimental.GlobalIllumination.Cookie;
                }

                class LightDataGI {
                    protected [__keep_incompatibility]: never;
                    public entityId: UnityEngine.EntityId;
                    public cookieTextureEntityId: UnityEngine.EntityId;
                    public cookieScale: number;
                    public color: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public indirectColor: UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public orientation: UnityEngine.Quaternion;
                    public position: UnityEngine.Vector3;
                    public range: number;
                    public coneAngle: number;
                    public innerConeAngle: number;
                    public shape0: number;
                    public shape1: number;
                    public type: UnityEngine.Experimental.GlobalIllumination.LightType;
                    public mode: UnityEngine.Experimental.GlobalIllumination.LightMode;
                    public shadow: number;
                    public falloff: UnityEngine.Experimental.GlobalIllumination.FalloffType;
                    public instanceID: number;
                    public cookieID: number;
                    public Init($light: $Ref<UnityEngine.Experimental.GlobalIllumination.DirectionalLight>, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>): void;
                    public Init($light: $Ref<UnityEngine.Experimental.GlobalIllumination.PointLight>, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>): void;
                    public Init($light: $Ref<UnityEngine.Experimental.GlobalIllumination.SpotLight>, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>): void;
                    public Init($light: $Ref<UnityEngine.Experimental.GlobalIllumination.RectangleLight>, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>): void;
                    public Init($light: $Ref<UnityEngine.Experimental.GlobalIllumination.DiscLight>, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>): void;
                    public Init($light: $Ref<UnityEngine.Experimental.GlobalIllumination.SpotLightBoxShape>, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>): void;
                    public Init($light: $Ref<UnityEngine.Experimental.GlobalIllumination.SpotLightPyramidShape>, $cookie: $Ref<UnityEngine.Experimental.GlobalIllumination.Cookie>): void;
                    public Init($light: $Ref<UnityEngine.Experimental.GlobalIllumination.DirectionalLight>): void;
                    public Init($light: $Ref<UnityEngine.Experimental.GlobalIllumination.PointLight>): void;
                    public Init($light: $Ref<UnityEngine.Experimental.GlobalIllumination.SpotLight>): void;
                    public Init($light: $Ref<UnityEngine.Experimental.GlobalIllumination.RectangleLight>): void;
                    public Init($light: $Ref<UnityEngine.Experimental.GlobalIllumination.DiscLight>): void;
                    public Init($light: $Ref<UnityEngine.Experimental.GlobalIllumination.SpotLightBoxShape>): void;
                    public Init($light: $Ref<UnityEngine.Experimental.GlobalIllumination.SpotLightPyramidShape>): void;
                    public InitNoBake($lightEntityId: UnityEngine.EntityId): void;
                    public InitNoBake($lightInstanceID: number): void;
                }

                class LightmapperUtils {
                    protected [__keep_incompatibility]: never;
                    public static Extract($baketype: UnityEngine.LightmapBakeType): UnityEngine.Experimental.GlobalIllumination.LightMode;
                    public static ExtractIndirect($l: UnityEngine.Light): UnityEngine.Experimental.GlobalIllumination.LinearColor;
                    public static ExtractInnerCone($l: UnityEngine.Light): number;
                    public static Extract($l: UnityEngine.Light, $dir: $Ref<UnityEngine.Experimental.GlobalIllumination.DirectionalLight>): void;
                    public static Extract($l: UnityEngine.Light, $point: $Ref<UnityEngine.Experimental.GlobalIllumination.PointLight>): void;
                    public static Extract($l: UnityEngine.Light, $spot: $Ref<UnityEngine.Experimental.GlobalIllumination.SpotLight>): void;
                    public static Extract($l: UnityEngine.Light, $rect: $Ref<UnityEngine.Experimental.GlobalIllumination.RectangleLight>): void;
                    public static Extract($l: UnityEngine.Light, $disc: $Ref<UnityEngine.Experimental.GlobalIllumination.DiscLight>): void;
                    public static Extract($l: UnityEngine.Light, $cookie: $Out<UnityEngine.Experimental.GlobalIllumination.Cookie>): void;
                }

                class Lightmapping {
                    protected [__keep_incompatibility]: never;
                    public static SetDelegate($del: UnityEngine.Experimental.GlobalIllumination.Lightmapping.RequestLightsDelegate): void;
                    public static GetDelegate(): UnityEngine.Experimental.GlobalIllumination.Lightmapping.RequestLightsDelegate;
                    public static ResetDelegate(): void;
                }
                namespace Lightmapping {
                    interface RequestLightsDelegate {
                        ($requests: System.Array$1<UnityEngine.Light>, $lightsOutput: Unity.Collections.NativeArray$1<UnityEngine.Experimental.GlobalIllumination.LightDataGI>): void;
                        Invoke?: ($requests: System.Array$1<UnityEngine.Light>, $lightsOutput: Unity.Collections.NativeArray$1<UnityEngine.Experimental.GlobalIllumination.LightDataGI>) => void;
                    }
                    var RequestLightsDelegate: { new (func: ($requests: System.Array$1<UnityEngine.Light>, $lightsOutput: Unity.Collections.NativeArray$1<UnityEngine.Experimental.GlobalIllumination.LightDataGI>) => void): RequestLightsDelegate; };

                }

                class RenderSettings {
                    protected [__keep_incompatibility]: never;
                    public static useRadianceAmbientProbe: boolean;
                    constructor();
                }

            }
        }
    }
    namespace UnityEngine {
        namespace Experimental {
            namespace Playables {
                class CameraPlayable implements System.IEquatable$1<UnityEngine.Experimental.Playables.CameraPlayable>, UnityEngine.Playables.IPlayable {
                    protected [__keep_incompatibility]: never;
                    public static Create($graph: UnityEngine.Playables.PlayableGraph, $camera: UnityEngine.Camera): UnityEngine.Experimental.Playables.CameraPlayable;
                    public GetHandle(): UnityEngine.Playables.PlayableHandle;
                    public Equals($other: UnityEngine.Experimental.Playables.CameraPlayable): boolean;
                    public GetCamera(): UnityEngine.Camera;
                    public SetCamera($value: UnityEngine.Camera): void;
                }

                class MaterialEffectPlayable implements System.IEquatable$1<UnityEngine.Experimental.Playables.MaterialEffectPlayable>, UnityEngine.Playables.IPlayable {
                    protected [__keep_incompatibility]: never;
                    public static Create($graph: UnityEngine.Playables.PlayableGraph, $material: UnityEngine.Material, $pass?: number): UnityEngine.Experimental.Playables.MaterialEffectPlayable;
                    public GetHandle(): UnityEngine.Playables.PlayableHandle;
                    public Equals($other: UnityEngine.Experimental.Playables.MaterialEffectPlayable): boolean;
                    public GetMaterial(): UnityEngine.Material;
                    public SetMaterial($value: UnityEngine.Material): void;
                    public GetPass(): number;
                    public SetPass($value: number): void;
                }

                class TextureMixerPlayable implements System.IEquatable$1<UnityEngine.Experimental.Playables.TextureMixerPlayable>, UnityEngine.Playables.IPlayable {
                    protected [__keep_incompatibility]: never;
                    public static Create($graph: UnityEngine.Playables.PlayableGraph): UnityEngine.Experimental.Playables.TextureMixerPlayable;
                    public GetHandle(): UnityEngine.Playables.PlayableHandle;
                    public Equals($other: UnityEngine.Experimental.Playables.TextureMixerPlayable): boolean;
                }

                class TexturePlayableBinding {
                    protected [__keep_incompatibility]: never;
                    public static Create($name: string, $key: UnityEngine.Object): UnityEngine.Playables.PlayableBinding;
                }

                class TexturePlayableOutput implements UnityEngine.Playables.IPlayableOutput {
                    protected [__keep_incompatibility]: never;
                    public static get Null(): UnityEngine.Experimental.Playables.TexturePlayableOutput;
                    public static Create($graph: UnityEngine.Playables.PlayableGraph, $name: string, $target: UnityEngine.RenderTexture): UnityEngine.Experimental.Playables.TexturePlayableOutput;
                    public GetHandle(): UnityEngine.Playables.PlayableOutputHandle;
                    public GetTarget(): UnityEngine.RenderTexture;
                    public SetTarget($value: UnityEngine.RenderTexture): void;
                }

            }
        }
    }
    namespace UnityEngine {
        namespace Experimental {
            namespace Rendering {
                interface IScriptableRuntimeReflectionSystem extends System.IDisposable {
                    TickRealtimeProbes(): boolean;
                }

                class ScriptableRuntimeReflectionSystem implements UnityEngine.Experimental.Rendering.IScriptableRuntimeReflectionSystem, System.IDisposable {
                    protected [__keep_incompatibility]: never;
                    public TickRealtimeProbes(): boolean;
                }

                class ScriptableRuntimeReflectionSystemSettings {
                    protected [__keep_incompatibility]: never;
                    public static system: UnityEngine.Experimental.Rendering.IScriptableRuntimeReflectionSystem;
                }

                class ExternalGPUProfiler {
                    protected [__keep_incompatibility]: never;
                    public static BeginGPUCapture(): void;
                    public static EndGPUCapture(): void;
                    public static IsAttached(): boolean;
                }

                enum WaitForPresentSyncPoint {
                    BeginFrame = 0,
                    EndFrame = 1
                }

                enum GraphicsJobsSyncPoint {
                    EndOfFrame = 0,
                    AfterScriptUpdate = 1,
                    AfterScriptLateUpdate = 2,
                    WaitForPresent = 3
                }

                class GraphicsDeviceSettings {
                    protected [__keep_incompatibility]: never;
                    public static waitForPresentSyncPoint: UnityEngine.Experimental.Rendering.WaitForPresentSyncPoint;
                    public static graphicsJobsSyncPoint: UnityEngine.Experimental.Rendering.GraphicsJobsSyncPoint;
                }

                enum TextureCreationFlags {
                    None = 0,
                    MipChain = 1,
                    DontInitializePixels = 4,
                    Crunch = 64,
                    DontUploadUponCreate = 1024,
                    IgnoreMipmapLimit = 2048
                }

                enum FormatUsage {
                    Sample = 0,
                    Linear = 1,
                    Sparse = 2,
                    Render = 4,
                    Blend = 5,
                    GetPixels = 6,
                    SetPixels = 7,
                    SetPixels32 = 8,
                    ReadPixels = 9,
                    LoadStore = 10,
                    MSAA2x = 11,
                    MSAA4x = 12,
                    MSAA8x = 13,
                    StencilSampling = 16
                }

                enum GraphicsFormatUsage {
                    None = 0,
                    Sample = 1,
                    Linear = 2,
                    Sparse = 4,
                    Render = 16,
                    Blend = 32,
                    GetPixels = 64,
                    SetPixels = 128,
                    SetPixels32 = 256,
                    ReadPixels = 512,
                    LoadStore = 1024,
                    MSAA2x = 2048,
                    MSAA4x = 4096,
                    MSAA8x = 8192,
                    StencilSampling = 65536
                }

                enum DefaultFormat {
                    LDR = 0,
                    HDR = 1,
                    DepthStencil = 2,
                    Shadow = 3,
                    Video = 4
                }

                enum GraphicsFormat {
                    None = 0,
                    R8_SRGB = 1,
                    R8G8_SRGB = 2,
                    R8G8B8_SRGB = 3,
                    R8G8B8A8_SRGB = 4,
                    R8_UNorm = 5,
                    R8G8_UNorm = 6,
                    R8G8B8_UNorm = 7,
                    R8G8B8A8_UNorm = 8,
                    R8_SNorm = 9,
                    R8G8_SNorm = 10,
                    R8G8B8_SNorm = 11,
                    R8G8B8A8_SNorm = 12,
                    R8_UInt = 13,
                    R8G8_UInt = 14,
                    R8G8B8_UInt = 15,
                    R8G8B8A8_UInt = 16,
                    R8_SInt = 17,
                    R8G8_SInt = 18,
                    R8G8B8_SInt = 19,
                    R8G8B8A8_SInt = 20,
                    R16_UNorm = 21,
                    R16G16_UNorm = 22,
                    R16G16B16_UNorm = 23,
                    R16G16B16A16_UNorm = 24,
                    R16_SNorm = 25,
                    R16G16_SNorm = 26,
                    R16G16B16_SNorm = 27,
                    R16G16B16A16_SNorm = 28,
                    R16_UInt = 29,
                    R16G16_UInt = 30,
                    R16G16B16_UInt = 31,
                    R16G16B16A16_UInt = 32,
                    R16_SInt = 33,
                    R16G16_SInt = 34,
                    R16G16B16_SInt = 35,
                    R16G16B16A16_SInt = 36,
                    R32_UInt = 37,
                    R32G32_UInt = 38,
                    R32G32B32_UInt = 39,
                    R32G32B32A32_UInt = 40,
                    R32_SInt = 41,
                    R32G32_SInt = 42,
                    R32G32B32_SInt = 43,
                    R32G32B32A32_SInt = 44,
                    R16_SFloat = 45,
                    R16G16_SFloat = 46,
                    R16G16B16_SFloat = 47,
                    R16G16B16A16_SFloat = 48,
                    R32_SFloat = 49,
                    R32G32_SFloat = 50,
                    R32G32B32_SFloat = 51,
                    R32G32B32A32_SFloat = 52,
                    B8G8R8_SRGB = 56,
                    B8G8R8A8_SRGB = 57,
                    B8G8R8_UNorm = 58,
                    B8G8R8A8_UNorm = 59,
                    B8G8R8_SNorm = 60,
                    B8G8R8A8_SNorm = 61,
                    B8G8R8_UInt = 62,
                    B8G8R8A8_UInt = 63,
                    B8G8R8_SInt = 64,
                    B8G8R8A8_SInt = 65,
                    R4G4B4A4_UNormPack16 = 66,
                    B4G4R4A4_UNormPack16 = 67,
                    R5G6B5_UNormPack16 = 68,
                    B5G6R5_UNormPack16 = 69,
                    R5G5B5A1_UNormPack16 = 70,
                    B5G5R5A1_UNormPack16 = 71,
                    A1R5G5B5_UNormPack16 = 72,
                    E5B9G9R9_UFloatPack32 = 73,
                    B10G11R11_UFloatPack32 = 74,
                    A2B10G10R10_UNormPack32 = 75,
                    A2B10G10R10_UIntPack32 = 76,
                    A2B10G10R10_SIntPack32 = 77,
                    A2R10G10B10_UNormPack32 = 78,
                    A2R10G10B10_UIntPack32 = 79,
                    A2R10G10B10_SIntPack32 = 80,
                    A2R10G10B10_XRSRGBPack32 = 81,
                    A2R10G10B10_XRUNormPack32 = 82,
                    R10G10B10_XRSRGBPack32 = 83,
                    R10G10B10_XRUNormPack32 = 84,
                    A10R10G10B10_XRSRGBPack32 = 85,
                    A10R10G10B10_XRUNormPack32 = 86,
                    D16_UNorm = 90,
                    D24_UNorm = 91,
                    D24_UNorm_S8_UInt = 92,
                    D32_SFloat = 93,
                    D32_SFloat_S8_UInt = 94,
                    S8_UInt = 95,
                    RGB_DXT1_SRGB = 96,
                    RGBA_DXT1_SRGB = 96,
                    RGB_DXT1_UNorm = 97,
                    RGBA_DXT1_UNorm = 97,
                    RGBA_DXT3_SRGB = 98,
                    RGBA_DXT3_UNorm = 99,
                    RGBA_DXT5_SRGB = 100,
                    RGBA_DXT5_UNorm = 101,
                    R_BC4_UNorm = 102,
                    R_BC4_SNorm = 103,
                    RG_BC5_UNorm = 104,
                    RG_BC5_SNorm = 105,
                    RGB_BC6H_UFloat = 106,
                    RGB_BC6H_SFloat = 107,
                    RGBA_BC7_SRGB = 108,
                    RGBA_BC7_UNorm = 109,
                    RGB_PVRTC_2Bpp_SRGB = 110,
                    RGB_PVRTC_2Bpp_UNorm = 111,
                    RGB_PVRTC_4Bpp_SRGB = 112,
                    RGB_PVRTC_4Bpp_UNorm = 113,
                    RGBA_PVRTC_2Bpp_SRGB = 114,
                    RGBA_PVRTC_2Bpp_UNorm = 115,
                    RGBA_PVRTC_4Bpp_SRGB = 116,
                    RGBA_PVRTC_4Bpp_UNorm = 117,
                    RGB_ETC_UNorm = 118,
                    RGB_ETC2_SRGB = 119,
                    RGB_ETC2_UNorm = 120,
                    RGB_A1_ETC2_SRGB = 121,
                    RGB_A1_ETC2_UNorm = 122,
                    RGBA_ETC2_SRGB = 123,
                    RGBA_ETC2_UNorm = 124,
                    R_EAC_UNorm = 125,
                    R_EAC_SNorm = 126,
                    RG_EAC_UNorm = 127,
                    RG_EAC_SNorm = 128,
                    RGBA_ASTC4X4_SRGB = 129,
                    RGBA_ASTC4X4_UNorm = 130,
                    RGBA_ASTC5X5_SRGB = 131,
                    RGBA_ASTC5X5_UNorm = 132,
                    RGBA_ASTC6X6_SRGB = 133,
                    RGBA_ASTC6X6_UNorm = 134,
                    RGBA_ASTC8X8_SRGB = 135,
                    RGBA_ASTC8X8_UNorm = 136,
                    RGBA_ASTC10X10_SRGB = 137,
                    RGBA_ASTC10X10_UNorm = 138,
                    RGBA_ASTC12X12_SRGB = 139,
                    RGBA_ASTC12X12_UNorm = 140,
                    YUV2 = 141,
                    DepthAuto = 142,
                    ShadowAuto = 143,
                    VideoAuto = 144,
                    RGBA_ASTC4X4_UFloat = 145,
                    RGBA_ASTC5X5_UFloat = 146,
                    RGBA_ASTC6X6_UFloat = 147,
                    RGBA_ASTC8X8_UFloat = 148,
                    RGBA_ASTC10X10_UFloat = 149,
                    RGBA_ASTC12X12_UFloat = 150,
                    D16_UNorm_S8_UInt = 151
                }

                enum RayTracingMode {
                    Off = 0,
                    Static = 1,
                    DynamicTransform = 2,
                    DynamicGeometry = 3,
                    DynamicGeometryManualUpdate = 4
                }

                class GraphicsFormatUtility {
                    protected [__keep_incompatibility]: never;
                    constructor();
                    public static GetGraphicsFormat($format: UnityEngine.TextureFormat, $isSRGB: boolean): UnityEngine.Experimental.Rendering.GraphicsFormat;
                    public static GetTextureFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.TextureFormat;
                    public static GetGraphicsFormat($format: UnityEngine.RenderTextureFormat, $isSRGB: boolean): UnityEngine.Experimental.Rendering.GraphicsFormat;
                    public static GetGraphicsFormat($format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite): UnityEngine.Experimental.Rendering.GraphicsFormat;
                    public static GetDepthStencilFormat($depthBits: number): UnityEngine.Experimental.Rendering.GraphicsFormat;
                    public static GetDepthBits($format: UnityEngine.Experimental.Rendering.GraphicsFormat): number;
                    public static GetDepthStencilFormat($minimumDepthBits: number, $minimumStencilBits: number): UnityEngine.Experimental.Rendering.GraphicsFormat;
                    public static IsSRGBFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsSwizzleFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsSwizzleFormat($format: UnityEngine.TextureFormat): boolean;
                    public static GetSRGBFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.Experimental.Rendering.GraphicsFormat;
                    public static GetLinearFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.Experimental.Rendering.GraphicsFormat;
                    public static GetRenderTextureFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.RenderTextureFormat;
                    public static GetColorComponentCount($format: UnityEngine.Experimental.Rendering.GraphicsFormat): number;
                    public static GetColorComponentCount($format: UnityEngine.TextureFormat): number;
                    public static GetAlphaComponentCount($format: UnityEngine.Experimental.Rendering.GraphicsFormat): number;
                    public static GetAlphaComponentCount($format: UnityEngine.TextureFormat): number;
                    public static GetComponentCount($format: UnityEngine.Experimental.Rendering.GraphicsFormat): number;
                    public static GetComponentCount($format: UnityEngine.TextureFormat): number;
                    public static GetFormatString($format: UnityEngine.Experimental.Rendering.GraphicsFormat): string;
                    public static GetFormatString($format: UnityEngine.TextureFormat): string;
                    public static IsCompressedFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsCompressedFormat($format: UnityEngine.TextureFormat): boolean;
                    public static IsPackedFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsPackedFormat($format: UnityEngine.TextureFormat): boolean;
                    public static Is16BitPackedFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static Is16BitPackedFormat($format: UnityEngine.TextureFormat): boolean;
                    public static ConvertToAlphaFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.Experimental.Rendering.GraphicsFormat;
                    public static ConvertToAlphaFormat($format: UnityEngine.TextureFormat): UnityEngine.TextureFormat;
                    public static IsAlphaOnlyFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsAlphaOnlyFormat($format: UnityEngine.TextureFormat): boolean;
                    public static IsAlphaTestFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsAlphaTestFormat($format: UnityEngine.TextureFormat): boolean;
                    public static HasAlphaChannel($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static HasAlphaChannel($format: UnityEngine.TextureFormat): boolean;
                    public static IsDepthFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsStencilFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsDepthStencilFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsIEEE754Format($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsFloatFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsHalfFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsUnsignedFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsUnsignedFormat($format: UnityEngine.TextureFormat): boolean;
                    public static IsSignedFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsSignedFormat($format: UnityEngine.TextureFormat): boolean;
                    public static IsNormFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsUNormFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsSNormFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsIntegerFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsUIntFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsSIntFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsXRFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsDXTCFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsDXTCFormat($format: UnityEngine.TextureFormat): boolean;
                    public static IsRGTCFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsRGTCFormat($format: UnityEngine.TextureFormat): boolean;
                    public static IsBPTCFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsBPTCFormat($format: UnityEngine.TextureFormat): boolean;
                    public static IsBCFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsBCFormat($format: UnityEngine.TextureFormat): boolean;
                    public static IsPVRTCFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsPVRTCFormat($format: UnityEngine.TextureFormat): boolean;
                    public static IsETCFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsETCFormat($format: UnityEngine.TextureFormat): boolean;
                    public static IsEACFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsEACFormat($format: UnityEngine.TextureFormat): boolean;
                    public static IsASTCFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsASTCFormat($format: UnityEngine.TextureFormat): boolean;
                    public static IsHDRFormat($format: UnityEngine.Experimental.Rendering.GraphicsFormat): boolean;
                    public static IsHDRFormat($format: UnityEngine.TextureFormat): boolean;
                    public static IsCrunchFormat($format: UnityEngine.TextureFormat): boolean;
                    public static GetSwizzleR($format: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.Rendering.FormatSwizzle;
                    public static GetSwizzleR($format: UnityEngine.TextureFormat): UnityEngine.Rendering.FormatSwizzle;
                    public static GetSwizzleG($format: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.Rendering.FormatSwizzle;
                    public static GetSwizzleG($format: UnityEngine.TextureFormat): UnityEngine.Rendering.FormatSwizzle;
                    public static GetSwizzleB($format: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.Rendering.FormatSwizzle;
                    public static GetSwizzleB($format: UnityEngine.TextureFormat): UnityEngine.Rendering.FormatSwizzle;
                    public static GetSwizzleA($format: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.Rendering.FormatSwizzle;
                    public static GetSwizzleA($format: UnityEngine.TextureFormat): UnityEngine.Rendering.FormatSwizzle;
                    public static GetBlockSize($format: UnityEngine.Experimental.Rendering.GraphicsFormat): number;
                    public static GetBlockSize($format: UnityEngine.TextureFormat): number;
                    public static GetBlockWidth($format: UnityEngine.Experimental.Rendering.GraphicsFormat): number;
                    public static GetBlockWidth($format: UnityEngine.TextureFormat): number;
                    public static GetBlockHeight($format: UnityEngine.Experimental.Rendering.GraphicsFormat): number;
                    public static GetBlockHeight($format: UnityEngine.TextureFormat): number;
                    public static ComputeMipmapSize($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat): number;
                    public static ComputeMipmapSize($width: number, $height: number, $format: UnityEngine.TextureFormat): number;
                    public static ComputeMipChainSize($width: number, $height: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount?: number): number;
                    public static ComputeMipChainSize($width: number, $height: number, $format: UnityEngine.TextureFormat, $mipCount?: number): number;
                    public static ComputeMipmapSize($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat): number;
                    public static ComputeMipmapSize($width: number, $height: number, $depth: number, $format: UnityEngine.TextureFormat): number;
                    public static ComputeMipChainSize($width: number, $height: number, $depth: number, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $mipCount?: number): number;
                    public static ComputeMipChainSize($width: number, $height: number, $depth: number, $format: UnityEngine.TextureFormat, $mipCount?: number): number;
                }

                class GraphicsStateCollection extends UnityEngine.Object {
                    protected [__keep_incompatibility]: never;
                    public get isTracing(): boolean;
                    public version: number;
                    public graphicsDeviceType: UnityEngine.Rendering.GraphicsDeviceType;
                    public runtimePlatform: UnityEngine.RuntimePlatform;
                    public qualityLevelName: string;
                    public get totalGraphicsStateCount(): number;
                    public get completedWarmupCount(): number;
                    public get isWarmedUp(): boolean;
                    public get variantCount(): number;
                    constructor();
                    constructor($filePath: string);
                    public BeginTrace(): boolean;
                    public EndTrace(): void;
                    public LoadFromFile($filePath: string): boolean;
                    public SaveToFile($filePath: string): boolean;
                    public SendToEditor($fileName: string): boolean;
                    public WarmUp($dependency?: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                    public WarmUpProgressively($count: number, $dependency?: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                    public GetVariants($results: System.Collections.Generic.List$1<UnityEngine.Experimental.Rendering.GraphicsStateCollection.ShaderVariant>): void;
                    public GetGraphicsStatesForVariant($shader: UnityEngine.Shader, $passId: UnityEngine.Rendering.PassIdentifier, $keywords: System.Array$1<UnityEngine.Rendering.LocalKeyword>, $results: System.Collections.Generic.List$1<UnityEngine.Experimental.Rendering.GraphicsStateCollection.GraphicsState>): void;
                    public GetGraphicsStateCountForVariant($shader: UnityEngine.Shader, $passId: UnityEngine.Rendering.PassIdentifier, $keywords: System.Array$1<UnityEngine.Rendering.LocalKeyword>): number;
                    public AddVariant($shader: UnityEngine.Shader, $passId: UnityEngine.Rendering.PassIdentifier, $keywords: System.Array$1<UnityEngine.Rendering.LocalKeyword>): boolean;
                    public AddVariant($mat: UnityEngine.Material, $passId: UnityEngine.Rendering.PassIdentifier): boolean;
                    public AddVariants($mat: UnityEngine.Material, $subshaderIndex?: number): boolean;
                    public RemoveVariant($shader: UnityEngine.Shader, $passId: UnityEngine.Rendering.PassIdentifier, $keywords: System.Array$1<UnityEngine.Rendering.LocalKeyword>): boolean;
                    public RemoveVariant($mat: UnityEngine.Material, $passId: UnityEngine.Rendering.PassIdentifier): boolean;
                    public ContainsVariant($shader: UnityEngine.Shader, $passId: UnityEngine.Rendering.PassIdentifier, $keywords: System.Array$1<UnityEngine.Rendering.LocalKeyword>): boolean;
                    public ContainsVariant($mat: UnityEngine.Material, $passId: UnityEngine.Rendering.PassIdentifier): boolean;
                    public ClearVariants(): void;
                    public AddGraphicsStateForVariant($shader: UnityEngine.Shader, $passId: UnityEngine.Rendering.PassIdentifier, $keywords: System.Array$1<UnityEngine.Rendering.LocalKeyword>, $setup: UnityEngine.Experimental.Rendering.GraphicsStateCollection.GraphicsState): boolean;
                    public RemoveGraphicsStatesForVariant($shader: UnityEngine.Shader, $passId: UnityEngine.Rendering.PassIdentifier, $keywords: System.Array$1<UnityEngine.Rendering.LocalKeyword>): boolean;
                    public CopyGraphicsStatesForVariant($srcShader: UnityEngine.Shader, $srcPassId: UnityEngine.Rendering.PassIdentifier, $srcKeywords: System.Array$1<UnityEngine.Rendering.LocalKeyword>, $dstShader: UnityEngine.Shader, $dstPassId: UnityEngine.Rendering.PassIdentifier, $dstKeywords: System.Array$1<UnityEngine.Rendering.LocalKeyword>): boolean;
                    public GetGraphicsStatesForVariant($variant: UnityEngine.Experimental.Rendering.GraphicsStateCollection.ShaderVariant, $results: System.Collections.Generic.List$1<UnityEngine.Experimental.Rendering.GraphicsStateCollection.GraphicsState>): void;
                    public GetGraphicsStateCountForVariant($variant: UnityEngine.Experimental.Rendering.GraphicsStateCollection.ShaderVariant): number;
                    public AddGraphicsStateForVariant($variant: UnityEngine.Experimental.Rendering.GraphicsStateCollection.ShaderVariant, $setup: UnityEngine.Experimental.Rendering.GraphicsStateCollection.GraphicsState): boolean;
                    public RemoveGraphicsStatesForVariant($variant: UnityEngine.Experimental.Rendering.GraphicsStateCollection.ShaderVariant): boolean;
                    public CopyGraphicsStatesForVariant($srcVariant: UnityEngine.Experimental.Rendering.GraphicsStateCollection.ShaderVariant, $dstVariant: UnityEngine.Experimental.Rendering.GraphicsStateCollection.ShaderVariant): boolean;
                }
                namespace GraphicsStateCollection {
                    class GraphicsState {
                        protected [__keep_incompatibility]: never;
                        public vertexAttributes: System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>;
                        public attachments: System.Array$1<UnityEngine.Rendering.AttachmentDescriptor>;
                        public subPasses: System.Array$1<UnityEngine.Rendering.SubPassDescriptor>;
                        public renderState: UnityEngine.Rendering.RenderStateBlock;
                        public topology: UnityEngine.MeshTopology;
                        public forceCullMode: UnityEngine.Rendering.CullMode;
                        public shadingRateCombinerPrimitive: UnityEngine.Rendering.ShadingRateCombiner;
                        public shadingRateCombinerFragment: UnityEngine.Rendering.ShadingRateCombiner;
                        public baseShadingRate: UnityEngine.Rendering.ShadingRateFragmentSize;
                        public depthBias: number;
                        public slopeDepthBias: number;
                        public depthAttachmentIndex: number;
                        public subPassIndex: number;
                        public shadingRateIndex: number;
                        public multiviewCount: number;
                        public sampleCount: number;
                        public hasEyeTexture: boolean;
                        public wireframe: boolean;
                        public invertCulling: boolean;
                        public negativeScale: boolean;
                        public invertProjection: boolean;
                        public SetMeshData($mesh: UnityEngine.Mesh, $submesh: number, $renderer?: UnityEngine.Renderer): void;
                        public SetRenderPassData($samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $subPasses: Unity.Collections.NativeArray$1<UnityEngine.Rendering.SubPassDescriptor>, $subPassIndex?: number, $depthAttachmentIndex?: number, $shadingRateIndex?: number): void;
                        public SetRenderStateData($shader: UnityEngine.Shader, $passId: UnityEngine.Rendering.PassIdentifier): void;
                    }

                    class ShaderVariant {
                        protected [__keep_incompatibility]: never;
                        public shader: UnityEngine.Shader;
                        public passId: UnityEngine.Rendering.PassIdentifier;
                        public keywords: System.Array$1<UnityEngine.Rendering.LocalKeyword>;
                        constructor($shader: UnityEngine.Shader, $passId: UnityEngine.Rendering.PassIdentifier, $keywords: System.Array$1<UnityEngine.Rendering.LocalKeyword>);
                        constructor($material: UnityEngine.Material, $passId: UnityEngine.Rendering.PassIdentifier);
                    }

                }

                class ShaderWarmupSetup {
                    protected [__keep_incompatibility]: never;
                    public vdecl: System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>;
                }

                class ShaderWarmup {
                    protected [__keep_incompatibility]: never;
                    public static WarmupShader($shader: UnityEngine.Shader, $setup: UnityEngine.Experimental.Rendering.ShaderWarmupSetup): void;
                    public static WarmupShaderFromCollection($collection: UnityEngine.ShaderVariantCollection, $shader: UnityEngine.Shader, $setup: UnityEngine.Experimental.Rendering.ShaderWarmupSetup): void;
                }

            }
        }
    }
    namespace UnityEngine {
        namespace Internal {
            class DefaultValueAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get Value(): any;
                constructor($value: string);
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class ExcludeFromDocsAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

        }
    }
    namespace UnityEngine {
        namespace iOS {
            class ADBannerView {
                protected [__keep_incompatibility]: never;
                public get loaded(): boolean;
                public visible: boolean;
                public layout: UnityEngine.iOS.ADBannerView.Layout;
                public position: UnityEngine.Vector2;
                public get size(): UnityEngine.Vector2;
                constructor($type: UnityEngine.iOS.ADBannerView.Type, $layout: UnityEngine.iOS.ADBannerView.Layout);
                public static IsAvailable($type: UnityEngine.iOS.ADBannerView.Type): boolean;
                public static add_onBannerWasClicked(handler: UnityEngine.iOS.ADBannerView.BannerWasClickedDelegate): void;
                public static remove_onBannerWasClicked(handler: UnityEngine.iOS.ADBannerView.BannerWasClickedDelegate): void;
                public static add_onBannerWasLoaded(handler: UnityEngine.iOS.ADBannerView.BannerWasLoadedDelegate): void;
                public static remove_onBannerWasLoaded(handler: UnityEngine.iOS.ADBannerView.BannerWasLoadedDelegate): void;
                public static add_onBannerFailedToLoad(handler: UnityEngine.iOS.ADBannerView.BannerFailedToLoadDelegate): void;
                public static remove_onBannerFailedToLoad(handler: UnityEngine.iOS.ADBannerView.BannerFailedToLoadDelegate): void;
            }
            namespace ADBannerView {
                enum Layout {
                    Top = 0,
                    TopLeft = 0,
                    Bottom = 1,
                    BottomLeft = 1,
                    CenterLeft = 2,
                    TopRight = 4,
                    BottomRight = 5,
                    CenterRight = 6,
                    TopCenter = 8,
                    BottomCenter = 9,
                    Center = 10,
                    Manual = -1
                }

                enum Type {
                    Banner = 0,
                    MediumRect = 1
                }

                interface BannerWasClickedDelegate {
                    (): void;
                    Invoke?: () => void;
                }
                var BannerWasClickedDelegate: { new (func: () => void): BannerWasClickedDelegate; };

                interface BannerWasLoadedDelegate {
                    (): void;
                    Invoke?: () => void;
                }
                var BannerWasLoadedDelegate: { new (func: () => void): BannerWasLoadedDelegate; };

                interface BannerFailedToLoadDelegate {
                    (): void;
                    Invoke?: () => void;
                }
                var BannerFailedToLoadDelegate: { new (func: () => void): BannerFailedToLoadDelegate; };

            }

            class ADInterstitialAd {
                protected [__keep_incompatibility]: never;
                public static get isAvailable(): boolean;
                public get loaded(): boolean;
                constructor($autoReload: boolean);
                constructor();
                public Show(): void;
                public ReloadAd(): void;
                public static add_onInterstitialWasLoaded(handler: UnityEngine.iOS.ADInterstitialAd.InterstitialWasLoadedDelegate): void;
                public static remove_onInterstitialWasLoaded(handler: UnityEngine.iOS.ADInterstitialAd.InterstitialWasLoadedDelegate): void;
                public static add_onInterstitialWasViewed(handler: UnityEngine.iOS.ADInterstitialAd.InterstitialWasViewedDelegate): void;
                public static remove_onInterstitialWasViewed(handler: UnityEngine.iOS.ADInterstitialAd.InterstitialWasViewedDelegate): void;
            }
            namespace ADInterstitialAd {
                interface InterstitialWasLoadedDelegate {
                    (): void;
                    Invoke?: () => void;
                }
                var InterstitialWasLoadedDelegate: { new (func: () => void): InterstitialWasLoadedDelegate; };

                interface InterstitialWasViewedDelegate {
                    (): void;
                    Invoke?: () => void;
                }
                var InterstitialWasViewedDelegate: { new (func: () => void): InterstitialWasViewedDelegate; };

            }

            class Device {
                protected [__keep_incompatibility]: never;
                public static hideHomeButton: boolean;
                public static wantsSoftwareDimming: boolean;
                public static deferSystemGesturesMode: UnityEngine.iOS.SystemGestureDeferMode;
                public static get systemVersion(): string;
                public static get generation(): UnityEngine.iOS.DeviceGeneration;
                public static get vendorIdentifier(): string;
                public static get lowPowerModeEnabled(): boolean;
                public static get advertisingTrackingEnabled(): boolean;
                public static get advertisingIdentifier(): string;
                public static get iosAppOnMac(): boolean;
                public static get runsOnSimulator(): boolean;
                constructor();
                public static RequestStoreReview(): boolean;
                public static SetNoBackupFlag($path: string): void;
                public static ResetNoBackupFlag($path: string): void;
            }

            enum DeviceGeneration {
                Unknown = 0,
                iPhone = 1,
                iPhone3G = 2,
                iPhone3GS = 3,
                iPodTouch1Gen = 4,
                iPodTouch2Gen = 5,
                iPodTouch3Gen = 6,
                iPad1Gen = 7,
                iPhone4 = 8,
                iPodTouch4Gen = 9,
                iPad2Gen = 10,
                iPhone4S = 11,
                iPad3Gen = 12,
                iPhone5 = 13,
                iPodTouch5Gen = 14,
                iPadMini1Gen = 15,
                iPad4Gen = 16,
                iPhone5C = 17,
                iPhone5S = 18,
                iPadAir1 = 19,
                iPadMini2Gen = 20,
                iPhone6 = 21,
                iPhone6Plus = 22,
                iPadMini3Gen = 23,
                iPadAir2 = 24,
                iPhone6S = 25,
                iPhone6SPlus = 26,
                iPadPro1Gen = 27,
                iPadMini4Gen = 28,
                iPhoneSE1Gen = 29,
                iPadPro10Inch1Gen = 30,
                iPhone7 = 31,
                iPhone7Plus = 32,
                iPodTouch6Gen = 33,
                iPad5Gen = 34,
                iPadPro2Gen = 35,
                iPadPro10Inch2Gen = 36,
                iPhone8 = 37,
                iPhone8Plus = 38,
                iPhoneX = 39,
                iPhoneXS = 40,
                iPhoneXSMax = 41,
                iPhoneXR = 42,
                iPadPro11Inch = 43,
                iPadPro3Gen = 44,
                iPad6Gen = 45,
                iPadAir3Gen = 46,
                iPadMini5Gen = 47,
                iPhone11 = 48,
                iPhone11Pro = 49,
                iPhone11ProMax = 50,
                iPodTouch7Gen = 51,
                iPad7Gen = 52,
                iPhoneSE2Gen = 53,
                iPadPro11Inch2Gen = 54,
                iPadPro4Gen = 55,
                iPhone12Mini = 56,
                iPhone12 = 57,
                iPhone12Pro = 58,
                iPhone12ProMax = 59,
                iPad8Gen = 60,
                iPadAir4Gen = 61,
                iPad9Gen = 62,
                iPadMini6Gen = 63,
                iPhone13 = 64,
                iPhone13Mini = 65,
                iPhone13Pro = 66,
                iPhone13ProMax = 67,
                iPadPro5Gen = 68,
                iPadPro11Inch3Gen = 69,
                iPhoneSE3Gen = 70,
                iPadAir5Gen = 71,
                iPhone14 = 72,
                iPhone14Plus = 73,
                iPhone14Pro = 74,
                iPhone14ProMax = 75,
                iPadPro6Gen = 76,
                iPadPro11Inch4Gen = 77,
                iPad10Gen = 78,
                iPhone15 = 79,
                iPhone15Plus = 80,
                iPhone15Pro = 81,
                iPhone15ProMax = 82,
                iPhone16 = 83,
                iPhone16Plus = 84,
                iPhone16Pro = 85,
                iPhone16ProMax = 86,
                iPhone16e = 87,
                iPhone17 = 88,
                iPhoneAir = 89,
                iPhone17Pro = 90,
                iPhone17ProMax = 91,
                iPhoneUnknown = 10001,
                iPadUnknown = 10002,
                iPodTouchUnknown = 10003
            }

            enum ActivityIndicatorStyle {
                WhiteLarge = 0,
                White = 1,
                Gray = 2,
                Medium = 100,
                Large = 101,
                DontShow = -1
            }

            enum SystemGestureDeferMode {
                None = 0,
                TopEdge = 1,
                LeftEdge = 2,
                BottomEdge = 4,
                RightEdge = 8,
                All = 15
            }

            class OnDemandResourcesRequest extends UnityEngine.AsyncOperation implements System.IDisposable {
                protected [__keep_incompatibility]: never;
                public get error(): string;
                public loadingPriority: number;
                public GetResourcePath($resourceName: string): string;
                public Dispose(): void;
            }

            class OnDemandResources {
                protected [__keep_incompatibility]: never;
                public static get enabled(): boolean;
                public static PreloadAsync($tags: System.Array$1<string>): UnityEngine.iOS.OnDemandResourcesRequest;
            }

        }
    }
    namespace UnityEngine {
        namespace Jobs {
            interface IJobParallelForTransform {
                Execute($index: number, $transform: UnityEngine.Jobs.TransformAccess): void;
            }

            class IJobParallelForTransformExtensions {
                protected [__keep_incompatibility]: never;
                public static EarlyJobInit<T extends UnityEngine.Jobs.IJobParallelForTransform>(): void;
                public static Schedule<T extends UnityEngine.Jobs.IJobParallelForTransform>($transforms: UnityEngine.Jobs.TransformAccessArray, $dependsOn?: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public static ScheduleReadOnly<T extends UnityEngine.Jobs.IJobParallelForTransform>($transforms: UnityEngine.Jobs.TransformAccessArray, $batchSize: number, $dependsOn?: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public static RunReadOnly<T extends UnityEngine.Jobs.IJobParallelForTransform>($transforms: UnityEngine.Jobs.TransformAccessArray): void;
                public static ScheduleByRef<T extends UnityEngine.Jobs.IJobParallelForTransform>($transforms: UnityEngine.Jobs.TransformAccessArray, $dependsOn?: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public static ScheduleReadOnlyByRef<T extends UnityEngine.Jobs.IJobParallelForTransform>($transforms: UnityEngine.Jobs.TransformAccessArray, $batchSize: number, $dependsOn?: Unity.Jobs.JobHandle): Unity.Jobs.JobHandle;
                public static RunReadOnlyByRef<T extends UnityEngine.Jobs.IJobParallelForTransform>($transforms: UnityEngine.Jobs.TransformAccessArray): void;
            }

            class TransformAccess {
                protected [__keep_incompatibility]: never;
                public position: UnityEngine.Vector3;
                public rotation: UnityEngine.Quaternion;
                public localPosition: UnityEngine.Vector3;
                public localRotation: UnityEngine.Quaternion;
                public localScale: UnityEngine.Vector3;
                public get localToWorldMatrix(): UnityEngine.Matrix4x4;
                public get worldToLocalMatrix(): UnityEngine.Matrix4x4;
                public get isValid(): boolean;
                public SetPositionAndRotation($position: UnityEngine.Vector3, $rotation: UnityEngine.Quaternion): void;
                public SetLocalPositionAndRotation($localPosition: UnityEngine.Vector3, $localRotation: UnityEngine.Quaternion): void;
                public GetPositionAndRotation($position: $Out<UnityEngine.Vector3>, $rotation: $Out<UnityEngine.Quaternion>): void;
                public GetLocalPositionAndRotation($localPosition: $Out<UnityEngine.Vector3>, $localRotation: $Out<UnityEngine.Quaternion>): void;
            }

            class TransformAccessArray implements System.IDisposable {
                protected [__keep_incompatibility]: never;
                public get isCreated(): boolean;
                public capacity: number;
                public get length(): number;
                constructor($transforms: System.Array$1<UnityEngine.Transform>, $desiredJobCount?: number);
                constructor($transformHandles: Unity.Collections.NativeArray$1<UnityEngine.TransformHandle>, $desiredJobCount?: number);
                constructor($capacity: number, $desiredJobCount?: number);
                public static Allocate($capacity: number, $desiredJobCount: number, $array: $Out<UnityEngine.Jobs.TransformAccessArray>): void;
                public Dispose(): void;
                public GetTransformHandle($index: number): UnityEngine.TransformHandle;
                public SetTransformHandle($index: number, $transformHandle: UnityEngine.TransformHandle): void;
                public Add($transform: UnityEngine.Transform): void;
                public Add($instanceId: number): void;
                public Add($transformHandle: UnityEngine.TransformHandle): void;
                public Add($entityId: UnityEngine.EntityId): void;
                public RemoveAtSwapBack($index: number): void;
                public SetTransforms($transforms: System.Array$1<UnityEngine.Transform>): void;
                public SetTransformHandles($transformHandles: Unity.Collections.NativeArray$1<UnityEngine.TransformHandle>): void;
                public get_Item($index: number): UnityEngine.Transform;
                public set_Item($index: number, value: UnityEngine.Transform): void;
            }

        }
    }
    namespace UnityEngine {
        namespace LowLevel {
            class PlayerLoopSystem {
                protected [__keep_incompatibility]: never;
                public type: System.Type;
                public subSystemList: System.Array$1<UnityEngine.LowLevel.PlayerLoopSystem>;
                public updateDelegate: UnityEngine.LowLevel.PlayerLoopSystem.UpdateFunction;
                public updateFunction: number;
                public loopConditionFunction: number;
                public ToString(): string;
            }
            namespace PlayerLoopSystem {
                interface UpdateFunction {
                    (): void;
                    Invoke?: () => void;
                }
                var UpdateFunction: { new (func: () => void): UpdateFunction; };

            }

            class PlayerLoop {
                protected [__keep_incompatibility]: never;
                constructor();
                public static GetDefaultPlayerLoop(): UnityEngine.LowLevel.PlayerLoopSystem;
                public static GetCurrentPlayerLoop(): UnityEngine.LowLevel.PlayerLoopSystem;
                public static SetPlayerLoop($loop: UnityEngine.LowLevel.PlayerLoopSystem): void;
            }

        }
    }
    namespace UnityEngine {
        namespace Lumin {
            class UsesLuminPlatformLevelAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get platformLevel(): number;
                constructor($platformLevel: number);
            }

            class UsesLuminPrivilegeAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get privilege(): string;
                constructor($privilege: string);
            }

        }
    }
    namespace UnityEngine {
        namespace Networking {
            namespace PlayerConnection {
                enum ConnectionTarget {
                    None = 0,
                    Player = 1,
                    Editor = 2
                }

                interface IConnectionState extends System.IDisposable {
                    get connectedToTarget(): UnityEngine.Networking.PlayerConnection.ConnectionTarget;
                    get connectionName(): string;
                }

                class MessageEventArgs {
                    protected [__keep_incompatibility]: never;
                    public playerId: number;
                    public data: System.Array$1<number>;
                    constructor();
                }

                interface IEditorPlayerConnection {
                    Register($messageId: System.Guid, $callback: UnityEngine.Events.UnityAction$1<UnityEngine.Networking.PlayerConnection.MessageEventArgs>): void;
                    Unregister($messageId: System.Guid, $callback: UnityEngine.Events.UnityAction$1<UnityEngine.Networking.PlayerConnection.MessageEventArgs>): void;
                    DisconnectAll(): void;
                    RegisterConnection($callback: UnityEngine.Events.UnityAction$1<number>): void;
                    RegisterDisconnection($callback: UnityEngine.Events.UnityAction$1<number>): void;
                    UnregisterConnection($callback: UnityEngine.Events.UnityAction$1<number>): void;
                    UnregisterDisconnection($callback: UnityEngine.Events.UnityAction$1<number>): void;
                    Send($messageId: System.Guid, $data: System.Array$1<number>): void;
                    TrySend($messageId: System.Guid, $data: System.Array$1<number>): boolean;
                }

                class PlayerConnection extends UnityEngine.ScriptableObject implements UnityEngine.Networking.PlayerConnection.IEditorPlayerConnection {
                    protected [__keep_incompatibility]: never;
                    public static get instance(): UnityEngine.Networking.PlayerConnection.PlayerConnection;
                    public get isConnected(): boolean;
                    constructor();
                    public OnEnable(): void;
                    public Register($messageId: System.Guid, $callback: UnityEngine.Events.UnityAction$1<UnityEngine.Networking.PlayerConnection.MessageEventArgs>): void;
                    public Unregister($messageId: System.Guid, $callback: UnityEngine.Events.UnityAction$1<UnityEngine.Networking.PlayerConnection.MessageEventArgs>): void;
                    public RegisterConnection($callback: UnityEngine.Events.UnityAction$1<number>): void;
                    public RegisterDisconnection($callback: UnityEngine.Events.UnityAction$1<number>): void;
                    public UnregisterConnection($callback: UnityEngine.Events.UnityAction$1<number>): void;
                    public UnregisterDisconnection($callback: UnityEngine.Events.UnityAction$1<number>): void;
                    public Send($messageId: System.Guid, $data: System.Array$1<number>): void;
                    public TrySend($messageId: System.Guid, $data: System.Array$1<number>): boolean;
                    public BlockUntilRecvMsg($messageId: System.Guid, $timeout: number): boolean;
                    public DisconnectAll(): void;
                }

            }
        }
    }
    namespace UnityEngine {
        namespace Playables {
            class FrameData {
                protected [__keep_incompatibility]: never;
                public get frameId(): bigint;
                public get deltaTime(): number;
                public get weight(): number;
                public get effectiveWeight(): number;
                public get effectiveParentDelay(): number;
                public get effectiveParentSpeed(): number;
                public get effectiveSpeed(): number;
                public get evaluationType(): UnityEngine.Playables.FrameData.EvaluationType;
                public get seekOccurred(): boolean;
                public get timeLooped(): boolean;
                public get timeHeld(): boolean;
                public get output(): UnityEngine.Playables.PlayableOutput;
                public get effectivePlayState(): UnityEngine.Playables.PlayState;
            }
            namespace FrameData {
                enum EvaluationType {
                    Evaluate = 0,
                    Playback = 1
                }

            }

            interface INotification {
                get id(): UnityEngine.PropertyName;
            }

            interface INotificationReceiver {
                OnNotify($origin: UnityEngine.Playables.Playable, $notification: UnityEngine.Playables.INotification, $context: any): void;
            }

            interface IPlayable {
                GetHandle(): UnityEngine.Playables.PlayableHandle;
            }

            interface IPlayableBehaviour {
                OnGraphStart($playable: UnityEngine.Playables.Playable): void;
                OnGraphStop($playable: UnityEngine.Playables.Playable): void;
                OnPlayableCreate($playable: UnityEngine.Playables.Playable): void;
                OnPlayableDestroy($playable: UnityEngine.Playables.Playable): void;
                OnBehaviourPlay($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData): void;
                OnBehaviourPause($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData): void;
                PrepareFrame($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData): void;
                ProcessFrame($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData, $playerData: any): void;
            }

            interface IPlayableOutput {
                GetHandle(): UnityEngine.Playables.PlayableOutputHandle;
            }

            class Notification implements UnityEngine.Playables.INotification {
                protected [__keep_incompatibility]: never;
                public get id(): UnityEngine.PropertyName;
                constructor($name: string);
            }

            enum DirectorWrapMode {
                Hold = 0,
                Loop = 1,
                None = 2
            }

            class Playable implements System.IEquatable$1<UnityEngine.Playables.Playable>, UnityEngine.Playables.IPlayable {
                protected [__keep_incompatibility]: never;
                public static get Null(): UnityEngine.Playables.Playable;
                public static Create($graph: UnityEngine.Playables.PlayableGraph, $inputCount?: number): UnityEngine.Playables.Playable;
                public GetHandle(): UnityEngine.Playables.PlayableHandle;
                public IsPlayableOfType<T extends UnityEngine.Playables.IPlayable>(): boolean;
                public GetPlayableType(): System.Type;
                public Equals($other: UnityEngine.Playables.Playable): boolean;
            }

            interface IPlayableAsset {
                get duration(): number;
                get outputs(): System.Collections.Generic.IEnumerable$1<UnityEngine.Playables.PlayableBinding>;
                CreatePlayable($graph: UnityEngine.Playables.PlayableGraph, $owner: UnityEngine.GameObject): UnityEngine.Playables.Playable;
            }

            class PlayableAsset extends UnityEngine.ScriptableObject implements UnityEngine.Playables.IPlayableAsset {
                protected [__keep_incompatibility]: never;
                public get duration(): number;
                public get outputs(): System.Collections.Generic.IEnumerable$1<UnityEngine.Playables.PlayableBinding>;
                public CreatePlayable($graph: UnityEngine.Playables.PlayableGraph, $owner: UnityEngine.GameObject): UnityEngine.Playables.Playable;
            }

            class PlayableBehaviour implements System.ICloneable, UnityEngine.Playables.IPlayableBehaviour {
                protected [__keep_incompatibility]: never;
                public OnGraphStart($playable: UnityEngine.Playables.Playable): void;
                public OnGraphStop($playable: UnityEngine.Playables.Playable): void;
                public OnPlayableCreate($playable: UnityEngine.Playables.Playable): void;
                public OnPlayableDestroy($playable: UnityEngine.Playables.Playable): void;
                public OnBehaviourDelay($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData): void;
                public OnBehaviourPlay($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData): void;
                public OnBehaviourPause($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData): void;
                public PrepareData($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData): void;
                public PrepareFrame($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData): void;
                public ProcessFrame($playable: UnityEngine.Playables.Playable, $info: UnityEngine.Playables.FrameData, $playerData: any): void;
                public Clone(): any;
            }

            enum DataStreamType {
                Animation = 0,
                Audio = 1,
                Texture = 2,
                None = 3
            }

            class PlayableBinding {
                protected [__keep_incompatibility]: never;
                public static readonly None: System.Array$1<UnityEngine.Playables.PlayableBinding>;
                public static readonly DefaultDuration: number;
                public streamName: string;
                public sourceObject: UnityEngine.Object;
                public get outputTargetType(): System.Type;
            }

            enum PlayableTraversalMode {
                Mix = 0,
                Passthrough = 1
            }

            class PlayableExtensions {
                protected [__keep_incompatibility]: never;
                public static IsNull<U extends UnityEngine.Playables.IPlayable>(): boolean;
                public static IsValid<U extends UnityEngine.Playables.IPlayable>(): boolean;
                public static Destroy<U extends UnityEngine.Playables.IPlayable>(): void;
                public static GetGraph<U extends UnityEngine.Playables.IPlayable>(): UnityEngine.Playables.PlayableGraph;
                public static SetPlayState<U extends UnityEngine.Playables.IPlayable>($value: UnityEngine.Playables.PlayState): void;
                public static GetPlayState<U extends UnityEngine.Playables.IPlayable>(): UnityEngine.Playables.PlayState;
                public static Play<U extends UnityEngine.Playables.IPlayable>(): void;
                public static Pause<U extends UnityEngine.Playables.IPlayable>(): void;
                public static SetSpeed<U extends UnityEngine.Playables.IPlayable>($value: number): void;
                public static GetSpeed<U extends UnityEngine.Playables.IPlayable>(): number;
                public static SetDuration<U extends UnityEngine.Playables.IPlayable>($value: number): void;
                public static GetDuration<U extends UnityEngine.Playables.IPlayable>(): number;
                public static SetTime<U extends UnityEngine.Playables.IPlayable>($value: number): void;
                public static GetTime<U extends UnityEngine.Playables.IPlayable>(): number;
                public static GetPreviousTime<U extends UnityEngine.Playables.IPlayable>(): number;
                public static SetDone<U extends UnityEngine.Playables.IPlayable>($value: boolean): void;
                public static IsDone<U extends UnityEngine.Playables.IPlayable>(): boolean;
                public static SetPropagateSetTime<U extends UnityEngine.Playables.IPlayable>($value: boolean): void;
                public static GetPropagateSetTime<U extends UnityEngine.Playables.IPlayable>(): boolean;
                public static CanChangeInputs<U extends UnityEngine.Playables.IPlayable>(): boolean;
                public static CanSetWeights<U extends UnityEngine.Playables.IPlayable>(): boolean;
                public static CanDestroy<U extends UnityEngine.Playables.IPlayable>(): boolean;
                public static SetInputCount<U extends UnityEngine.Playables.IPlayable>($value: number): void;
                public static GetInputCount<U extends UnityEngine.Playables.IPlayable>(): number;
                public static SetOutputCount<U extends UnityEngine.Playables.IPlayable>($value: number): void;
                public static GetOutputCount<U extends UnityEngine.Playables.IPlayable>(): number;
                public static GetInput<U extends UnityEngine.Playables.IPlayable>($inputPort: number): UnityEngine.Playables.Playable;
                public static GetOutput<U extends UnityEngine.Playables.IPlayable>($outputPort: number): UnityEngine.Playables.Playable;
                public static SetInputWeight<U extends UnityEngine.Playables.IPlayable>($inputIndex: number, $weight: number): void;
                public static SetInputWeight<U extends UnityEngine.Playables.IPlayable, V extends UnityEngine.Playables.IPlayable>($input: V, $weight: number): void;
                public static GetInputWeight<U extends UnityEngine.Playables.IPlayable>($inputIndex: number): number;
                public static ConnectInput<U extends UnityEngine.Playables.IPlayable, V extends UnityEngine.Playables.IPlayable>($inputIndex: number, $sourcePlayable: V, $sourceOutputIndex: number): void;
                public static ConnectInput<U extends UnityEngine.Playables.IPlayable, V extends UnityEngine.Playables.IPlayable>($inputIndex: number, $sourcePlayable: V, $sourceOutputIndex: number, $weight: number): void;
                public static DisconnectInput<U extends UnityEngine.Playables.IPlayable>($inputPort: number): void;
                public static AddInput<U extends UnityEngine.Playables.IPlayable, V extends UnityEngine.Playables.IPlayable>($sourcePlayable: V, $sourceOutputIndex: number, $weight?: number): number;
                public static SetDelay<U extends UnityEngine.Playables.IPlayable>($delay: number): void;
                public static GetDelay<U extends UnityEngine.Playables.IPlayable>(): number;
                public static IsDelayed<U extends UnityEngine.Playables.IPlayable>(): boolean;
                public static SetLeadTime<U extends UnityEngine.Playables.IPlayable>($value: number): void;
                public static GetLeadTime<U extends UnityEngine.Playables.IPlayable>(): number;
                public static GetTraversalMode<U extends UnityEngine.Playables.IPlayable>(): UnityEngine.Playables.PlayableTraversalMode;
                public static SetTraversalMode<U extends UnityEngine.Playables.IPlayable>($mode: UnityEngine.Playables.PlayableTraversalMode): void;
            }

            enum DirectorUpdateMode {
                DSPClock = 0,
                GameTime = 1,
                UnscaledGameTime = 2,
                Manual = 3
            }

            class PlayableGraph {
                protected [__keep_incompatibility]: never;
                public GetRootPlayable($index: number): UnityEngine.Playables.Playable;
                public Connect<U extends UnityEngine.Playables.IPlayable, V extends UnityEngine.Playables.IPlayable>($source: U, $sourceOutputPort: number, $destination: V, $destinationInputPort: number): boolean;
                public Disconnect<U extends UnityEngine.Playables.IPlayable>($input: U, $inputPort: number): void;
                public DestroyPlayable<U extends UnityEngine.Playables.IPlayable>($playable: U): void;
                public DestroySubgraph<U extends UnityEngine.Playables.IPlayable>($playable: U): void;
                public DestroyOutput<U extends UnityEngine.Playables.IPlayableOutput>($output: U): void;
                public GetOutputCountByType<T extends UnityEngine.Playables.IPlayableOutput>(): number;
                public GetOutput($index: number): UnityEngine.Playables.PlayableOutput;
                public GetOutputByType<T extends UnityEngine.Playables.IPlayableOutput>($index: number): UnityEngine.Playables.PlayableOutput;
                public Evaluate(): void;
                public static Create(): UnityEngine.Playables.PlayableGraph;
                public static Create($name: string): UnityEngine.Playables.PlayableGraph;
                public Destroy(): void;
                public IsValid(): boolean;
                public IsPlaying(): boolean;
                public IsDone(): boolean;
                public Play(): void;
                public Stop(): void;
                public Evaluate($deltaTime: number): void;
                public GetTimeUpdateMode(): UnityEngine.Playables.DirectorUpdateMode;
                public SetTimeUpdateMode($value: UnityEngine.Playables.DirectorUpdateMode): void;
                public GetResolver(): UnityEngine.IExposedPropertyTable;
                public SetResolver($value: UnityEngine.IExposedPropertyTable): void;
                public GetPlayableCount(): number;
                public GetRootPlayableCount(): number;
                public GetOutputCount(): number;
                public GetEditorName(): string;
            }

            enum PlayState {
                Paused = 0,
                Playing = 1,
                Delayed = 2
            }

            class PlayableHandle implements System.IEquatable$1<UnityEngine.Playables.PlayableHandle> {
                protected [__keep_incompatibility]: never;
                public static get Null(): UnityEngine.Playables.PlayableHandle;
                public Equals($p: any): boolean;
                public Equals($other: UnityEngine.Playables.PlayableHandle): boolean;
                public GetHashCode(): number;
            }

            class PlayableOutput implements System.IEquatable$1<UnityEngine.Playables.PlayableOutput>, UnityEngine.Playables.IPlayableOutput {
                protected [__keep_incompatibility]: never;
                public static get Null(): UnityEngine.Playables.PlayableOutput;
                public GetHandle(): UnityEngine.Playables.PlayableOutputHandle;
                public IsPlayableOutputOfType<T extends UnityEngine.Playables.IPlayableOutput>(): boolean;
                public GetPlayableOutputType(): System.Type;
                public Equals($other: UnityEngine.Playables.PlayableOutput): boolean;
            }

            class PlayableOutputExtensions {
                protected [__keep_incompatibility]: never;
                public static IsOutputNull<U extends UnityEngine.Playables.IPlayableOutput>(): boolean;
                public static IsOutputValid<U extends UnityEngine.Playables.IPlayableOutput>(): boolean;
                public static GetReferenceObject<U extends UnityEngine.Playables.IPlayableOutput>(): UnityEngine.Object;
                public static SetReferenceObject<U extends UnityEngine.Playables.IPlayableOutput>($value: UnityEngine.Object): void;
                public static GetUserData<U extends UnityEngine.Playables.IPlayableOutput>(): UnityEngine.Object;
                public static SetUserData<U extends UnityEngine.Playables.IPlayableOutput>($value: UnityEngine.Object): void;
                public static GetSourcePlayable<U extends UnityEngine.Playables.IPlayableOutput>(): UnityEngine.Playables.Playable;
                public static SetSourcePlayable<U extends UnityEngine.Playables.IPlayableOutput, V extends UnityEngine.Playables.IPlayable>($value: V): void;
                public static SetSourcePlayable<U extends UnityEngine.Playables.IPlayableOutput, V extends UnityEngine.Playables.IPlayable>($value: V, $port: number): void;
                public static GetSourceOutputPort<U extends UnityEngine.Playables.IPlayableOutput>(): number;
                public static GetWeight<U extends UnityEngine.Playables.IPlayableOutput>(): number;
                public static SetWeight<U extends UnityEngine.Playables.IPlayableOutput>($value: number): void;
                public static PushNotification<U extends UnityEngine.Playables.IPlayableOutput>($origin: UnityEngine.Playables.Playable, $notification: UnityEngine.Playables.INotification, $context?: any): void;
                public static GetNotificationReceivers<U extends UnityEngine.Playables.IPlayableOutput>(): System.Array$1<UnityEngine.Playables.INotificationReceiver>;
                public static AddNotificationReceiver<U extends UnityEngine.Playables.IPlayableOutput>($receiver: UnityEngine.Playables.INotificationReceiver): void;
                public static RemoveNotificationReceiver<U extends UnityEngine.Playables.IPlayableOutput>($receiver: UnityEngine.Playables.INotificationReceiver): void;
                public static GetSourceInputPort<U extends UnityEngine.Playables.IPlayableOutput>(): number;
                public static SetSourceInputPort<U extends UnityEngine.Playables.IPlayableOutput>($value: number): void;
                public static SetSourceOutputPort<U extends UnityEngine.Playables.IPlayableOutput>($value: number): void;
            }

            class PlayableOutputHandle implements System.IEquatable$1<UnityEngine.Playables.PlayableOutputHandle> {
                protected [__keep_incompatibility]: never;
                public static get Null(): UnityEngine.Playables.PlayableOutputHandle;
                public GetHashCode(): number;
                public Equals($p: any): boolean;
                public Equals($other: UnityEngine.Playables.PlayableOutputHandle): boolean;
            }

            class ScriptPlayable<T extends UnityEngine.Playables.IPlayableBehaviour> implements System.IEquatable$1<UnityEngine.Playables.ScriptPlayable$1<T>>, UnityEngine.Playables.IPlayable {
                protected [__keep_incompatibility]: never;
                public static get Null(): UnityEngine.Playables.ScriptPlayable$1<T>;
                public static Create($graph: UnityEngine.Playables.PlayableGraph, $inputCount?: number): UnityEngine.Playables.ScriptPlayable$1<T>;
                public static Create($graph: UnityEngine.Playables.PlayableGraph, $template: T, $inputCount?: number): UnityEngine.Playables.ScriptPlayable$1<T>;
                public GetHandle(): UnityEngine.Playables.PlayableHandle;
                public GetBehaviour(): T;
                public Equals($other: UnityEngine.Playables.ScriptPlayable$1<T>): boolean;
            }

            class ScriptPlayableBinding {
                protected [__keep_incompatibility]: never;
                public static Create($name: string, $key: UnityEngine.Object, $type: System.Type): UnityEngine.Playables.PlayableBinding;
            }

            class ScriptPlayableOutput implements UnityEngine.Playables.IPlayableOutput {
                protected [__keep_incompatibility]: never;
                public static get Null(): UnityEngine.Playables.ScriptPlayableOutput;
                public static Create($graph: UnityEngine.Playables.PlayableGraph, $name: string): UnityEngine.Playables.ScriptPlayableOutput;
                public GetHandle(): UnityEngine.Playables.PlayableOutputHandle;
            }

        }
    }
    namespace UnityEngine {
        namespace PlayerLoop {
            class TimeUpdate {
                protected [__keep_incompatibility]: never;
            }
            namespace TimeUpdate {
                class WaitForLastPresentationAndUpdateTime {
                    protected [__keep_incompatibility]: never;
                }

                class ProfilerStartFrame {
                    protected [__keep_incompatibility]: never;
                }

            }

            class Initialization {
                protected [__keep_incompatibility]: never;
            }
            namespace Initialization {
                class ProfilerStartFrame {
                    protected [__keep_incompatibility]: never;
                }

                class PlayerUpdateTime {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateCameraMotionVectors {
                    protected [__keep_incompatibility]: never;
                }

                class DirectorSampleTime {
                    protected [__keep_incompatibility]: never;
                }

                class AsyncUploadTimeSlicedUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class SynchronizeState {
                    protected [__keep_incompatibility]: never;
                }

                class SynchronizeInputs {
                    protected [__keep_incompatibility]: never;
                }

                class XREarlyUpdate {
                    protected [__keep_incompatibility]: never;
                }

            }

            class EarlyUpdate {
                protected [__keep_incompatibility]: never;
            }
            namespace EarlyUpdate {
                class PollPlayerConnection {
                    protected [__keep_incompatibility]: never;
                }

                class ProfilerStartFrame {
                    protected [__keep_incompatibility]: never;
                }

                class PollHtcsPlayerConnection {
                    protected [__keep_incompatibility]: never;
                }

                class GpuTimestamp {
                    protected [__keep_incompatibility]: never;
                }

                class AnalyticsCoreStatsUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class InsightsUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class UnityWebRequestUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateStreamingManager {
                    protected [__keep_incompatibility]: never;
                }

                class ExecuteMainThreadJobs {
                    protected [__keep_incompatibility]: never;
                }

                class ProcessMouseInWindow {
                    protected [__keep_incompatibility]: never;
                }

                class ClearIntermediateRenderers {
                    protected [__keep_incompatibility]: never;
                }

                class ClearLines {
                    protected [__keep_incompatibility]: never;
                }

                class PresentBeforeUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class ResetFrameStatsAfterPresent {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateAsyncReadbackManager {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateTextureStreamingManager {
                    protected [__keep_incompatibility]: never;
                }

                class UpdatePreloading {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateContentLoading {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateAsyncInstantiate {
                    protected [__keep_incompatibility]: never;
                }

                class RendererNotifyInvisible {
                    protected [__keep_incompatibility]: never;
                }

                class PlayerCleanupCachedData {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateMainGameViewRect {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateCanvasRectTransform {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateInputManager {
                    protected [__keep_incompatibility]: never;
                }

                class ProcessRemoteInput {
                    protected [__keep_incompatibility]: never;
                }

                class XRUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class ScriptRunDelayedStartupFrame {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateKinect {
                    protected [__keep_incompatibility]: never;
                }

                class DeliverIosPlatformEvents {
                    protected [__keep_incompatibility]: never;
                }

                class DispatchEventQueueEvents {
                    protected [__keep_incompatibility]: never;
                }

                class Physics2DEarlyUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class PhysicsResetInterpolatedTransformPosition {
                    protected [__keep_incompatibility]: never;
                }

                class SpriteAtlasManagerUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class TangoUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class ARCoreUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class PerformanceAnalyticsUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class TilemapRendererEarlyUpdate {
                    protected [__keep_incompatibility]: never;
                }

            }

            class FixedUpdate {
                protected [__keep_incompatibility]: never;
            }
            namespace FixedUpdate {
                class ClearLines {
                    protected [__keep_incompatibility]: never;
                }

                class DirectorFixedSampleTime {
                    protected [__keep_incompatibility]: never;
                }

                class AudioFixedUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class ScriptRunBehaviourFixedUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class DirectorFixedUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class LegacyFixedAnimationUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class XRFixedUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class PhysicsFixedUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class Physics2DFixedUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class DirectorFixedUpdatePostPhysics {
                    protected [__keep_incompatibility]: never;
                }

                class ScriptRunDelayedFixedFrameRate {
                    protected [__keep_incompatibility]: never;
                }

                class NewInputFixedUpdate {
                    protected [__keep_incompatibility]: never;
                }

            }

            class PreUpdate {
                protected [__keep_incompatibility]: never;
            }
            namespace PreUpdate {
                class PhysicsUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class Physics2DUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class CheckTexFieldInput {
                    protected [__keep_incompatibility]: never;
                }

                class IMGUISendQueuedEvents {
                    protected [__keep_incompatibility]: never;
                }

                class SendMouseEvents {
                    protected [__keep_incompatibility]: never;
                }

                class AIUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class WindUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateVideo {
                    protected [__keep_incompatibility]: never;
                }

                class NewInputUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class InputForUIUpdate {
                    protected [__keep_incompatibility]: never;
                }

            }

            class Update {
                protected [__keep_incompatibility]: never;
            }
            namespace Update {
                class ScriptRunBehaviourUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class DirectorUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class ScriptRunDelayedDynamicFrameRate {
                    protected [__keep_incompatibility]: never;
                }

                class ScriptRunDelayedTasks {
                    protected [__keep_incompatibility]: never;
                }

            }

            class PreLateUpdate {
                protected [__keep_incompatibility]: never;
            }
            namespace PreLateUpdate {
                class Physics2DLateUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class PhysicsLateUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class AIUpdatePostScript {
                    protected [__keep_incompatibility]: never;
                }

                class DirectorUpdateAnimationBegin {
                    protected [__keep_incompatibility]: never;
                }

                class LegacyAnimationUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class DirectorUpdateAnimationEnd {
                    protected [__keep_incompatibility]: never;
                }

                class DirectorDeferredEvaluate {
                    protected [__keep_incompatibility]: never;
                }

                class AccessibilityUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class UIElementsUpdatePanels {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateNetworkManager {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateMasterServerInterface {
                    protected [__keep_incompatibility]: never;
                }

                class EndGraphicsJobsAfterScriptUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class ParticleSystemBeginUpdateAll {
                    protected [__keep_incompatibility]: never;
                }

                class ScriptRunBehaviourLateUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class ConstraintManagerUpdate {
                    protected [__keep_incompatibility]: never;
                }

            }

            class PostLateUpdate {
                protected [__keep_incompatibility]: never;
            }
            namespace PostLateUpdate {
                class PlayerSendFrameStarted {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateRectTransform {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateCanvasRectTransform {
                    protected [__keep_incompatibility]: never;
                }

                class PlayerUpdateCanvases {
                    protected [__keep_incompatibility]: never;
                }

                class AccessibilityLateUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateAudio {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateVideo {
                    protected [__keep_incompatibility]: never;
                }

                class DirectorLateUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class ScriptRunDelayedDynamicFrameRate {
                    protected [__keep_incompatibility]: never;
                }

                class VFXUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class ParticleSystemEndUpdateAll {
                    protected [__keep_incompatibility]: never;
                }

                class EndGraphicsJobsAfterScriptLateUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateSubstance {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateCustomRenderTextures {
                    protected [__keep_incompatibility]: never;
                }

                class XRPostLateUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateAllRenderers {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateLightProbeProxyVolumes {
                    protected [__keep_incompatibility]: never;
                }

                class EnlightenRuntimeUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateAllSkinnedMeshes {
                    protected [__keep_incompatibility]: never;
                }

                class ProcessWebSendMessages {
                    protected [__keep_incompatibility]: never;
                }

                class RenderAs2DUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class SortingGroupsUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateVideoTextures {
                    protected [__keep_incompatibility]: never;
                }

                class DirectorRenderImage {
                    protected [__keep_incompatibility]: never;
                }

                class PlayerEmitCanvasGeometry {
                    protected [__keep_incompatibility]: never;
                }

                class FinishFrameRendering {
                    protected [__keep_incompatibility]: never;
                }

                class BatchModeUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class PlayerSendFrameComplete {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateCaptureScreenshot {
                    protected [__keep_incompatibility]: never;
                }

                class PresentAfterDraw {
                    protected [__keep_incompatibility]: never;
                }

                class ClearImmediateRenderers {
                    protected [__keep_incompatibility]: never;
                }

                class XRPostPresent {
                    protected [__keep_incompatibility]: never;
                }

                class UpdateResolution {
                    protected [__keep_incompatibility]: never;
                }

                class InputEndFrame {
                    protected [__keep_incompatibility]: never;
                }

                class GUIClearEvents {
                    protected [__keep_incompatibility]: never;
                }

                class ShaderHandleErrors {
                    protected [__keep_incompatibility]: never;
                }

                class ResetInputAxis {
                    protected [__keep_incompatibility]: never;
                }

                class ThreadedLoadingDebug {
                    protected [__keep_incompatibility]: never;
                }

                class ProfilerSynchronizeStats {
                    protected [__keep_incompatibility]: never;
                }

                class MemoryFrameMaintenance {
                    protected [__keep_incompatibility]: never;
                }

                class ExecuteGameCenterCallbacks {
                    protected [__keep_incompatibility]: never;
                }

                class XRPreEndFrame {
                    protected [__keep_incompatibility]: never;
                }

                class ProfilerEndFrame {
                    protected [__keep_incompatibility]: never;
                }

                class GraphicsWarmupPreloadedShaders {
                    protected [__keep_incompatibility]: never;
                }

                class PlayerSendFramePostPresent {
                    protected [__keep_incompatibility]: never;
                }

                class PhysicsSkinnedClothBeginUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class PhysicsSkinnedClothFinishUpdate {
                    protected [__keep_incompatibility]: never;
                }

                class TriggerEndOfFrameCallbacks {
                    protected [__keep_incompatibility]: never;
                }

                class ObjectDispatcherPostLateUpdate {
                    protected [__keep_incompatibility]: never;
                }

            }

        }
    }
    namespace UnityEngine {
        namespace Pool {
            class CollectionPool<TCollection extends System.Collections.Generic.ICollection$1<TItem>, TItem> {
                protected [__keep_incompatibility]: never;
                constructor();
                public static Get(): TCollection;
                public static Get($value: $Out<TCollection>): UnityEngine.Pool.PooledObject$1<TCollection>;
                public static Release($toRelease: TCollection): void;
            }

            class ListPool<T> extends UnityEngine.Pool.CollectionPool$2<System.Collections.Generic.List$1<T>, T> {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class HashSetPool<T> extends UnityEngine.Pool.CollectionPool$2<System.Collections.Generic.HashSet$1<T>, T> {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class DictionaryPool<TKey, TValue> extends UnityEngine.Pool.CollectionPool$2<System.Collections.Generic.Dictionary$2<TKey, TValue>, System.Collections.Generic.KeyValuePair$2<TKey, TValue>> {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class GenericPool<T extends object> {
                protected [__keep_incompatibility]: never;
                constructor();
                public static Get(): T;
                public static Get($value: $Out<T>): UnityEngine.Pool.PooledObject$1<T>;
                public static Release($toRelease: T): void;
            }

            interface IObjectPool<T extends object> {
                get CountInactive(): number;
                Get(): T;
                Get($v: $Out<T>): UnityEngine.Pool.PooledObject$1<T>;
                Release($element: T): void;
                Clear(): void;
            }

            class LinkedPool<T extends object> implements UnityEngine.Pool.IObjectPool$1<T>, UnityEngine.Pool.IPool, System.IDisposable {
                protected [__keep_incompatibility]: never;
                public get CountInactive(): number;
                constructor($createFunc: System.Func$1<T>, $actionOnGet?: System.Action$1<T>, $actionOnRelease?: System.Action$1<T>, $actionOnDestroy?: System.Action$1<T>, $collectionCheck?: boolean, $maxSize?: number);
                public Get(): T;
                public Get($v: $Out<T>): UnityEngine.Pool.PooledObject$1<T>;
                public Release($item: T): void;
                public Clear(): void;
                public Dispose(): void;
            }

            class ObjectPool<T extends object> implements UnityEngine.Pool.IObjectPool$1<T>, UnityEngine.Pool.IPool, System.IDisposable {
                protected [__keep_incompatibility]: never;
                public get CountAll(): number;
                public get CountActive(): number;
                public get CountInactive(): number;
                constructor($createFunc: System.Func$1<T>, $actionOnGet?: System.Action$1<T>, $actionOnRelease?: System.Action$1<T>, $actionOnDestroy?: System.Action$1<T>, $collectionCheck?: boolean, $defaultCapacity?: number, $maxSize?: number);
                public Get(): T;
                public Get($v: $Out<T>): UnityEngine.Pool.PooledObject$1<T>;
                public Release($element: T): void;
                public Clear(): void;
                public Dispose(): void;
            }

            class PooledObject<T extends object> implements System.IDisposable {
                protected [__keep_incompatibility]: never;
                constructor($value: T, $pool: UnityEngine.Pool.IObjectPool$1<T>);
            }

            class UnsafeGenericPool<T extends object> {
                protected [__keep_incompatibility]: never;
                public static Get(): T;
                public static Get($value: $Out<T>): UnityEngine.Pool.PooledObject$1<T>;
                public static Release($toRelease: T): void;
            }

        }
    }
    namespace UnityEngine {
        namespace Profiling {
            enum ProfilerArea {
                CPU = 0,
                GPU = 1,
                Rendering = 2,
                Memory = 3,
                Audio = 4,
                Video = 5,
                Physics = 6,
                Physics2D = 7,
                NetworkMessages = 8,
                NetworkOperations = 9,
                UI = 10,
                UIDetails = 11,
                GlobalIllumination = 12,
                VirtualTexturing = 13
            }

            class Profiler {
                protected [__keep_incompatibility]: never;
                public static get supported(): boolean;
                public static logFile: string;
                public static enableBinaryLog: boolean;
                public static maxUsedMemory: number;
                public static enabled: boolean;
                public static enableAllocationCallstacks: boolean;
                public static get areaCount(): number;
                public static maxNumberOfSamplesPerFrame: number;
                public static get usedHeapSize(): number;
                public static get usedHeapSizeLong(): bigint;
                public static SetAreaEnabled($area: UnityEngine.Profiling.ProfilerArea, $enabled: boolean): void;
                public static GetAreaEnabled($area: UnityEngine.Profiling.ProfilerArea): boolean;
                public static AddFramesFromFile($file: string): void;
                public static SetScreenshotCaptureFrameInterval($frames: number): void;
                public static BeginThreadProfiling($threadGroupName: string, $threadName: string): void;
                public static EndThreadProfiling(): void;
                public static BeginSample($name: string): void;
                public static BeginSample($name: string, $targetObject: UnityEngine.Object): void;
                public static EndSample(): void;
                public static GetRuntimeMemorySize($o: UnityEngine.Object): number;
                public static GetRuntimeMemorySizeLong($o: UnityEngine.Object): bigint;
                public static GetMonoHeapSize(): number;
                public static GetMonoHeapSizeLong(): bigint;
                public static GetMonoUsedSize(): number;
                public static GetMonoUsedSizeLong(): bigint;
                public static SetTempAllocatorRequestedSize($size: number): boolean;
                public static GetTempAllocatorSize(): number;
                public static GetTotalAllocatedMemory(): number;
                public static GetTotalAllocatedMemoryLong(): bigint;
                public static GetTotalUnusedReservedMemory(): number;
                public static GetTotalUnusedReservedMemoryLong(): bigint;
                public static GetTotalReservedMemory(): number;
                public static GetTotalReservedMemoryLong(): bigint;
                public static GetTotalFragmentationInfo($stats: Unity.Collections.NativeArray$1<number>): bigint;
                public static GetAllocatedMemoryForGraphicsDriver(): bigint;
                public static EmitFrameMetaData($id: System.Guid, $tag: number, $data: System.Array): void;
                public static EmitFrameMetaData<T>($id: System.Guid, $tag: number, $data: System.Collections.Generic.List$1<T>): void;
                public static EmitFrameMetaData<T>($id: System.Guid, $tag: number, $data: Unity.Collections.NativeArray$1<T>): void;
                public static EmitSessionMetaData($id: System.Guid, $tag: number, $data: System.Array): void;
                public static EmitSessionMetaData<T>($id: System.Guid, $tag: number, $data: System.Collections.Generic.List$1<T>): void;
                public static EmitSessionMetaData<T>($id: System.Guid, $tag: number, $data: Unity.Collections.NativeArray$1<T>): void;
                public static SetCategoryEnabled($category: Unity.Profiling.ProfilerCategory, $enabled: boolean): void;
                public static IsCategoryEnabled($category: Unity.Profiling.ProfilerCategory): boolean;
                public static GetCategoriesCount(): number;
                public static GetAllCategories($categories: System.Array$1<Unity.Profiling.ProfilerCategory>): void;
                public static GetAllCategories($categories: Unity.Collections.NativeArray$1<Unity.Profiling.ProfilerCategory>): void;
            }

            class Recorder {
                protected [__keep_incompatibility]: never;
                public get isValid(): boolean;
                public enabled: boolean;
                public get elapsedNanoseconds(): bigint;
                public get gpuElapsedNanoseconds(): bigint;
                public get sampleBlockCount(): number;
                public get gpuSampleBlockCount(): number;
                public static Get($samplerName: string): UnityEngine.Profiling.Recorder;
                public FilterToCurrentThread(): void;
                public CollectFromAllThreads(): void;
            }

            class Sampler {
                protected [__keep_incompatibility]: never;
                public get isValid(): boolean;
                public get name(): string;
                public GetRecorder(): UnityEngine.Profiling.Recorder;
                public static Get($name: string): UnityEngine.Profiling.Sampler;
                public static GetNames($names: System.Collections.Generic.List$1<string>): number;
            }

            class CustomSampler extends UnityEngine.Profiling.Sampler {
                protected [__keep_incompatibility]: never;
                public static Create($name: string, $collectGpuData?: boolean): UnityEngine.Profiling.CustomSampler;
                public Begin(): void;
                public Begin($targetObject: UnityEngine.Object): void;
                public End(): void;
            }

        }
    }
    namespace UnityEngine {
        namespace Profiling {
            namespace Experimental {
                class DebugScreenCapture {
                    protected [__keep_incompatibility]: never;
                }

            }
        }
    }
    namespace UnityEngine {
        namespace Profiling {
            namespace Memory {
                namespace Experimental {
                    class MetaData {
                        protected [__keep_incompatibility]: never;
                        public platform: string;
                        constructor();
                    }

                    enum CaptureFlags {
                        ManagedObjects = 1,
                        NativeObjects = 2,
                        NativeAllocations = 4,
                        NativeAllocationSites = 8,
                        NativeStackTraces = 16
                    }

                    class MemoryProfiler {
                        protected [__keep_incompatibility]: never;
                    }

                }
            }
        }
    }
    namespace UnityEngine {
        namespace Rendering {
            class SortingGroup extends UnityEngine.Behaviour {
                protected [__keep_incompatibility]: never;
                public sortingLayerName: string;
                public sortingLayerID: number;
                public sortingOrder: number;
                public sortAtRoot: boolean;
                constructor();
                public static UpdateAllSortingGroups(): void;
            }

            class AsyncGPUReadbackRequest {
                protected [__keep_incompatibility]: never;
                public get done(): boolean;
                public get hasError(): boolean;
                public get layerCount(): number;
                public get layerDataSize(): number;
                public get width(): number;
                public get height(): number;
                public get depth(): number;
                public forcePlayerLoopUpdate: boolean;
                public Update(): void;
                public WaitForCompletion(): void;
                public GetData<T>($layer?: number): Unity.Collections.NativeArray$1<T>;
            }

            class AsyncGPUReadback {
                protected [__keep_incompatibility]: never;
                public static WaitAllRequests(): void;
                public static Request($src: UnityEngine.ComputeBuffer, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static Request($src: UnityEngine.ComputeBuffer, $size: number, $offset: number, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static Request($src: UnityEngine.GraphicsBuffer, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static Request($src: UnityEngine.GraphicsBuffer, $size: number, $offset: number, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static Request($src: UnityEngine.Texture, $mipIndex?: number, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static Request($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static Request($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static Request($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static Request($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static Request($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.ComputeBuffer, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.ComputeBuffer, $size: number, $offset: number, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.GraphicsBuffer, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.GraphicsBuffer, $size: number, $offset: number, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex?: number, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.ComputeBuffer, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.ComputeBuffer, $size: number, $offset: number, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.GraphicsBuffer, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.GraphicsBuffer, $size: number, $offset: number, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex?: number, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback?: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): UnityEngine.Rendering.AsyncGPUReadbackRequest;
                public static RequestAsync($src: UnityEngine.ComputeBuffer): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestAsync($src: UnityEngine.ComputeBuffer, $size: number, $offset: number): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestAsync($src: UnityEngine.GraphicsBuffer): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestAsync($src: UnityEngine.GraphicsBuffer, $size: number, $offset: number): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestAsync($src: UnityEngine.Texture, $mipIndex?: number): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestAsync($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestAsync($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestAsync($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestAsync($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestAsync($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeArrayAsync<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.ComputeBuffer): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeSliceAsync<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.ComputeBuffer): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeArrayAsync<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.ComputeBuffer, $size: number, $offset: number): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeSliceAsync<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.ComputeBuffer, $size: number, $offset: number): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeArrayAsync<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.GraphicsBuffer): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeSliceAsync<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.GraphicsBuffer): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeArrayAsync<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.GraphicsBuffer, $size: number, $offset: number): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeSliceAsync<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.GraphicsBuffer, $size: number, $offset: number): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeArrayAsync<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex?: number): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeSliceAsync<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex?: number): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeArrayAsync<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeSliceAsync<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeArrayAsync<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeSliceAsync<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeArrayAsync<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeSliceAsync<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeArrayAsync<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
                public static RequestIntoNativeSliceAsync<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat): UnityEngine.Awaitable$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>;
            }

            enum SynchronisationStage {
                VertexProcessing = 0,
                PixelProcessing = 1
            }

            class GPUFence {
                protected [__keep_incompatibility]: never;
                public get passed(): boolean;
            }

            class PIX {
                protected [__keep_incompatibility]: never;
                constructor();
                public static BeginGPUCapture(): void;
                public static EndGPUCapture(): void;
                public static IsAttached(): boolean;
            }

            class LoadStoreActionDebugModeSettings {
                protected [__keep_incompatibility]: never;
                public static LoadStoreDebugModeEnabled: boolean;
            }

            enum ShaderHardwareTier {
                Tier1 = 0,
                Tier2 = 1,
                Tier3 = 2
            }

            enum BlendShapeBufferLayout {
                PerShape = 0,
                PerVertex = 1
            }

            enum RayTracingAccelerationStructureBuildFlags {
                None = 0,
                PreferFastTrace = 1,
                PreferFastBuild = 2,
                MinimizeMemory = 4
            }

            enum IndexFormat {
                UInt16 = 0,
                UInt32 = 1
            }

            enum MeshUpdateFlags {
                Default = 0,
                DontValidateIndices = 1,
                DontResetBoneBounds = 2,
                DontNotifyMeshUsers = 4,
                DontRecalculateBounds = 8,
                DontValidateLodRanges = 16
            }

            enum VertexAttributeFormat {
                Float32 = 0,
                Float16 = 1,
                UNorm8 = 2,
                SNorm8 = 3,
                UNorm16 = 4,
                SNorm16 = 5,
                UInt8 = 6,
                SInt8 = 7,
                UInt16 = 8,
                SInt16 = 9,
                UInt32 = 10,
                SInt32 = 11
            }

            enum VertexAttribute {
                Position = 0,
                Normal = 1,
                Tangent = 2,
                Color = 3,
                TexCoord0 = 4,
                TexCoord1 = 5,
                TexCoord2 = 6,
                TexCoord3 = 7,
                TexCoord4 = 8,
                TexCoord5 = 9,
                TexCoord6 = 10,
                TexCoord7 = 11,
                BlendWeight = 12,
                BlendIndices = 13
            }

            enum ShaderParamType {
                Float = 0,
                Int = 1,
                Bool = 2,
                Half = 3,
                Short = 4,
                UInt = 5
            }

            enum ShaderConstantType {
                Vector = 0,
                Matrix = 1,
                Struct = 2
            }

            enum OpaqueSortMode {
                Default = 0,
                FrontToBack = 1,
                NoDistanceSort = 2
            }

            enum RenderQueue {
                Background = 1000,
                Geometry = 2000,
                AlphaTest = 2450,
                GeometryLast = 2500,
                Transparent = 3000,
                Overlay = 4000
            }

            enum RenderBufferLoadAction {
                Load = 0,
                Clear = 1,
                DontCare = 2
            }

            enum RenderBufferStoreAction {
                Store = 0,
                Resolve = 1,
                StoreAndResolve = 2,
                DontCare = 3
            }

            enum FastMemoryFlags {
                None = 0,
                SpillTop = 1,
                SpillBottom = 2
            }

            enum BlendMode {
                Zero = 0,
                One = 1,
                DstColor = 2,
                SrcColor = 3,
                OneMinusDstColor = 4,
                SrcAlpha = 5,
                OneMinusSrcColor = 6,
                DstAlpha = 7,
                OneMinusDstAlpha = 8,
                SrcAlphaSaturate = 9,
                OneMinusSrcAlpha = 10
            }

            enum BlendOp {
                Add = 0,
                Subtract = 1,
                ReverseSubtract = 2,
                Min = 3,
                Max = 4,
                LogicalClear = 5,
                LogicalSet = 6,
                LogicalCopy = 7,
                LogicalCopyInverted = 8,
                LogicalNoop = 9,
                LogicalInvert = 10,
                LogicalAnd = 11,
                LogicalNand = 12,
                LogicalOr = 13,
                LogicalNor = 14,
                LogicalXor = 15,
                LogicalEquivalence = 16,
                LogicalAndReverse = 17,
                LogicalAndInverted = 18,
                LogicalOrReverse = 19,
                LogicalOrInverted = 20,
                Multiply = 21,
                Screen = 22,
                Overlay = 23,
                Darken = 24,
                Lighten = 25,
                ColorDodge = 26,
                ColorBurn = 27,
                HardLight = 28,
                SoftLight = 29,
                Difference = 30,
                Exclusion = 31,
                HSLHue = 32,
                HSLSaturation = 33,
                HSLColor = 34,
                HSLLuminosity = 35
            }

            enum CompareFunction {
                Disabled = 0,
                Never = 1,
                Less = 2,
                Equal = 3,
                LessEqual = 4,
                Greater = 5,
                NotEqual = 6,
                GreaterEqual = 7,
                Always = 8
            }

            enum CullMode {
                Off = 0,
                Front = 1,
                Back = 2
            }

            enum ColorWriteMask {
                Alpha = 1,
                Blue = 2,
                Green = 4,
                Red = 8,
                All = 15
            }

            enum StencilOp {
                Keep = 0,
                Zero = 1,
                Replace = 2,
                IncrementSaturate = 3,
                DecrementSaturate = 4,
                Invert = 5,
                IncrementWrap = 6,
                DecrementWrap = 7
            }

            enum AmbientMode {
                Skybox = 0,
                Trilight = 1,
                Flat = 3,
                Custom = 4
            }

            enum DefaultReflectionMode {
                Skybox = 0,
                Custom = 1
            }

            enum ReflectionCubemapCompression {
                Uncompressed = 0,
                Compressed = 1,
                Auto = 2
            }

            enum CameraEvent {
                BeforeDepthTexture = 0,
                AfterDepthTexture = 1,
                BeforeDepthNormalsTexture = 2,
                AfterDepthNormalsTexture = 3,
                BeforeGBuffer = 4,
                AfterGBuffer = 5,
                BeforeLighting = 6,
                AfterLighting = 7,
                BeforeFinalPass = 8,
                AfterFinalPass = 9,
                BeforeForwardOpaque = 10,
                AfterForwardOpaque = 11,
                BeforeImageEffectsOpaque = 12,
                AfterImageEffectsOpaque = 13,
                BeforeSkybox = 14,
                AfterSkybox = 15,
                BeforeForwardAlpha = 16,
                AfterForwardAlpha = 17,
                BeforeImageEffects = 18,
                AfterImageEffects = 19,
                AfterEverything = 20,
                BeforeReflections = 21,
                AfterReflections = 22,
                BeforeHaloAndLensFlares = 23,
                AfterHaloAndLensFlares = 24
            }

            enum LightEvent {
                BeforeShadowMap = 0,
                AfterShadowMap = 1,
                BeforeScreenspaceMask = 2,
                AfterScreenspaceMask = 3,
                BeforeShadowMapPass = 4,
                AfterShadowMapPass = 5
            }

            enum ShadowMapPass {
                PointlightPositiveX = 1,
                PointlightNegativeX = 2,
                PointlightPositiveY = 4,
                PointlightNegativeY = 8,
                PointlightPositiveZ = 16,
                PointlightNegativeZ = 32,
                Pointlight = 63,
                DirectionalCascade0 = 64,
                DirectionalCascade1 = 128,
                DirectionalCascade2 = 256,
                DirectionalCascade3 = 512,
                Directional = 960,
                Spotlight = 1024,
                All = 2047,
                AreaLight = 2048
            }

            enum BuiltinRenderTextureType {
                None = 0,
                CurrentActive = 1,
                CameraTarget = 2,
                Depth = 3,
                DepthNormals = 4,
                ResolvedDepth = 5,
                PrepassNormalsSpec = 7,
                PrepassLight = 8,
                PrepassLightSpec = 9,
                GBuffer0 = 10,
                GBuffer1 = 11,
                GBuffer2 = 12,
                GBuffer3 = 13,
                Reflections = 14,
                MotionVectors = 15,
                GBuffer4 = 16,
                GBuffer5 = 17,
                GBuffer6 = 18,
                GBuffer7 = 19,
                PropertyName = -4,
                BufferPtr = -3,
                RenderTexture = -2,
                BindableTexture = -1
            }

            enum PassType {
                Normal = 0,
                Vertex = 1,
                VertexLM = 2,
                VertexLMRGBM = 3,
                ForwardBase = 4,
                ForwardAdd = 5,
                LightPrePassBase = 6,
                LightPrePassFinal = 7,
                ShadowCaster = 8,
                Deferred = 10,
                Meta = 11,
                MotionVectors = 12,
                ScriptableRenderPipeline = 13,
                ScriptableRenderPipelineDefaultUnlit = 14,
                GrabPass = 15
            }

            enum ShadowCastingMode {
                Off = 0,
                On = 1,
                TwoSided = 2,
                ShadowsOnly = 3
            }

            enum LightShadowResolution {
                Low = 0,
                Medium = 1,
                High = 2,
                VeryHigh = 3,
                FromQualitySettings = -1
            }

            enum LightUnit {
                Lumen = 0,
                Candela = 1,
                Lux = 2,
                Nits = 3,
                Ev100 = 4
            }

            enum GraphicsDeviceType {
                OpenGL2 = 0,
                Direct3D9 = 1,
                Direct3D11 = 2,
                PlayStation3 = 3,
                Null = 4,
                Xbox360 = 6,
                OpenGLES2 = 8,
                OpenGLES3 = 11,
                PlayStationVita = 12,
                PlayStation4 = 13,
                XboxOne = 14,
                PlayStationMobile = 15,
                Metal = 16,
                OpenGLCore = 17,
                Direct3D12 = 18,
                N3DS = 19,
                Vulkan = 21,
                Switch = 22,
                XboxOneD3D12 = 23,
                GameCoreXboxOne = 24,
                GameCoreXboxSeries = 25,
                PlayStation5 = 26,
                PlayStation5NGGC = 27,
                WebGPU = 28,
                Switch2 = 29,
                GameCoreScarlett = -1
            }

            enum GraphicsTier {
                Tier1 = 0,
                Tier2 = 1,
                Tier3 = 2
            }

            class SubMeshDescriptor {
                protected [__keep_incompatibility]: never;
                public bounds: UnityEngine.Bounds;
                public topology: UnityEngine.MeshTopology;
                public indexStart: number;
                public indexCount: number;
                public baseVertex: number;
                public firstVertex: number;
                public vertexCount: number;
                constructor($indexStart: number, $indexCount: number, $topology?: UnityEngine.MeshTopology);
                public ToString(): string;
            }

            class VertexAttributeDescriptor implements System.IEquatable$1<UnityEngine.Rendering.VertexAttributeDescriptor> {
                protected [__keep_incompatibility]: never;
                public attribute: UnityEngine.Rendering.VertexAttribute;
                public format: UnityEngine.Rendering.VertexAttributeFormat;
                public dimension: number;
                public stream: number;
                constructor($attribute?: UnityEngine.Rendering.VertexAttribute, $format?: UnityEngine.Rendering.VertexAttributeFormat, $dimension?: number, $stream?: number);
                public ToString(): string;
                public GetHashCode(): number;
                public Equals($other: any): boolean;
                public Equals($other: UnityEngine.Rendering.VertexAttributeDescriptor): boolean;
            }

            enum FormatSwizzle {
                FormatSwizzleR = 0,
                FormatSwizzleG = 1,
                FormatSwizzleB = 2,
                FormatSwizzleA = 3,
                FormatSwizzle0 = 4,
                FormatSwizzle1 = 5
            }

            class RenderTargetIdentifier implements System.IEquatable$1<UnityEngine.Rendering.RenderTargetIdentifier> {
                protected [__keep_incompatibility]: never;
                public static readonly Invalid: UnityEngine.Rendering.RenderTargetIdentifier;
                public static readonly AllDepthSlices: number;
                constructor($type: UnityEngine.Rendering.BuiltinRenderTextureType);
                constructor($type: UnityEngine.Rendering.BuiltinRenderTextureType, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number);
                constructor($name: string);
                constructor($name: string, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number);
                constructor($nameID: number);
                constructor($nameID: number, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number);
                constructor($renderTargetIdentifier: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number);
                constructor($tex: UnityEngine.Texture);
                constructor($tex: UnityEngine.Texture, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number);
                constructor($buf: UnityEngine.RenderBuffer, $mipLevel?: number, $cubeFace?: UnityEngine.CubemapFace, $depthSlice?: number);
                public ToString(): string;
                public GetHashCode(): number;
                public Equals($rhs: UnityEngine.Rendering.RenderTargetIdentifier): boolean;
                public Equals($obj: any): boolean;
            }

            enum RenderTargetFlags {
                None = 0,
                ReadOnlyDepth = 1,
                ReadOnlyStencil = 2,
                ReadOnlyDepthStencil = 3
            }

            class RenderTargetBinding {
                protected [__keep_incompatibility]: never;
                public colorRenderTargets: System.Array$1<UnityEngine.Rendering.RenderTargetIdentifier>;
                public depthRenderTarget: UnityEngine.Rendering.RenderTargetIdentifier;
                public colorLoadActions: System.Array$1<UnityEngine.Rendering.RenderBufferLoadAction>;
                public colorStoreActions: System.Array$1<UnityEngine.Rendering.RenderBufferStoreAction>;
                public depthLoadAction: UnityEngine.Rendering.RenderBufferLoadAction;
                public depthStoreAction: UnityEngine.Rendering.RenderBufferStoreAction;
                public flags: UnityEngine.Rendering.RenderTargetFlags;
                constructor($colorRenderTargets: System.Array$1<UnityEngine.Rendering.RenderTargetIdentifier>, $colorLoadActions: System.Array$1<UnityEngine.Rendering.RenderBufferLoadAction>, $colorStoreActions: System.Array$1<UnityEngine.Rendering.RenderBufferStoreAction>, $depthRenderTarget: UnityEngine.Rendering.RenderTargetIdentifier, $depthLoadAction: UnityEngine.Rendering.RenderBufferLoadAction, $depthStoreAction: UnityEngine.Rendering.RenderBufferStoreAction);
                constructor($colorRenderTarget: UnityEngine.Rendering.RenderTargetIdentifier, $colorLoadAction: UnityEngine.Rendering.RenderBufferLoadAction, $colorStoreAction: UnityEngine.Rendering.RenderBufferStoreAction, $depthRenderTarget: UnityEngine.Rendering.RenderTargetIdentifier, $depthLoadAction: UnityEngine.Rendering.RenderBufferLoadAction, $depthStoreAction: UnityEngine.Rendering.RenderBufferStoreAction);
                constructor($setup: UnityEngine.RenderTargetSetup);
            }

            enum ReflectionProbeUsage {
                Off = 0,
                BlendProbes = 1,
                BlendProbesAndSkybox = 2,
                Simple = 3
            }

            enum ReflectionProbeType {
                Cube = 0,
                Card = 1
            }

            enum ReflectionProbeClearFlags {
                Skybox = 1,
                SolidColor = 2
            }

            enum ReflectionProbeMode {
                Baked = 0,
                Realtime = 1,
                Custom = 2
            }

            class ReflectionProbeBlendInfo {
                protected [__keep_incompatibility]: never;
                public probe: UnityEngine.ReflectionProbe;
                public weight: number;
            }

            enum ReflectionProbeRefreshMode {
                OnAwake = 0,
                EveryFrame = 1,
                ViaScripting = 2
            }

            enum ReflectionProbeTimeSlicingMode {
                AllFacesAtOnce = 0,
                IndividualFaces = 1,
                NoTimeSlicing = 2
            }

            enum ShadowSamplingMode {
                CompareDepths = 0,
                RawDepth = 1,
                None = 2
            }

            enum LightProbeUsage {
                Off = 0,
                BlendProbes = 1,
                UseProxyVolume = 2,
                CustomProvided = 4
            }

            enum BuiltinShaderType {
                DeferredShading = 0,
                DeferredReflections = 1,
                LegacyDeferredLighting = 2,
                ScreenSpaceShadows = 3,
                DepthNormals = 4,
                MotionVectors = 5,
                LightHalo = 6,
                LensFlare = 7
            }

            enum BuiltinShaderMode {
                Disabled = 0,
                UseBuiltin = 1,
                UseCustom = 2
            }

            enum BuiltinShaderDefine {
                UNITY_NO_DXT5nm = 0,
                UNITY_NO_RGBM = 1,
                UNITY_USE_NATIVE_HDR = 2,
                UNITY_ENABLE_REFLECTION_BUFFERS = 3,
                UNITY_FRAMEBUFFER_FETCH_AVAILABLE = 4,
                UNITY_ENABLE_NATIVE_SHADOW_LOOKUPS = 5,
                UNITY_METAL_SHADOWS_USE_POINT_FILTERING = 6,
                UNITY_NO_CUBEMAP_ARRAY = 7,
                UNITY_NO_SCREENSPACE_SHADOWS = 8,
                UNITY_USE_DITHER_MASK_FOR_ALPHABLENDED_SHADOWS = 9,
                UNITY_PBS_USE_BRDF1 = 10,
                UNITY_PBS_USE_BRDF2 = 11,
                UNITY_PBS_USE_BRDF3 = 12,
                UNITY_NO_FULL_STANDARD_SHADER = 13,
                UNITY_SPECCUBE_BOX_PROJECTION = 14,
                UNITY_SPECCUBE_BLENDING = 15,
                UNITY_ENABLE_DETAIL_NORMALMAP = 16,
                SHADER_API_MOBILE = 17,
                SHADER_API_DESKTOP = 18,
                UNITY_HARDWARE_TIER1 = 19,
                UNITY_HARDWARE_TIER2 = 20,
                UNITY_HARDWARE_TIER3 = 21,
                UNITY_COLORSPACE_GAMMA = 22,
                UNITY_LIGHT_PROBE_PROXY_VOLUME = 23,
                UNITY_HALF_PRECISION_FRAGMENT_SHADER_REGISTERS = 24,
                UNITY_LIGHTMAP_DLDR_ENCODING = 25,
                UNITY_LIGHTMAP_RGBM_ENCODING = 26,
                UNITY_LIGHTMAP_FULL_HDR = 27,
                UNITY_VIRTUAL_TEXTURING = 28,
                UNITY_PRETRANSFORM_TO_DISPLAY_ORIENTATION = 29,
                UNITY_ASTC_NORMALMAP_ENCODING = 30,
                SHADER_API_GLES30 = 31,
                SHADER_API_GLES31 = 32,
                SHADER_API_GLES32 = 33,
                UNITY_UNIFIED_SHADER_PRECISION_MODEL = 34,
                UNITY_PLATFORM_SUPPORTS_WAVE_32 = 35,
                UNITY_PLATFORM_SUPPORTS_WAVE_64 = 36,
                UNITY_NEEDS_RENDERPASS_FBFETCH_FALLBACK = 37,
                UNITY_PLATFORM_SUPPORTS_DEPTH_FETCH = 38
            }

            enum VideoShadersIncludeMode {
                Never = 0,
                Referenced = 1,
                Always = 2
            }

            enum TextureDimension {
                None = 0,
                Any = 1,
                Tex2D = 2,
                Tex3D = 3,
                Cube = 4,
                Tex2DArray = 5,
                CubeArray = 6,
                Unknown = -1
            }

            enum CopyTextureSupport {
                None = 0,
                Basic = 1,
                Copy3D = 2,
                DifferentTypes = 4,
                TextureToRT = 8,
                RTToTexture = 16
            }

            enum CameraHDRMode {
                FP16 = 1,
                R11G11B10 = 2
            }

            enum RealtimeGICPUUsage {
                Low = 25,
                Medium = 50,
                High = 75,
                Unlimited = 100
            }

            enum LightProbeOutsideHullStrategy {
                kLightProbeSearchTetrahedralHull = 0,
                kLightProbeUseAmbientProbe = 1
            }

            enum ComputeQueueType {
                Default = 0,
                Background = 1,
                Urgent = 2
            }

            enum SinglePassStereoMode {
                None = 0,
                SideBySide = 1,
                Instancing = 2,
                Multiview = 3
            }

            enum FoveatedRenderingCaps {
                None = 0,
                FoveationImage = 1,
                NonUniformRaster = 2,
                ModeChangeOnlyBeforeRenderTargetSet = 4
            }

            enum FoveatedRenderingMode {
                Disabled = 0,
                Enabled = 1
            }

            enum CommandBufferExecutionFlags {
                None = 0,
                AsyncCompute = 2
            }

            enum RTClearFlags {
                None = 0,
                Color = 1,
                Depth = 2,
                ColorDepth = 3,
                Stencil = 4,
                ColorStencil = 5,
                DepthStencil = 6,
                All = 7,
                Color0 = 8,
                Color1 = 16,
                Color2 = 32,
                Color3 = 64,
                Color4 = 128,
                Color5 = 256,
                Color6 = 512,
                Color7 = 1024
            }

            enum RenderTextureSubElement {
                Color = 0,
                Depth = 1,
                Stencil = 2,
                Default = 3,
                ShadingRate = 4
            }

            enum RenderingThreadingMode {
                Direct = 0,
                SingleThreaded = 1,
                MultiThreaded = 2,
                LegacyJobified = 3,
                NativeGraphicsJobs = 4,
                NativeGraphicsJobsWithoutRenderThread = 5,
                NativeGraphicsJobsSplitThreading = 6
            }

            enum CameraLateLatchMatrixType {
                View = 0,
                InverseView = 1,
                ViewProjection = 2,
                InverseViewProjection = 3
            }

            enum OpenGLESVersion {
                None = 0,
                OpenGLES20 = 1,
                OpenGLES30 = 2,
                OpenGLES31 = 3,
                OpenGLES31AEP = 4,
                OpenGLES32 = 5
            }

            enum CustomMarkerCallbackFlags {
                CustomMarkerCallbackDefault = 0,
                CustomMarkerCallbackForceInvalidateStateTracking = 4
            }

            enum ShadingRateFragmentSize {
                FragmentSize1x1 = 0,
                FragmentSize1x2 = 1,
                FragmentSize2x1 = 2,
                FragmentSize2x2 = 3,
                FragmentSize1x4 = 4,
                FragmentSize4x1 = 5,
                FragmentSize2x4 = 6,
                FragmentSize4x2 = 7,
                FragmentSize4x4 = 8
            }

            enum ShadingRateCombinerStage {
                Primitive = 0,
                Fragment = 1
            }

            enum ShadingRateCombiner {
                Keep = 0,
                Override = 1,
                Min = 2,
                Max = 3
            }

            enum SynchronisationStageFlags {
                VertexProcessing = 1,
                PixelProcessing = 2,
                ComputeProcessing = 4,
                AllGPUOperations = 7
            }

            enum GraphicsFenceType {
                AsyncQueueSynchronisation = 0,
                CPUSynchronisation = 1
            }

            class GraphicsFence {
                protected [__keep_incompatibility]: never;
                public get passed(): boolean;
            }

            class GraphicsSettings extends UnityEngine.Object {
                protected [__keep_incompatibility]: never;
                public static transparencySortMode: UnityEngine.TransparencySortMode;
                public static transparencySortAxis: UnityEngine.Vector3;
                public static realtimeDirectRectangularAreaLights: boolean;
                public static lightsUseLinearIntensity: boolean;
                public static lightsUseColorTemperature: boolean;
                public static defaultRenderingLayerMask: number;
                public static defaultGateFitMode: UnityEngine.Camera.GateFitMode;
                public static useScriptableRenderPipelineBatching: boolean;
                public static logWhenShaderIsCompiled: boolean;
                public static disableBuiltinCustomRenderTextureUpdate: boolean;
                public static videoShadersIncludeMode: UnityEngine.Rendering.VideoShadersIncludeMode;
                public static lightProbeOutsideHullStrategy: UnityEngine.Rendering.LightProbeOutsideHullStrategy;
                public static get currentRenderPipeline(): UnityEngine.Rendering.RenderPipelineAsset;
                public static get isScriptableRenderPipelineEnabled(): boolean;
                public static get currentRenderPipelineAssetType(): System.Type;
                public static renderPipelineAsset: UnityEngine.Rendering.RenderPipelineAsset;
                public static defaultRenderPipeline: UnityEngine.Rendering.RenderPipelineAsset;
                public static get allConfiguredRenderPipelines(): System.Array$1<UnityEngine.Rendering.RenderPipelineAsset>;
                public static cameraRelativeLightCulling: boolean;
                public static cameraRelativeShadowCulling: boolean;
                public static HasShaderDefine($tier: UnityEngine.Rendering.GraphicsTier, $defineHash: UnityEngine.Rendering.BuiltinShaderDefine): boolean;
                public static HasShaderDefine($defineHash: UnityEngine.Rendering.BuiltinShaderDefine): boolean;
                public static GetGraphicsSettings(): UnityEngine.Object;
                public static SetShaderMode($type: UnityEngine.Rendering.BuiltinShaderType, $mode: UnityEngine.Rendering.BuiltinShaderMode): void;
                public static GetShaderMode($type: UnityEngine.Rendering.BuiltinShaderType): UnityEngine.Rendering.BuiltinShaderMode;
                public static SetCustomShader($type: UnityEngine.Rendering.BuiltinShaderType, $shader: UnityEngine.Shader): void;
                public static GetCustomShader($type: UnityEngine.Rendering.BuiltinShaderType): UnityEngine.Shader;
                public static Subscribe<TChild extends UnityEngine.Rendering.IRenderPipelineGraphicsSettings>($callback: System.Action$2<TChild, string>): void;
                public static Unsubscribe<TChild extends UnityEngine.Rendering.IRenderPipelineGraphicsSettings>($callback: System.Action$2<TChild, string>): void;
                public static ForEach($callback: System.Action$1<UnityEngine.Rendering.IRenderPipelineGraphicsSettings>): void;
                public static UpdateGraphicsSettings($newSettings: UnityEngine.Rendering.RenderPipelineGlobalSettings, $renderPipelineType: System.Type): void;
                public static RegisterRenderPipelineSettings($renderPipelineType: System.Type, $settings: UnityEngine.Rendering.RenderPipelineGlobalSettings): void;
                public static RegisterRenderPipelineSettings<T extends UnityEngine.Rendering.RenderPipeline>($settings: UnityEngine.Rendering.RenderPipelineGlobalSettings): void;
                public static UnregisterRenderPipelineSettings<T extends UnityEngine.Rendering.RenderPipeline>(): void;
                public static UnregisterRenderPipelineSettings($renderPipelineType: System.Type): void;
                public static GetSettingsForRenderPipeline<T extends UnityEngine.Rendering.RenderPipeline>(): UnityEngine.Rendering.RenderPipelineGlobalSettings;
                public static GetSettingsForRenderPipeline($renderPipelineType: System.Type): UnityEngine.Rendering.RenderPipelineGlobalSettings;
                public static TryGetCurrentRenderPipelineGlobalSettings($asset: $Out<UnityEngine.Rendering.RenderPipelineGlobalSettings>): boolean;
                public static GetRenderPipelineSettings<T extends UnityEngine.Rendering.IRenderPipelineGraphicsSettings>(): T;
                public static TryGetRenderPipelineSettings<T extends UnityEngine.Rendering.IRenderPipelineGraphicsSettings>($settings: $Out<T>): boolean;
            }

            enum GraphicsTextureDescriptorFlags {
                None = 0,
                RenderTarget = 1,
                RandomWriteTarget = 2
            }

            class GraphicsTextureDescriptor {
                protected [__keep_incompatibility]: never;
                public width: number;
                public height: number;
                public depth: number;
                public arrayLength: number;
                public format: UnityEngine.Experimental.Rendering.GraphicsFormat;
                public dimension: UnityEngine.Rendering.TextureDimension;
                public mipCount: number;
                public numSamples: number;
                public flags: UnityEngine.Rendering.GraphicsTextureDescriptorFlags;
                constructor();
            }

            enum GraphicsTextureState {
                Constructed = 0,
                Initializing = 1,
                InitializedOnRenderThread = 2,
                DestroyQueued = 3,
                Destroyed = 4
            }

            class GraphicsTexture implements System.IDisposable {
                protected [__keep_incompatibility]: never;
                public get descriptor(): UnityEngine.Rendering.GraphicsTextureDescriptor;
                public get state(): UnityEngine.Rendering.GraphicsTextureState;
                public static active: UnityEngine.Rendering.GraphicsTexture;
                constructor($desc: UnityEngine.Rendering.GraphicsTextureDescriptor);
                public Dispose(): void;
            }

            interface IRenderPipelineGraphicsSettings {
                get version(): number;
                get isAvailableInPlayerBuild(): boolean;
                Reset(): void;
            }

            interface IRenderPipelineResources extends UnityEngine.Rendering.IRenderPipelineGraphicsSettings {
            }

            enum SearchType {
                ProjectPath = 0,
                BuiltinPath = 1,
                BuiltinExtraPath = 2,
                ShaderName = 3
            }

            class ResourcePathsBaseAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get location(): UnityEngine.Rendering.SearchType;
                public get paths(): System.Array$1<string>;
                public get isField(): boolean;
            }

            class ResourcePathAttribute extends UnityEngine.Rendering.ResourcePathsBaseAttribute {
                protected [__keep_incompatibility]: never;
                constructor($path: string, $location?: UnityEngine.Rendering.SearchType);
            }

            class ResourcePathsAttribute extends UnityEngine.Rendering.ResourcePathsBaseAttribute {
                protected [__keep_incompatibility]: never;
                constructor($paths: System.Array$1<string>, $location?: UnityEngine.Rendering.SearchType);
            }

            class ResourceFormattedPathsAttribute extends UnityEngine.Rendering.ResourcePathsBaseAttribute {
                protected [__keep_incompatibility]: never;
                constructor($pathFormat: string, $rangeMin: number, $rangeMax: number, $location?: UnityEngine.Rendering.SearchType);
            }

            class MachineLearningContext implements System.IDisposable {
                protected [__keep_incompatibility]: never;
                constructor();
                public Dispose(): void;
            }

            enum MachineLearningOperatorType {
                None = 0,
                Identity = 1,
                Gemm = 2,
                Conv = 3,
                ReLU = 4,
                ReduceMax = 5,
                ReduceMean = 6,
                ReduceMin = 7,
                ReduceProd = 8,
                ReduceSum = 9,
                ReduceSumSquare = 10,
                ReduceL1 = 11,
                ReduceL2 = 12,
                ReduceLogSum = 13,
                ReduceLogSumExp = 14
            }

            class MachineLearningOperator implements System.IEquatable$1<UnityEngine.Rendering.MachineLearningOperator> {
                protected [__keep_incompatibility]: never;
                public get IsValid(): boolean;
                public Equals($other: UnityEngine.Rendering.MachineLearningOperator): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class MachineLearningOperatorFactory {
                protected [__keep_incompatibility]: never;
                public static Identity($context: UnityEngine.Rendering.MachineLearningContext, $desc: $Ref<UnityEngine.Rendering.MachineLearningOperatorFactory.IdentityDescriptor>): UnityEngine.Rendering.MachineLearningOperator;
                public static Gemm($context: UnityEngine.Rendering.MachineLearningContext, $desc: $Ref<UnityEngine.Rendering.MachineLearningOperatorFactory.GemmDescriptor>): UnityEngine.Rendering.MachineLearningOperator;
                public static Reduce($context: UnityEngine.Rendering.MachineLearningContext, $desc: $Ref<UnityEngine.Rendering.MachineLearningOperatorFactory.ReduceDescriptor>): UnityEngine.Rendering.MachineLearningOperator;
                public static Conv($context: UnityEngine.Rendering.MachineLearningContext, $desc: $Ref<UnityEngine.Rendering.MachineLearningOperatorFactory.ConvDescriptor>): UnityEngine.Rendering.MachineLearningOperator;
            }

            class MachineLearningOperatorDispatcher {
                protected [__keep_incompatibility]: never;
                public static Identity($cb: UnityEngine.Rendering.CommandBuffer, $op: UnityEngine.Rendering.MachineLearningOperator, $X: UnityEngine.ComputeBuffer, $O: UnityEngine.ComputeBuffer): void;
                public static Gemm($cb: UnityEngine.Rendering.CommandBuffer, $op: UnityEngine.Rendering.MachineLearningOperator, $X: UnityEngine.ComputeBuffer, $Y: UnityEngine.ComputeBuffer, $Z: UnityEngine.ComputeBuffer, $O: UnityEngine.ComputeBuffer): void;
                public static Conv($cb: UnityEngine.Rendering.CommandBuffer, $op: UnityEngine.Rendering.MachineLearningOperator, $X: UnityEngine.ComputeBuffer, $K: UnityEngine.ComputeBuffer, $B: UnityEngine.ComputeBuffer, $O: UnityEngine.ComputeBuffer): void;
                public static Reduce($cb: UnityEngine.Rendering.CommandBuffer, $op: UnityEngine.Rendering.MachineLearningOperator, $X: UnityEngine.ComputeBuffer, $O: UnityEngine.ComputeBuffer): void;
            }

            enum MachineLearningDataType {
                Unknown = 0,
                Float32 = 1,
                Float16 = 2,
                UInt32 = 3,
                UInt16 = 4,
                UInt8 = 5,
                Int32 = 6,
                Int16 = 7,
                Int8 = 8,
                Float64 = 9,
                UInt64 = 10,
                Int64 = 11
            }

            class MachineLearningTensorShape implements System.IEquatable$1<UnityEngine.Rendering.MachineLearningTensorShape> {
                protected [__keep_incompatibility]: never;
                public rank: number;
                public D0: number;
                public D1: number;
                public D2: number;
                public D3: number;
                public D4: number;
                public D5: number;
                public D6: number;
                public D7: number;
                public GetHashCode(): number;
                public Equals($other: UnityEngine.Rendering.MachineLearningTensorShape): boolean;
                public Equals($obj: any): boolean;
            }

            class MachineLearningTensorDescriptor implements System.IEquatable$1<UnityEngine.Rendering.MachineLearningTensorDescriptor> {
                protected [__keep_incompatibility]: never;
                public dataType: UnityEngine.Rendering.MachineLearningDataType;
                public shape: UnityEngine.Rendering.MachineLearningTensorShape;
                constructor($dataType: UnityEngine.Rendering.MachineLearningDataType, $shape: UnityEngine.Rendering.MachineLearningTensorShape);
                public GetHashCode(): number;
                public Equals($other: UnityEngine.Rendering.MachineLearningTensorDescriptor): boolean;
                public Equals($obj: any): boolean;
                public static NullTensor(): UnityEngine.Rendering.MachineLearningTensorDescriptor;
            }

            class OnDemandRendering {
                protected [__keep_incompatibility]: never;
                public static get willCurrentFrameRender(): boolean;
                public static renderFrameInterval: number;
                public static get effectiveRenderFrameRate(): number;
                constructor();
            }

            enum RayTracingSubMeshFlags {
                Disabled = 0,
                Enabled = 1,
                ClosestHitOnly = 2,
                UniqueAnyHitCalls = 4
            }

            enum RayTracingInstanceCullingFlags {
                None = 0,
                EnableSphereCulling = 1,
                EnablePlaneCulling = 2,
                EnableLODCulling = 4,
                ComputeMaterialsCRC = 8,
                IgnoreReflectionProbes = 16,
                EnableSolidAngleCulling = 32,
                EnableMeshLOD = 64
            }

            class RayTracingInstanceCullingTest {
                protected [__keep_incompatibility]: never;
                public instanceMask: number;
                public layerMask: number;
                public shadowCastingModeMask: number;
                public allowOpaqueMaterials: boolean;
                public allowTransparentMaterials: boolean;
                public allowAlphaTestedMaterials: boolean;
                public allowVisualEffects: boolean;
            }

            class RayTracingInstanceCullingShaderTagConfig {
                protected [__keep_incompatibility]: never;
                public tagId: UnityEngine.Rendering.ShaderTagId;
                public tagValueId: UnityEngine.Rendering.ShaderTagId;
            }

            class RayTracingInstanceMaterialConfig {
                protected [__keep_incompatibility]: never;
                public renderQueueLowerBound: number;
                public renderQueueUpperBound: number;
                public optionalShaderTags: System.Array$1<UnityEngine.Rendering.RayTracingInstanceCullingShaderTagConfig>;
                public optionalShaderKeywords: System.Array$1<string>;
            }

            class RayTracingInstanceCullingMaterialTest {
                protected [__keep_incompatibility]: never;
                public deniedShaderPasses: System.Array$1<string>;
                public requiredShaderTags: System.Array$1<UnityEngine.Rendering.RayTracingInstanceCullingShaderTagConfig>;
            }

            class RayTracingInstanceTriangleCullingConfig {
                protected [__keep_incompatibility]: never;
                public optionalDoubleSidedShaderKeywords: System.Array$1<string>;
                public frontTriangleCounterClockwise: boolean;
                public checkDoubleSidedGIMaterial: boolean;
                public forceDoubleSided: boolean;
            }

            class RayTracingSubMeshFlagsConfig {
                protected [__keep_incompatibility]: never;
                public opaqueMaterials: UnityEngine.Rendering.RayTracingSubMeshFlags;
                public transparentMaterials: UnityEngine.Rendering.RayTracingSubMeshFlags;
                public alphaTestedMaterials: UnityEngine.Rendering.RayTracingSubMeshFlags;
            }

            class RayTracingInstanceCullingConfig {
                protected [__keep_incompatibility]: never;
                public flags: UnityEngine.Rendering.RayTracingInstanceCullingFlags;
                public sphereCenter: UnityEngine.Vector3;
                public sphereRadius: number;
                public minSolidAngle: number;
                public planes: System.Array$1<UnityEngine.Plane>;
                public instanceTests: System.Array$1<UnityEngine.Rendering.RayTracingInstanceCullingTest>;
                public materialTest: UnityEngine.Rendering.RayTracingInstanceCullingMaterialTest;
                public transparentMaterialConfig: UnityEngine.Rendering.RayTracingInstanceMaterialConfig;
                public alphaTestedMaterialConfig: UnityEngine.Rendering.RayTracingInstanceMaterialConfig;
                public subMeshFlagsConfig: UnityEngine.Rendering.RayTracingSubMeshFlagsConfig;
                public triangleCullingConfig: UnityEngine.Rendering.RayTracingInstanceTriangleCullingConfig;
                public lodParameters: UnityEngine.Rendering.LODParameters;
            }

            class RayTracingInstanceMaterialCRC {
                protected [__keep_incompatibility]: never;
                public instanceID: number;
                public crc: number;
            }

            class RayTracingInstanceCullingResults {
                protected [__keep_incompatibility]: never;
                public materialsCRC: System.Array$1<UnityEngine.Rendering.RayTracingInstanceMaterialCRC>;
                public transformsChanged: boolean;
            }

            class RayTracingSubGeometryDesc {
                protected [__keep_incompatibility]: never;
                public flags: UnityEngine.Rendering.RayTracingSubMeshFlags;
                public id: number;
                public indexStart: number;
                public indexCount: number;
                public vertexStart: number;
                public vertexCount: number;
                constructor();
                constructor($indexStart: number, $indexCount: number, $id?: number, $flags?: UnityEngine.Rendering.RayTracingSubMeshFlags);
            }

            class RayTracingMeshInstanceConfig {
                protected [__keep_incompatibility]: never;
                public mesh: UnityEngine.Mesh;
                public subMeshIndex: number;
                public subMeshFlags: UnityEngine.Rendering.RayTracingSubMeshFlags;
                public material: UnityEngine.Material;
                public materialProperties: UnityEngine.MaterialPropertyBlock;
                public enableTriangleCulling: boolean;
                public frontTriangleCounterClockwise: boolean;
                public layer: number;
                public renderingLayerMask: number;
                public mask: number;
                public motionVectorMode: UnityEngine.MotionVectorGenerationMode;
                public lightProbeUsage: UnityEngine.Rendering.LightProbeUsage;
                public lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume;
                public meshLod: number;
                public rayTracingMode: UnityEngine.Experimental.Rendering.RayTracingMode;
                public dynamicGeometry: boolean;
                public accelerationStructureBuildFlags: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
                public accelerationStructureBuildFlagsOverride: boolean;
                constructor();
                constructor($mesh: UnityEngine.Mesh, $subMeshIndex: number, $material: UnityEngine.Material);
            }

            class RayTracingAABBsInstanceConfig {
                protected [__keep_incompatibility]: never;
                public aabbBuffer: UnityEngine.GraphicsBuffer;
                public aabbCount: number;
                public aabbOffset: number;
                public dynamicGeometry: boolean;
                public opaqueMaterial: boolean;
                public material: UnityEngine.Material;
                public materialProperties: UnityEngine.MaterialPropertyBlock;
                public layer: number;
                public mask: number;
                public accelerationStructureBuildFlags: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
                public accelerationStructureBuildFlagsOverride: boolean;
                constructor();
                constructor($aabbBuffer: UnityEngine.GraphicsBuffer, $aabbCount: number, $dynamicGeometry: boolean, $material: UnityEngine.Material);
            }

            class RayTracingGeometryInstanceConfig {
                protected [__keep_incompatibility]: never;
                public vertexBuffer: UnityEngine.GraphicsBuffer;
                public vertexAttributes: System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>;
                public vertexStart: number;
                public vertexCount: number;
                public indexBuffer: UnityEngine.GraphicsBuffer;
                public indexStart: number;
                public indexCount: number;
                public subMeshFlags: UnityEngine.Rendering.RayTracingSubMeshFlags;
                public rayTracingMode: UnityEngine.Experimental.Rendering.RayTracingMode;
                public dynamicGeometry: boolean;
                public material: UnityEngine.Material;
                public materialProperties: UnityEngine.MaterialPropertyBlock;
                public enableTriangleCulling: boolean;
                public frontTriangleCounterClockwise: boolean;
                public layer: number;
                public renderingLayerMask: number;
                public mask: number;
                public motionVectorMode: UnityEngine.MotionVectorGenerationMode;
                public lightProbeUsage: UnityEngine.Rendering.LightProbeUsage;
                public lightProbeProxyVolume: UnityEngine.LightProbeProxyVolume;
                public accelerationStructureBuildFlags: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
                public accelerationStructureBuildFlagsOverride: boolean;
                constructor();
                constructor($vertexBuffer: UnityEngine.GraphicsBuffer, $vertexAttributes: System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>, $indexBuffer: UnityEngine.GraphicsBuffer, $material: UnityEngine.Material);
            }

            class RayTracingMultiGeometryInstanceConfig {
                protected [__keep_incompatibility]: never;
                public vertexBuffer: UnityEngine.GraphicsBuffer;
                public vertexAttributes: System.Array$1<UnityEngine.Rendering.VertexAttributeDescriptor>;
                public indexBuffer: UnityEngine.GraphicsBuffer;
                public rayTracingMode: UnityEngine.Experimental.Rendering.RayTracingMode;
                public materials: System.Array$1<UnityEngine.Material>;
                public subGeometries: System.Array$1<UnityEngine.Rendering.RayTracingSubGeometryDesc>;
                public subGeometriesValidation: boolean;
                public materialProperties: UnityEngine.MaterialPropertyBlock;
                public enableTriangleCulling: boolean;
                public frontTriangleCounterClockwise: boolean;
                public layer: number;
                public renderingLayerMask: number;
                public mask: number;
                public motionVectorMode: UnityEngine.MotionVectorGenerationMode;
                public accelerationStructureBuildFlags: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
                public accelerationStructureBuildFlagsOverride: boolean;
                constructor();
            }

            class RayTracingAccelerationStructure implements System.IDisposable {
                protected [__keep_incompatibility]: never;
                constructor($settings: UnityEngine.Rendering.RayTracingAccelerationStructure.Settings);
                constructor();
                public Dispose(): void;
                public Release(): void;
                public Build(): void;
                public Build($relativeOrigin: UnityEngine.Vector3): void;
                public AddInstance($targetRenderer: UnityEngine.Renderer, $subMeshFlags: System.Array$1<UnityEngine.Rendering.RayTracingSubMeshFlags>, $enableTriangleCulling?: boolean, $frontTriangleCounterClockwise?: boolean, $mask?: number, $id?: number): number;
                public AddInstance($config: UnityEngine.Rendering.RayTracingAABBsInstanceConfig, $matrix: UnityEngine.Matrix4x4, $id?: number): number;
                public AddInstance($config: $Ref<UnityEngine.Rendering.RayTracingMeshInstanceConfig>, $matrix: UnityEngine.Matrix4x4, $prevMatrix?: UnityEngine.Matrix4x4 | null, $id?: number): number;
                public AddInstance($config: $Ref<UnityEngine.Rendering.RayTracingGeometryInstanceConfig>, $matrix: UnityEngine.Matrix4x4, $prevMatrix?: UnityEngine.Matrix4x4 | null, $id?: number): number;
                public AddInstances<T>($config: $Ref<UnityEngine.Rendering.RayTracingMeshInstanceConfig>, $instanceData: System.Array$1<T>, $instanceCount?: number, $startInstance?: number, $id?: number): number;
                public AddInstances<T>($config: $Ref<UnityEngine.Rendering.RayTracingMeshInstanceConfig>, $instanceData: System.Collections.Generic.List$1<T>, $instanceCount?: number, $startInstance?: number, $id?: number): number;
                public AddInstances<T>($config: $Ref<UnityEngine.Rendering.RayTracingMeshInstanceConfig>, $instanceData: Unity.Collections.NativeArray$1<T>, $instanceCount?: number, $startInstance?: number, $id?: number): number;
                public AddInstancesIndirect($config: $Ref<UnityEngine.Rendering.RayTracingMeshInstanceConfig>, $instanceMatrices: UnityEngine.GraphicsBuffer, $maxInstanceCount: number, $argsBuffer: UnityEngine.GraphicsBuffer, $argsOffset?: number, $id?: number): number;
                public AddInstancesIndirect($config: $Ref<UnityEngine.Rendering.RayTracingGeometryInstanceConfig>, $instanceMatrices: UnityEngine.GraphicsBuffer, $maxInstanceCount: number, $argsBuffer: UnityEngine.GraphicsBuffer, $argsOffset?: number, $id?: number): number;
                public AddInstancesIndirect($config: $Ref<UnityEngine.Rendering.RayTracingMultiGeometryInstanceConfig>, $instanceData: UnityEngine.GraphicsBuffer, $instanceType: System.Type, $instanceIndices: UnityEngine.GraphicsBuffer, $maxInstanceCount: number, $argsBuffer: UnityEngine.GraphicsBuffer, $argsOffset?: number, $id?: number): number;
                public AddInstancesIndirect<T>($config: $Ref<UnityEngine.Rendering.RayTracingMultiGeometryInstanceConfig>, $instanceData: UnityEngine.GraphicsBuffer, $instanceIndices: UnityEngine.GraphicsBuffer, $maxInstanceCount: number, $argsBuffer: UnityEngine.GraphicsBuffer, $argsOffset?: number, $id?: number): number;
                public AddInstances<T>($config: $Ref<UnityEngine.Rendering.RayTracingMeshInstanceConfig>, $instanceData: Unity.Collections.NativeSlice$1<T>, $id?: number): number;
                public RemoveInstance($targetRenderer: UnityEngine.Renderer): void;
                public RemoveInstance($handle: number): void;
                public UpdateInstanceGeometry($renderer: UnityEngine.Renderer): void;
                public UpdateInstanceGeometry($handle: number): void;
                public UpdateInstanceTransform($renderer: UnityEngine.Renderer): void;
                public UpdateInstanceTransform($handle: number, $matrix: UnityEngine.Matrix4x4): void;
                public UpdateInstanceID($renderer: UnityEngine.Renderer, $instanceID: number): void;
                public UpdateInstanceID($handle: number, $instanceID: number): void;
                public UpdateInstanceMask($renderer: UnityEngine.Renderer, $mask: number): void;
                public UpdateInstanceMask($handle: number, $mask: number): void;
                public Build($buildSettings: UnityEngine.Rendering.RayTracingAccelerationStructure.BuildSettings): void;
                public AddVFXInstances($targetRenderer: UnityEngine.Renderer, $vfxSystemMasks: System.Array$1<number>): void;
                public RemoveVFXInstances($targetRenderer: UnityEngine.Renderer): void;
                public UpdateInstancePropertyBlock($handle: number, $properties: UnityEngine.MaterialPropertyBlock): void;
                public GetSize(): bigint;
                public GetInstanceCount(): number;
                public ClearInstances(): void;
                public RemoveInstances($layerMask: number, $rayTracingModeMask: UnityEngine.Rendering.RayTracingAccelerationStructure.RayTracingModeMask): void;
                public CullInstances($cullingConfig: $Ref<UnityEngine.Rendering.RayTracingInstanceCullingConfig>): UnityEngine.Rendering.RayTracingInstanceCullingResults;
            }
            namespace RayTracingAccelerationStructure {
                enum RayTracingModeMask {
                    Nothing = 0,
                    Static = 2,
                    DynamicTransform = 4,
                    DynamicGeometry = 8,
                    DynamicGeometryManualUpdate = 16,
                    Everything = 30
                }

                enum ManagementMode {
                    Manual = 0,
                    Automatic = 1
                }

                class BuildSettings {
                    protected [__keep_incompatibility]: never;
                    public buildFlags: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
                    public relativeOrigin: UnityEngine.Vector3;
                    constructor();
                    constructor($buildFlags: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags, $relativeOrigin: UnityEngine.Vector3);
                }

                class RASSettings {
                    protected [__keep_incompatibility]: never;
                    public managementMode: UnityEngine.Rendering.RayTracingAccelerationStructure.ManagementMode;
                    public rayTracingModeMask: UnityEngine.Rendering.RayTracingAccelerationStructure.RayTracingModeMask;
                    public layerMask: number;
                    constructor($sceneManagementMode: UnityEngine.Rendering.RayTracingAccelerationStructure.ManagementMode, $rayTracingModeMask: UnityEngine.Rendering.RayTracingAccelerationStructure.RayTracingModeMask, $layerMask: number);
                }

                class Settings {
                    protected [__keep_incompatibility]: never;
                    public managementMode: UnityEngine.Rendering.RayTracingAccelerationStructure.ManagementMode;
                    public rayTracingModeMask: UnityEngine.Rendering.RayTracingAccelerationStructure.RayTracingModeMask;
                    public layerMask: number;
                    public buildFlagsStaticGeometries: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
                    public buildFlagsDynamicGeometries: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags;
                    public enableCompaction: boolean;
                    constructor();
                    constructor($sceneManagementMode: UnityEngine.Rendering.RayTracingAccelerationStructure.ManagementMode, $rayTracingModeMask: UnityEngine.Rendering.RayTracingAccelerationStructure.RayTracingModeMask, $layerMask: number);
                    constructor($sceneManagementMode: UnityEngine.Rendering.RayTracingAccelerationStructure.ManagementMode, $rayTracingModeMask: UnityEngine.Rendering.RayTracingAccelerationStructure.RayTracingModeMask, $layerMask: number, $buildFlagsStaticGeometries: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags, $buildFlagsDynamicGeometries: UnityEngine.Rendering.RayTracingAccelerationStructureBuildFlags);
                }

            }

            class CommandBuffer implements System.IDisposable {
                protected [__keep_incompatibility]: never;
                public static ThrowOnSetRenderTarget: boolean;
                public name: string;
                public get sizeInBytes(): number;
                constructor();
                public ConvertTexture($src: UnityEngine.Rendering.RenderTargetIdentifier, $dst: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public ConvertTexture($src: UnityEngine.Rendering.RenderTargetIdentifier, $srcElement: number, $dst: UnityEngine.Rendering.RenderTargetIdentifier, $dstElement: number): void;
                public WaitAllAsyncReadbackRequests(): void;
                public RequestAsyncReadback($src: UnityEngine.ComputeBuffer, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadback($src: UnityEngine.GraphicsBuffer, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadback($src: UnityEngine.ComputeBuffer, $size: number, $offset: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadback($src: UnityEngine.GraphicsBuffer, $size: number, $offset: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadback($src: UnityEngine.Texture, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadback($src: UnityEngine.Texture, $mipIndex: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadback($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadback($src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadback($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadback($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadback($src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.ComputeBuffer, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.ComputeBuffer, $size: number, $offset: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.GraphicsBuffer, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.GraphicsBuffer, $size: number, $offset: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeArray<T>($output: $Ref<Unity.Collections.NativeArray$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.ComputeBuffer, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.ComputeBuffer, $size: number, $offset: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.GraphicsBuffer, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.GraphicsBuffer, $size: number, $offset: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.TextureFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public RequestAsyncReadbackIntoNativeSlice<T>($output: $Ref<Unity.Collections.NativeSlice$1<T>>, $src: UnityEngine.Texture, $mipIndex: number, $x: number, $width: number, $y: number, $height: number, $z: number, $depth: number, $dstFormat: UnityEngine.Experimental.Rendering.GraphicsFormat, $callback: System.Action$1<UnityEngine.Rendering.AsyncGPUReadbackRequest>): void;
                public SetInvertCulling($invertCulling: boolean): void;
                public SetComputeFloatParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $val: number): void;
                public SetComputeIntParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $val: number): void;
                public SetComputeVectorParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $val: UnityEngine.Vector4): void;
                public SetComputeVectorArrayParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $values: System.Array$1<UnityEngine.Vector4>): void;
                public SetComputeMatrixParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $val: UnityEngine.Matrix4x4): void;
                public SetComputeMatrixArrayParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>): void;
                public SetRayTracingShaderPass($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $passName: string): void;
                public Clear(): void;
                public ClearRandomWriteTargets(): void;
                public SetViewport($pixelRect: UnityEngine.Rect): void;
                public EnableScissorRect($scissor: UnityEngine.Rect): void;
                public DisableScissorRect(): void;
                public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless, $useDynamicScale: boolean): void;
                public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless): void;
                public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean): void;
                public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number): void;
                public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat): void;
                public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless, $useDynamicScale: boolean): void;
                public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $enableRandomWrite: boolean, $memorylessMode: UnityEngine.RenderTextureMemoryless): void;
                public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $enableRandomWrite: boolean): void;
                public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number): void;
                public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite): void;
                public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat): void;
                public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number, $filter: UnityEngine.FilterMode): void;
                public GetTemporaryRT($nameID: number, $width: number, $height: number, $depthBuffer: number): void;
                public GetTemporaryRT($nameID: number, $width: number, $height: number): void;
                public GetTemporaryRT($nameID: number, $desc: UnityEngine.RenderTextureDescriptor, $filter: UnityEngine.FilterMode): void;
                public GetTemporaryRT($nameID: number, $desc: UnityEngine.RenderTextureDescriptor): void;
                public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean, $useDynamicScale: boolean): void;
                public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number, $enableRandomWrite: boolean): void;
                public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat, $antiAliasing: number): void;
                public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.Experimental.Rendering.GraphicsFormat): void;
                public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number, $enableRandomWrite: boolean): void;
                public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite, $antiAliasing: number): void;
                public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat, $readWrite: UnityEngine.RenderTextureReadWrite): void;
                public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode, $format: UnityEngine.RenderTextureFormat): void;
                public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number, $filter: UnityEngine.FilterMode): void;
                public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number, $depthBuffer: number): void;
                public GetTemporaryRTArray($nameID: number, $width: number, $height: number, $slices: number): void;
                public ReleaseTemporaryRT($nameID: number): void;
                public ClearRenderTarget($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color): void;
                public ClearRenderTarget($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color, $depth: number): void;
                public ClearRenderTarget($clearDepth: boolean, $clearColor: boolean, $backgroundColor: UnityEngine.Color, $depth?: number, $stencil?: number): void;
                public ClearRenderTarget($clearFlags: UnityEngine.Rendering.RTClearFlags, $backgroundColor: UnityEngine.Color, $depth?: number, $stencil?: number): void;
                public ClearRenderTarget($clearFlags: UnityEngine.Rendering.RTClearFlags, $backgroundColors: System.Array$1<UnityEngine.Color>, $depth?: number, $stencil?: number): void;
                public SetGlobalFloat($nameID: number, $value: number): void;
                public SetGlobalInt($nameID: number, $value: number): void;
                public SetGlobalInteger($nameID: number, $value: number): void;
                public SetGlobalVector($nameID: number, $value: UnityEngine.Vector4): void;
                public SetGlobalColor($nameID: number, $value: UnityEngine.Color): void;
                public SetGlobalMatrix($nameID: number, $value: UnityEngine.Matrix4x4): void;
                public EnableShaderKeyword($keyword: string): void;
                public EnableKeyword($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>): void;
                public EnableKeyword($material: UnityEngine.Material, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): void;
                public EnableKeyword($computeShader: UnityEngine.ComputeShader, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): void;
                public EnableKeyword($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): void;
                public DisableShaderKeyword($keyword: string): void;
                public DisableKeyword($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>): void;
                public DisableKeyword($material: UnityEngine.Material, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): void;
                public DisableKeyword($computeShader: UnityEngine.ComputeShader, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): void;
                public DisableKeyword($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): void;
                public SetKeyword($keyword: $Ref<UnityEngine.Rendering.GlobalKeyword>, $value: boolean): void;
                public SetKeyword($material: UnityEngine.Material, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>, $value: boolean): void;
                public SetKeyword($computeShader: UnityEngine.ComputeShader, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>, $value: boolean): void;
                public SetKeyword($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $keyword: $Ref<UnityEngine.Rendering.LocalKeyword>, $value: boolean): void;
                public SetViewMatrix($view: UnityEngine.Matrix4x4): void;
                public SetProjectionMatrix($proj: UnityEngine.Matrix4x4): void;
                public SetViewProjectionMatrices($view: UnityEngine.Matrix4x4, $proj: UnityEngine.Matrix4x4): void;
                public SetGlobalDepthBias($bias: number, $slopeBias: number): void;
                public SetExecutionFlags($flags: UnityEngine.Rendering.CommandBufferExecutionFlags): void;
                public SetGlobalFloatArray($nameID: number, $values: System.Array$1<number>): void;
                public SetGlobalVectorArray($nameID: number, $values: System.Array$1<UnityEngine.Vector4>): void;
                public SetGlobalMatrixArray($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>): void;
                public SetLateLatchProjectionMatrices($projectionMat: System.Array$1<UnityEngine.Matrix4x4>): void;
                public MarkLateLatchMatrixShaderPropertyID($matrixPropertyType: UnityEngine.Rendering.CameraLateLatchMatrixType, $shaderPropertyID: number): void;
                public UnmarkLateLatchMatrix($matrixPropertyType: UnityEngine.Rendering.CameraLateLatchMatrixType): void;
                public BeginSample($name: string): void;
                public EndSample($name: string): void;
                public BeginSample($sampler: UnityEngine.Profiling.CustomSampler): void;
                public EndSample($sampler: UnityEngine.Profiling.CustomSampler): void;
                public BeginSample($marker: Unity.Profiling.ProfilerMarker): void;
                public EndSample($marker: Unity.Profiling.ProfilerMarker): void;
                public IncrementUpdateCount($dest: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public SetInstanceMultiplier($multiplier: number): void;
                public SetFoveatedRenderingMode($foveatedRenderingMode: UnityEngine.Rendering.FoveatedRenderingMode): void;
                public SetWireframe($enable: boolean): void;
                public ConfigureFoveatedRendering($platformData: number): void;
                public SetRenderTarget($rt: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public SetRenderTarget($rt: UnityEngine.Rendering.RenderTargetIdentifier, $loadAction: UnityEngine.Rendering.RenderBufferLoadAction, $storeAction: UnityEngine.Rendering.RenderBufferStoreAction): void;
                public SetRenderTarget($rt: UnityEngine.Rendering.RenderTargetIdentifier, $colorLoadAction: UnityEngine.Rendering.RenderBufferLoadAction, $colorStoreAction: UnityEngine.Rendering.RenderBufferStoreAction, $depthLoadAction: UnityEngine.Rendering.RenderBufferLoadAction, $depthStoreAction: UnityEngine.Rendering.RenderBufferStoreAction): void;
                public SetRenderTarget($rt: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number): void;
                public SetRenderTarget($rt: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace): void;
                public SetRenderTarget($rt: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: number): void;
                public SetRenderTarget($color: UnityEngine.Rendering.RenderTargetIdentifier, $depth: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public SetRenderTarget($color: UnityEngine.Rendering.RenderTargetIdentifier, $depth: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number): void;
                public SetRenderTarget($color: UnityEngine.Rendering.RenderTargetIdentifier, $depth: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace): void;
                public SetRenderTarget($color: UnityEngine.Rendering.RenderTargetIdentifier, $depth: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: number): void;
                public SetRenderTarget($color: UnityEngine.Rendering.RenderTargetIdentifier, $colorLoadAction: UnityEngine.Rendering.RenderBufferLoadAction, $colorStoreAction: UnityEngine.Rendering.RenderBufferStoreAction, $depth: UnityEngine.Rendering.RenderTargetIdentifier, $depthLoadAction: UnityEngine.Rendering.RenderBufferLoadAction, $depthStoreAction: UnityEngine.Rendering.RenderBufferStoreAction): void;
                public SetRenderTarget($colors: System.Array$1<UnityEngine.Rendering.RenderTargetIdentifier>, $depth: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public SetRenderTarget($colors: System.Array$1<UnityEngine.Rendering.RenderTargetIdentifier>, $depth: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: number): void;
                public SetRenderTarget($binding: UnityEngine.Rendering.RenderTargetBinding, $mipLevel: number, $cubemapFace: UnityEngine.CubemapFace, $depthSlice: number): void;
                public SetRenderTarget($binding: UnityEngine.Rendering.RenderTargetBinding): void;
                public SetBufferData($buffer: UnityEngine.ComputeBuffer, $data: System.Array): void;
                public SetBufferData<T>($buffer: UnityEngine.ComputeBuffer, $data: System.Collections.Generic.List$1<T>): void;
                public SetBufferData<T>($buffer: UnityEngine.ComputeBuffer, $data: Unity.Collections.NativeArray$1<T>): void;
                public SetBufferData($buffer: UnityEngine.ComputeBuffer, $data: System.Array, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number): void;
                public SetBufferData<T>($buffer: UnityEngine.ComputeBuffer, $data: System.Collections.Generic.List$1<T>, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number): void;
                public SetBufferData<T>($buffer: UnityEngine.ComputeBuffer, $data: Unity.Collections.NativeArray$1<T>, $nativeBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number): void;
                public SetBufferCounterValue($buffer: UnityEngine.ComputeBuffer, $counterValue: number): void;
                public SetBufferData($buffer: UnityEngine.GraphicsBuffer, $data: System.Array): void;
                public SetBufferData<T>($buffer: UnityEngine.GraphicsBuffer, $data: System.Collections.Generic.List$1<T>): void;
                public SetBufferData<T>($buffer: UnityEngine.GraphicsBuffer, $data: Unity.Collections.NativeArray$1<T>): void;
                public SetBufferData($buffer: UnityEngine.GraphicsBuffer, $data: System.Array, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number): void;
                public SetBufferData<T>($buffer: UnityEngine.GraphicsBuffer, $data: System.Collections.Generic.List$1<T>, $managedBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number): void;
                public SetBufferData<T>($buffer: UnityEngine.GraphicsBuffer, $data: Unity.Collections.NativeArray$1<T>, $nativeBufferStartIndex: number, $graphicsBufferStartIndex: number, $count: number): void;
                public SetBufferCounterValue($buffer: UnityEngine.GraphicsBuffer, $counterValue: number): void;
                public BeginRenderPass($width: number, $height: number, $volumeDepth: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex: number, $subPasses: Unity.Collections.NativeArray$1<UnityEngine.Rendering.SubPassDescriptor>, $debugNameUtf8: System.ReadOnlySpan$1<number>): void;
                public BeginRenderPass($width: number, $height: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex: number, $subPasses: Unity.Collections.NativeArray$1<UnityEngine.Rendering.SubPassDescriptor>, $debugNameUtf8: System.ReadOnlySpan$1<number>): void;
                public BeginRenderPass($width: number, $height: number, $volumeDepth: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex: number, $subPasses: Unity.Collections.NativeArray$1<UnityEngine.Rendering.SubPassDescriptor>): void;
                public BeginRenderPass($width: number, $height: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex: number, $subPasses: Unity.Collections.NativeArray$1<UnityEngine.Rendering.SubPassDescriptor>): void;
                public BeginRenderPass($width: number, $height: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex: number, $shadingRateImageAttachmentIndex: number, $subPasses: Unity.Collections.NativeArray$1<UnityEngine.Rendering.SubPassDescriptor>): void;
                public BeginRenderPass($width: number, $height: number, $volumeDepth: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex: number, $shadingRateImageAttachmentIndex: number, $subPasses: Unity.Collections.NativeArray$1<UnityEngine.Rendering.SubPassDescriptor>): void;
                public BeginRenderPass($width: number, $height: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex: number, $shadingRateImageAttachmentIndex: number, $subPasses: Unity.Collections.NativeArray$1<UnityEngine.Rendering.SubPassDescriptor>, $debugNameUtf8: System.ReadOnlySpan$1<number>): void;
                public BeginRenderPass($width: number, $height: number, $volumeDepth: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex: number, $shadingRateImageAttachmentIndex: number, $subPasses: Unity.Collections.NativeArray$1<UnityEngine.Rendering.SubPassDescriptor>, $debugNameUtf8: System.ReadOnlySpan$1<number>): void;
                public NextSubPass(): void;
                public EndRenderPass(): void;
                public SetupCameraProperties($camera: UnityEngine.Camera): void;
                public InvokeOnRenderObjectCallbacks(): void;
                public SetShadingRateFragmentSize($shadingRateFragmentSize: UnityEngine.Rendering.ShadingRateFragmentSize): void;
                public SetShadingRateCombiner($stage: UnityEngine.Rendering.ShadingRateCombinerStage, $combiner: UnityEngine.Rendering.ShadingRateCombiner): void;
                public SetShadingRateImage($shadingRateImage: $Ref<UnityEngine.Rendering.RenderTargetIdentifier>): void;
                public ResetShadingRate(): void;
                public Dispose(): void;
                public Release(): void;
                public CreateAsyncGraphicsFence(): UnityEngine.Rendering.GraphicsFence;
                public CreateAsyncGraphicsFence($stage: UnityEngine.Rendering.SynchronisationStage): UnityEngine.Rendering.GraphicsFence;
                public CreateGraphicsFence($fenceType: UnityEngine.Rendering.GraphicsFenceType, $stage: UnityEngine.Rendering.SynchronisationStageFlags): UnityEngine.Rendering.GraphicsFence;
                public WaitOnAsyncGraphicsFence($fence: UnityEngine.Rendering.GraphicsFence): void;
                public WaitOnAsyncGraphicsFence($fence: UnityEngine.Rendering.GraphicsFence, $stage: UnityEngine.Rendering.SynchronisationStage): void;
                public WaitOnAsyncGraphicsFence($fence: UnityEngine.Rendering.GraphicsFence, $stage: UnityEngine.Rendering.SynchronisationStageFlags): void;
                public SetComputeFloatParam($computeShader: UnityEngine.ComputeShader, $name: string, $val: number): void;
                public SetComputeIntParam($computeShader: UnityEngine.ComputeShader, $name: string, $val: number): void;
                public SetComputeVectorParam($computeShader: UnityEngine.ComputeShader, $name: string, $val: UnityEngine.Vector4): void;
                public SetComputeVectorArrayParam($computeShader: UnityEngine.ComputeShader, $name: string, $values: System.Array$1<UnityEngine.Vector4>): void;
                public SetComputeMatrixParam($computeShader: UnityEngine.ComputeShader, $name: string, $val: UnityEngine.Matrix4x4): void;
                public SetComputeMatrixArrayParam($computeShader: UnityEngine.ComputeShader, $name: string, $values: System.Array$1<UnityEngine.Matrix4x4>): void;
                public SetComputeFloatParams($computeShader: UnityEngine.ComputeShader, $name: string, ...values: number[]): void;
                public SetComputeFloatParams($computeShader: UnityEngine.ComputeShader, $nameID: number, ...values: number[]): void;
                public SetComputeIntParams($computeShader: UnityEngine.ComputeShader, $name: string, ...values: number[]): void;
                public SetComputeIntParams($computeShader: UnityEngine.ComputeShader, $nameID: number, ...values: number[]): void;
                public SetComputeTextureParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $rt: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public SetComputeTextureParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $rt: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public SetComputeTextureParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $rt: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number): void;
                public SetComputeTextureParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $rt: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number): void;
                public SetComputeTextureParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $rt: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $element: UnityEngine.Rendering.RenderTextureSubElement): void;
                public SetComputeTextureParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $rt: UnityEngine.Rendering.RenderTargetIdentifier, $mipLevel: number, $element: UnityEngine.Rendering.RenderTextureSubElement): void;
                public SetComputeBufferParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $buffer: UnityEngine.ComputeBuffer): void;
                public SetComputeBufferParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $buffer: UnityEngine.ComputeBuffer): void;
                public SetComputeBufferParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $bufferHandle: UnityEngine.GraphicsBufferHandle): void;
                public SetComputeBufferParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $bufferHandle: UnityEngine.GraphicsBufferHandle): void;
                public SetComputeBufferParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $buffer: UnityEngine.GraphicsBuffer): void;
                public SetComputeBufferParam($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $buffer: UnityEngine.GraphicsBuffer): void;
                public SetComputeConstantBufferParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number): void;
                public SetComputeConstantBufferParam($computeShader: UnityEngine.ComputeShader, $name: string, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number): void;
                public SetComputeConstantBufferParam($computeShader: UnityEngine.ComputeShader, $nameID: number, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number): void;
                public SetComputeConstantBufferParam($computeShader: UnityEngine.ComputeShader, $name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number): void;
                public SetComputeParamsFromMaterial($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $material: UnityEngine.Material): void;
                public DispatchCompute($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $threadGroupsX: number, $threadGroupsY: number, $threadGroupsZ: number): void;
                public DispatchCompute($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $indirectBuffer: UnityEngine.ComputeBuffer, $argsOffset: number): void;
                public DispatchCompute($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $indirectBuffer: UnityEngine.GraphicsBuffer, $argsOffset: number): void;
                public BuildRayTracingAccelerationStructure($accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure): void;
                public BuildRayTracingAccelerationStructure($accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure, $relativeOrigin: UnityEngine.Vector3): void;
                public BuildRayTracingAccelerationStructure($accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure, $buildSettings: UnityEngine.Rendering.RayTracingAccelerationStructure.BuildSettings): void;
                public SetRayTracingAccelerationStructure($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $rayTracingAccelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure): void;
                public SetRayTracingAccelerationStructure($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $rayTracingAccelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure): void;
                public SetRayTracingAccelerationStructure($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $name: string, $rayTracingAccelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure): void;
                public SetRayTracingAccelerationStructure($computeShader: UnityEngine.ComputeShader, $kernelIndex: number, $nameID: number, $rayTracingAccelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure): void;
                public SetRayTracingBufferParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $buffer: UnityEngine.ComputeBuffer): void;
                public SetRayTracingBufferParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $buffer: UnityEngine.ComputeBuffer): void;
                public SetRayTracingBufferParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $buffer: UnityEngine.GraphicsBuffer): void;
                public SetRayTracingBufferParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $buffer: UnityEngine.GraphicsBuffer): void;
                public SetRayTracingBufferParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $bufferHandle: UnityEngine.GraphicsBufferHandle): void;
                public SetRayTracingBufferParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $bufferHandle: UnityEngine.GraphicsBufferHandle): void;
                public SetRayTracingConstantBufferParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number): void;
                public SetRayTracingConstantBufferParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number): void;
                public SetRayTracingConstantBufferParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number): void;
                public SetRayTracingConstantBufferParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number): void;
                public SetRayTracingTextureParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $rt: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public SetRayTracingTextureParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $rt: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public SetRayTracingFloatParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $val: number): void;
                public SetRayTracingFloatParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $val: number): void;
                public SetRayTracingFloatParams($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, ...values: number[]): void;
                public SetRayTracingFloatParams($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, ...values: number[]): void;
                public SetRayTracingIntParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $val: number): void;
                public SetRayTracingIntParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $val: number): void;
                public SetRayTracingIntParams($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, ...values: number[]): void;
                public SetRayTracingIntParams($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, ...values: number[]): void;
                public SetRayTracingVectorParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $val: UnityEngine.Vector4): void;
                public SetRayTracingVectorParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $val: UnityEngine.Vector4): void;
                public SetRayTracingVectorArrayParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, ...values: UnityEngine.Vector4[]): void;
                public SetRayTracingVectorArrayParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, ...values: UnityEngine.Vector4[]): void;
                public SetRayTracingMatrixParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, $val: UnityEngine.Matrix4x4): void;
                public SetRayTracingMatrixParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, $val: UnityEngine.Matrix4x4): void;
                public SetRayTracingMatrixArrayParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $name: string, ...values: UnityEngine.Matrix4x4[]): void;
                public SetRayTracingMatrixArrayParam($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $nameID: number, ...values: UnityEngine.Matrix4x4[]): void;
                public DispatchRays($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $rayGenName: string, $width: number, $height: number, $depth: number, $camera?: UnityEngine.Camera): void;
                public DispatchRays($rayTracingShader: UnityEngine.Rendering.RayTracingShader, $rayGenName: string, $argsBuffer: UnityEngine.GraphicsBuffer, $argsOffset: number, $camera?: UnityEngine.Camera): void;
                public GenerateMips($rt: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public GenerateMips($rt: UnityEngine.RenderTexture): void;
                public ResolveAntiAliasedSurface($rt: UnityEngine.RenderTexture, $target?: UnityEngine.RenderTexture): void;
                public DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $submeshIndex: number, $shaderPass: number, $properties: UnityEngine.MaterialPropertyBlock): void;
                public DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $submeshIndex: number, $shaderPass: number): void;
                public DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $submeshIndex: number): void;
                public DrawMesh($mesh: UnityEngine.Mesh, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material): void;
                public DrawMultipleMeshes($matrices: System.Array$1<UnityEngine.Matrix4x4>, $meshes: System.Array$1<UnityEngine.Mesh>, $subsetIndices: System.Array$1<number>, $count: number, $material: UnityEngine.Material, $shaderPass: number, $properties: UnityEngine.MaterialPropertyBlock): void;
                public DrawRenderer($renderer: UnityEngine.Renderer, $material: UnityEngine.Material, $submeshIndex: number, $shaderPass: number): void;
                public DrawRenderer($renderer: UnityEngine.Renderer, $material: UnityEngine.Material, $submeshIndex: number): void;
                public DrawRenderer($renderer: UnityEngine.Renderer, $material: UnityEngine.Material): void;
                public DrawRendererList($rendererList: UnityEngine.Rendering.RendererList): void;
                public DrawProcedural($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount: number, $properties: UnityEngine.MaterialPropertyBlock): void;
                public DrawProcedural($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $vertexCount: number, $instanceCount: number): void;
                public DrawProcedural($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $vertexCount: number): void;
                public DrawProcedural($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $indexCount: number, $instanceCount: number, $properties: UnityEngine.MaterialPropertyBlock): void;
                public DrawProcedural($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $indexCount: number, $instanceCount: number): void;
                public DrawProcedural($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $indexCount: number): void;
                public DrawProceduralIndirect($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock): void;
                public DrawProceduralIndirect($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number): void;
                public DrawProceduralIndirect($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer): void;
                public DrawProceduralIndirect($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock): void;
                public DrawProceduralIndirect($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number): void;
                public DrawProceduralIndirect($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.ComputeBuffer): void;
                public DrawProceduralIndirect($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock): void;
                public DrawProceduralIndirect($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number): void;
                public DrawProceduralIndirect($matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer): void;
                public DrawProceduralIndirect($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock): void;
                public DrawProceduralIndirect($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number): void;
                public DrawProceduralIndirect($indexBuffer: UnityEngine.GraphicsBuffer, $matrix: UnityEngine.Matrix4x4, $material: UnityEngine.Material, $shaderPass: number, $topology: UnityEngine.MeshTopology, $bufferWithArgs: UnityEngine.GraphicsBuffer): void;
                public DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number, $properties: UnityEngine.MaterialPropertyBlock): void;
                public DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $matrices: System.Array$1<UnityEngine.Matrix4x4>, $count: number): void;
                public DrawMeshInstanced($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $matrices: System.Array$1<UnityEngine.Matrix4x4>): void;
                public DrawMeshInstancedProcedural($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $count: number, $properties?: UnityEngine.MaterialPropertyBlock): void;
                public DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock): void;
                public DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.ComputeBuffer, $argsOffset: number): void;
                public DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.ComputeBuffer): void;
                public DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number, $properties: UnityEngine.MaterialPropertyBlock): void;
                public DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.GraphicsBuffer, $argsOffset: number): void;
                public DrawMeshInstancedIndirect($mesh: UnityEngine.Mesh, $submeshIndex: number, $material: UnityEngine.Material, $shaderPass: number, $bufferWithArgs: UnityEngine.GraphicsBuffer): void;
                public DrawOcclusionMesh($normalizedCamViewport: UnityEngine.RectInt): void;
                public SetRandomWriteTarget($index: number, $rt: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public SetRandomWriteTarget($index: number, $buffer: UnityEngine.ComputeBuffer, $preserveCounterValue: boolean): void;
                public SetRandomWriteTarget($index: number, $buffer: UnityEngine.ComputeBuffer): void;
                public SetRandomWriteTarget($index: number, $buffer: UnityEngine.GraphicsBuffer, $preserveCounterValue: boolean): void;
                public SetRandomWriteTarget($index: number, $buffer: UnityEngine.GraphicsBuffer): void;
                public CopyCounterValue($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number): void;
                public CopyCounterValue($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.ComputeBuffer, $dstOffsetBytes: number): void;
                public CopyCounterValue($src: UnityEngine.ComputeBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: number): void;
                public CopyCounterValue($src: UnityEngine.GraphicsBuffer, $dst: UnityEngine.GraphicsBuffer, $dstOffsetBytes: number): void;
                public CopyTexture($src: UnityEngine.Rendering.RenderTargetIdentifier, $dst: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public CopyTexture($src: UnityEngine.Rendering.RenderTargetIdentifier, $srcElement: number, $dst: UnityEngine.Rendering.RenderTargetIdentifier, $dstElement: number): void;
                public CopyTexture($src: UnityEngine.Rendering.RenderTargetIdentifier, $srcElement: number, $srcMip: number, $dst: UnityEngine.Rendering.RenderTargetIdentifier, $dstElement: number, $dstMip: number): void;
                public CopyTexture($src: UnityEngine.Rendering.RenderTargetIdentifier, $srcElement: number, $srcMip: number, $srcX: number, $srcY: number, $srcWidth: number, $srcHeight: number, $dst: UnityEngine.Rendering.RenderTargetIdentifier, $dstElement: number, $dstMip: number, $dstX: number, $dstY: number): void;
                public Blit($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public Blit($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2): void;
                public Blit($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $mat: UnityEngine.Material): void;
                public Blit($source: UnityEngine.Texture, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $mat: UnityEngine.Material, $pass: number): void;
                public Blit($source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public Blit($source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2): void;
                public Blit($source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $mat: UnityEngine.Material): void;
                public Blit($source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $mat: UnityEngine.Material, $pass: number): void;
                public Blit($source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $sourceDepthSlice: number, $destDepthSlice: number): void;
                public Blit($source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $scale: UnityEngine.Vector2, $offset: UnityEngine.Vector2, $sourceDepthSlice: number, $destDepthSlice: number): void;
                public Blit($source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $mat: UnityEngine.Material, $pass: number, $destDepthSlice: number): void;
                public SetGlobalFloat($name: string, $value: number): void;
                public SetGlobalInt($name: string, $value: number): void;
                public SetGlobalInteger($name: string, $value: number): void;
                public SetGlobalVector($name: string, $value: UnityEngine.Vector4): void;
                public SetGlobalColor($name: string, $value: UnityEngine.Color): void;
                public SetGlobalMatrix($name: string, $value: UnityEngine.Matrix4x4): void;
                public SetGlobalFloatArray($propertyName: string, $values: System.Collections.Generic.List$1<number>): void;
                public SetGlobalFloatArray($nameID: number, $values: System.Collections.Generic.List$1<number>): void;
                public SetGlobalFloatArray($propertyName: string, $values: System.Array$1<number>): void;
                public SetGlobalVectorArray($propertyName: string, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
                public SetGlobalVectorArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Vector4>): void;
                public SetGlobalVectorArray($propertyName: string, $values: System.Array$1<UnityEngine.Vector4>): void;
                public SetGlobalMatrixArray($propertyName: string, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
                public SetGlobalMatrixArray($nameID: number, $values: System.Collections.Generic.List$1<UnityEngine.Matrix4x4>): void;
                public SetGlobalMatrixArray($propertyName: string, $values: System.Array$1<UnityEngine.Matrix4x4>): void;
                public SetGlobalTexture($name: string, $value: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public SetGlobalTexture($nameID: number, $value: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public SetGlobalTexture($name: string, $value: UnityEngine.Rendering.RenderTargetIdentifier, $element: UnityEngine.Rendering.RenderTextureSubElement): void;
                public SetGlobalTexture($nameID: number, $value: UnityEngine.Rendering.RenderTargetIdentifier, $element: UnityEngine.Rendering.RenderTextureSubElement): void;
                public SetGlobalBuffer($name: string, $value: UnityEngine.ComputeBuffer): void;
                public SetGlobalBuffer($nameID: number, $value: UnityEngine.ComputeBuffer): void;
                public SetGlobalBuffer($name: string, $value: UnityEngine.GraphicsBuffer): void;
                public SetGlobalBuffer($nameID: number, $value: UnityEngine.GraphicsBuffer): void;
                public SetGlobalConstantBuffer($buffer: UnityEngine.ComputeBuffer, $nameID: number, $offset: number, $size: number): void;
                public SetGlobalConstantBuffer($buffer: UnityEngine.ComputeBuffer, $name: string, $offset: number, $size: number): void;
                public SetGlobalConstantBuffer($buffer: UnityEngine.GraphicsBuffer, $nameID: number, $offset: number, $size: number): void;
                public SetGlobalConstantBuffer($buffer: UnityEngine.GraphicsBuffer, $name: string, $offset: number, $size: number): void;
                public SetGlobalRayTracingAccelerationStructure($name: string, $accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure): void;
                public SetGlobalRayTracingAccelerationStructure($nameID: number, $accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure): void;
                public SetShadowSamplingMode($shadowmap: UnityEngine.Rendering.RenderTargetIdentifier, $mode: UnityEngine.Rendering.ShadowSamplingMode): void;
                public SetSinglePassStereo($mode: UnityEngine.Rendering.SinglePassStereoMode): void;
                public IssuePluginEvent($callback: number, $eventID: number): void;
                public IssuePluginEventAndData($callback: number, $eventID: number, $data: number): void;
                public IssuePluginEventAndDataWithFlags($callback: number, $eventID: number, $flags: UnityEngine.Rendering.CustomMarkerCallbackFlags, $data: number): void;
                public IssuePluginCustomBlit($callback: number, $command: number, $source: UnityEngine.Rendering.RenderTargetIdentifier, $dest: UnityEngine.Rendering.RenderTargetIdentifier, $commandParam: number, $commandFlags: number): void;
                public IssuePluginCustomTextureUpdate($callback: number, $targetTexture: UnityEngine.Texture, $userData: number): void;
                public IssuePluginCustomTextureUpdateV1($callback: number, $targetTexture: UnityEngine.Texture, $userData: number): void;
                public IssuePluginCustomTextureUpdateV2($callback: number, $targetTexture: UnityEngine.Texture, $userData: number): void;
                public ProcessVTFeedback($rt: UnityEngine.Rendering.RenderTargetIdentifier, $resolver: number, $slice: number, $x: number, $width: number, $y: number, $height: number, $mip: number): void;
                public CopyBuffer($source: UnityEngine.GraphicsBuffer, $dest: UnityEngine.GraphicsBuffer): void;
                public CreateGPUFence($stage: UnityEngine.Rendering.SynchronisationStage): UnityEngine.Rendering.GPUFence;
                public CreateGPUFence(): UnityEngine.Rendering.GPUFence;
                public WaitOnGPUFence($fence: UnityEngine.Rendering.GPUFence, $stage: UnityEngine.Rendering.SynchronisationStage): void;
                public WaitOnGPUFence($fence: UnityEngine.Rendering.GPUFence): void;
            }

            class CommandBufferExtensions {
                protected [__keep_incompatibility]: never;
                public static SwitchIntoFastMemory($rid: UnityEngine.Rendering.RenderTargetIdentifier, $fastMemoryFlags: UnityEngine.Rendering.FastMemoryFlags, $residency: number, $copyContents: boolean): void;
                public static SwitchOutOfFastMemory($rid: UnityEngine.Rendering.RenderTargetIdentifier, $copyContents: boolean): void;
            }

            class RenderPipelineGraphicsSettingsCollection {
                protected [__keep_incompatibility]: never;
                public get settingsList(): System.Collections.Generic.List$1<UnityEngine.Rendering.IRenderPipelineGraphicsSettings>;
                constructor();
            }

            class RenderPipelineGraphicsSettingsExtensions {
                protected [__keep_incompatibility]: never;
                public static SetValueAndNotify<T>($currentPropertyValue: $Ref<T>, $newValue: T, $propertyName?: string): void;
                public static NotifyValueChanged($propertyName?: string): void;
            }

            class RecreatePipelineOnChangeAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class ShadingRateImage {
                protected [__keep_incompatibility]: never;
                public static GetAllocTileSize($pixelSize: UnityEngine.Vector2Int): UnityEngine.Vector2Int;
                public static GetAllocTileSize($pixelWidth: number, $pixelHeight: number): UnityEngine.Vector2Int;
                public static AllocFromPixelSize($rtDesc: $Ref<UnityEngine.RenderTextureDescriptor>): UnityEngine.RenderTexture;
                public static GetRenderTextureDescriptor($width: number, $height: number, $volumeDepth?: number, $textureDimension?: UnityEngine.Rendering.TextureDimension): UnityEngine.RenderTextureDescriptor;
            }

            class ShadingRateInfo {
                protected [__keep_incompatibility]: never;
                public static get supportsPerImageTile(): boolean;
                public static get supportsPerDrawCall(): boolean;
                public static get imageTileSize(): UnityEngine.Vector2Int;
                public static get availableFragmentSizes(): System.Array$1<UnityEngine.Rendering.ShadingRateFragmentSize>;
                public static get graphicsFormat(): UnityEngine.Experimental.Rendering.GraphicsFormat;
                public static QueryNativeValue($fragmentSize: UnityEngine.Rendering.ShadingRateFragmentSize): number;
            }

            class SplashScreen {
                protected [__keep_incompatibility]: never;
                public static get isFinished(): boolean;
                constructor();
                public static Begin(): void;
                public static Stop($stopBehavior: UnityEngine.Rendering.SplashScreen.StopBehavior): void;
                public static Draw(): void;
            }
            namespace SplashScreen {
                enum StopBehavior {
                    StopImmediate = 0,
                    FadeOut = 1
                }

            }

            class SupportedOnRenderPipelineAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get renderPipelineTypes(): System.Array$1<System.Type>;
                public get isSupportedOnCurrentPipeline(): boolean;
                constructor($renderPipeline: System.Type);
                constructor(...renderPipeline: System.Type[]);
                public GetSupportedMode($renderPipelineAssetType: System.Type): UnityEngine.Rendering.SupportedOnRenderPipelineAttribute.SupportedMode;
                public static IsTypeSupportedOnRenderPipeline($type: System.Type, $renderPipelineAssetType: System.Type): boolean;
            }
            namespace SupportedOnRenderPipelineAttribute {
                enum SupportedMode {
                    Unsupported = 0,
                    Supported = 1,
                    SupportedByBaseClass = 2
                }

            }

            class Watermark {
                protected [__keep_incompatibility]: never;
                public static showDeveloperWatermark: boolean;
                constructor();
                public static IsVisible(): boolean;
            }

            class SphericalHarmonicsL2 implements System.IEquatable$1<UnityEngine.Rendering.SphericalHarmonicsL2> {
                protected [__keep_incompatibility]: never;
                public Clear(): void;
                public AddAmbientLight($color: UnityEngine.Color): void;
                public AddAmbientLight($color: $Ref<UnityEngine.Color>): void;
                public AddDirectionalLight($direction: UnityEngine.Vector3, $color: UnityEngine.Color, $intensity: number): void;
                public AddDirectionalLight($direction: $Ref<UnityEngine.Vector3>, $color: $Ref<UnityEngine.Color>, $intensity: number): void;
                public Evaluate($directions: System.Array$1<UnityEngine.Vector3>, $results: System.Array$1<UnityEngine.Color>): void;
                public GetHashCode(): number;
                public Equals($other: any): boolean;
                public Equals($other: UnityEngine.Rendering.SphericalHarmonicsL2): boolean;
                public Equals($other: $Ref<UnityEngine.Rendering.SphericalHarmonicsL2>): boolean;
                public get_Item($rgb: number, $coefficient: number): number;
                public set_Item($rgb: number, $coefficient: number, value: number): void;
            }

            class BatchID implements System.IEquatable$1<UnityEngine.Rendering.BatchID> {
                protected [__keep_incompatibility]: never;
                public static readonly Null: UnityEngine.Rendering.BatchID;
                public value: number;
                public GetHashCode(): number;
                public Equals($obj: any): boolean;
                public Equals($other: UnityEngine.Rendering.BatchID): boolean;
                public CompareTo($other: UnityEngine.Rendering.BatchID): number;
            }

            class BatchMaterialID implements System.IEquatable$1<UnityEngine.Rendering.BatchMaterialID> {
                protected [__keep_incompatibility]: never;
                public static readonly Null: UnityEngine.Rendering.BatchMaterialID;
                public value: number;
                public GetHashCode(): number;
                public Equals($obj: any): boolean;
                public Equals($other: UnityEngine.Rendering.BatchMaterialID): boolean;
                public CompareTo($other: UnityEngine.Rendering.BatchMaterialID): number;
            }

            class BatchMeshID implements System.IEquatable$1<UnityEngine.Rendering.BatchMeshID> {
                protected [__keep_incompatibility]: never;
                public static readonly Null: UnityEngine.Rendering.BatchMeshID;
                public value: number;
                public GetHashCode(): number;
                public Equals($obj: any): boolean;
                public Equals($other: UnityEngine.Rendering.BatchMeshID): boolean;
                public CompareTo($other: UnityEngine.Rendering.BatchMeshID): number;
            }

            enum BatchDrawCommandType {
                Direct = 0,
                Indirect = 1,
                Procedural = 2,
                ProceduralIndirect = 3
            }

            enum BatchDrawCommandFlags {
                None = 0,
                FlipWinding = 1,
                HasMotion = 2,
                IsLightMapped = 4,
                HasSortingPosition = 8,
                LODCrossFadeKeyword = 16,
                LODCrossFadeValuePacked = 32,
                LODCrossFade = 48,
                UseLegacyLightmapsKeyword = 64
            }

            enum BatchCullingFlags {
                None = 0,
                CullLightmappedShadowCasters = 1
            }

            enum BatchCullingViewType {
                Unknown = 0,
                Camera = 1,
                Light = 2,
                Picking = 3,
                SelectionOutline = 4,
                Filtering = 5
            }

            enum BatchCullingProjectionType {
                Unknown = 0,
                Perspective = 1,
                Orthographic = 2
            }

            enum BatchBufferTarget {
                Unknown = 0,
                RawBuffer = 1,
                ConstantBuffer = 2,
                UnsupportedByUnderlyingGraphicsApi = -1
            }

            class BatchPackedCullingViewID implements System.IEquatable$1<UnityEngine.Rendering.BatchPackedCullingViewID> {
                protected [__keep_incompatibility]: never;
                constructor($instanceID: number, $sliceIndex: number);
                public GetHashCode(): number;
                public Equals($other: UnityEngine.Rendering.BatchPackedCullingViewID): boolean;
                public Equals($obj: any): boolean;
                public GetInstanceID(): number;
                public GetSliceIndex(): number;
            }

            class BatchDrawCommand {
                protected [__keep_incompatibility]: never;
                public flags: UnityEngine.Rendering.BatchDrawCommandFlags;
                public batchID: UnityEngine.Rendering.BatchID;
                public materialID: UnityEngine.Rendering.BatchMaterialID;
                public splitVisibilityMask: number;
                public lightmapIndex: number;
                public sortingPosition: number;
                public visibleOffset: number;
                public visibleCount: number;
                public meshID: UnityEngine.Rendering.BatchMeshID;
                public submeshIndex: number;
                public activeMeshLod: number;
            }

            class BatchDrawCommandIndirect {
                protected [__keep_incompatibility]: never;
                public flags: UnityEngine.Rendering.BatchDrawCommandFlags;
                public batchID: UnityEngine.Rendering.BatchID;
                public materialID: UnityEngine.Rendering.BatchMaterialID;
                public splitVisibilityMask: number;
                public lightmapIndex: number;
                public sortingPosition: number;
                public visibleOffset: number;
                public meshID: UnityEngine.Rendering.BatchMeshID;
                public topology: UnityEngine.MeshTopology;
                public visibleInstancesBufferHandle: UnityEngine.GraphicsBufferHandle;
                public visibleInstancesBufferWindowOffset: number;
                public visibleInstancesBufferWindowSizeBytes: number;
                public indirectArgsBufferHandle: UnityEngine.GraphicsBufferHandle;
                public indirectArgsBufferOffset: number;
            }

            class BatchDrawCommandProcedural {
                protected [__keep_incompatibility]: never;
                public flags: UnityEngine.Rendering.BatchDrawCommandFlags;
                public batchID: UnityEngine.Rendering.BatchID;
                public materialID: UnityEngine.Rendering.BatchMaterialID;
                public splitVisibilityMask: number;
                public lightmapIndex: number;
                public sortingPosition: number;
                public visibleOffset: number;
                public visibleCount: number;
                public topology: UnityEngine.MeshTopology;
                public indexBufferHandle: UnityEngine.GraphicsBufferHandle;
                public baseVertex: number;
                public indexOffsetBytes: number;
                public elementCount: number;
            }

            class BatchDrawCommandProceduralIndirect {
                protected [__keep_incompatibility]: never;
                public flags: UnityEngine.Rendering.BatchDrawCommandFlags;
                public batchID: UnityEngine.Rendering.BatchID;
                public materialID: UnityEngine.Rendering.BatchMaterialID;
                public splitVisibilityMask: number;
                public lightmapIndex: number;
                public sortingPosition: number;
                public visibleOffset: number;
                public topology: UnityEngine.MeshTopology;
                public indexBufferHandle: UnityEngine.GraphicsBufferHandle;
                public visibleInstancesBufferHandle: UnityEngine.GraphicsBufferHandle;
                public visibleInstancesBufferWindowOffset: number;
                public visibleInstancesBufferWindowSizeBytes: number;
                public indirectArgsBufferHandle: UnityEngine.GraphicsBufferHandle;
                public indirectArgsBufferOffset: number;
            }

            class BatchFilterSettings {
                protected [__keep_incompatibility]: never;
                public renderingLayerMask: number;
                public rendererPriority: number;
                public layer: number;
                public batchLayer: number;
                public motionMode: UnityEngine.MotionVectorGenerationMode;
                public shadowCastingMode: UnityEngine.Rendering.ShadowCastingMode;
                public receiveShadows: boolean;
                public staticShadowCaster: boolean;
                public allDepthSorted: boolean;
                public sceneCullingMask: bigint;
            }

            class BatchDrawRange {
                protected [__keep_incompatibility]: never;
                public drawCommandsType: UnityEngine.Rendering.BatchDrawCommandType;
                public drawCommandsBegin: number;
                public drawCommandsCount: number;
                public filterSettings: UnityEngine.Rendering.BatchFilterSettings;
            }

            class BatchCullingOutputDrawCommands {
                protected [__keep_incompatibility]: never;
                public drawCommandCount: number;
                public indirectDrawCommandCount: number;
                public proceduralDrawCommandCount: number;
                public proceduralIndirectDrawCommandCount: number;
                public visibleInstanceCount: number;
                public drawRangeCount: number;
                public instanceSortingPositionFloatCount: number;
            }

            class MetadataValue {
                protected [__keep_incompatibility]: never;
                public NameID: number;
                public Value: number;
            }

            class CullingSplit {
                protected [__keep_incompatibility]: never;
                public sphereCenter: UnityEngine.Vector3;
                public sphereRadius: number;
                public cullingPlaneOffset: number;
                public cullingPlaneCount: number;
                public cascadeBlendCullingFactor: number;
                public nearPlane: number;
                public cullingMatrix: UnityEngine.Matrix4x4;
            }

            class BatchCullingContext {
                protected [__keep_incompatibility]: never;
                public readonly cullingPlanes: Unity.Collections.NativeArray$1<UnityEngine.Plane>;
                public readonly cullingSplits: Unity.Collections.NativeArray$1<UnityEngine.Rendering.CullingSplit>;
                public readonly lodParameters: UnityEngine.Rendering.LODParameters;
                public readonly localToWorldMatrix: UnityEngine.Matrix4x4;
                public readonly viewType: UnityEngine.Rendering.BatchCullingViewType;
                public readonly projectionType: UnityEngine.Rendering.BatchCullingProjectionType;
                public readonly cullingFlags: UnityEngine.Rendering.BatchCullingFlags;
                public readonly viewID: UnityEngine.Rendering.BatchPackedCullingViewID;
                public readonly cullingLayerMask: number;
                public readonly sceneCullingMask: bigint;
                public readonly splitExclusionMask: number;
                public readonly isOrthographic: number;
                public readonly receiverPlaneOffset: number;
                public readonly receiverPlaneCount: number;
            }

            class BatchCullingOutput {
                protected [__keep_incompatibility]: never;
                public drawCommands: Unity.Collections.NativeArray$1<UnityEngine.Rendering.BatchCullingOutputDrawCommands>;
                public customCullingResult: Unity.Collections.NativeArray$1<number>;
            }

            class ThreadedBatchContext {
                protected [__keep_incompatibility]: never;
                public batchRendererGroup: number;
                public AddBatch($batchMetadata: Unity.Collections.NativeArray$1<UnityEngine.Rendering.MetadataValue>, $buffer: UnityEngine.GraphicsBufferHandle): UnityEngine.Rendering.BatchID;
                public AddBatch($batchMetadata: Unity.Collections.NativeArray$1<UnityEngine.Rendering.MetadataValue>, $buffer: UnityEngine.GraphicsBufferHandle, $bufferOffset: number, $windowSize: number): UnityEngine.Rendering.BatchID;
                public SetBatchBuffer($batchID: UnityEngine.Rendering.BatchID, $buffer: UnityEngine.GraphicsBufferHandle): void;
                public RemoveBatch($batchID: UnityEngine.Rendering.BatchID): void;
            }

            class BatchRendererGroupCreateInfo {
                protected [__keep_incompatibility]: never;
                public cullingCallback: UnityEngine.Rendering.BatchRendererGroup.OnPerformCulling;
                public finishedCullingCallback: UnityEngine.Rendering.BatchRendererGroup.OnFinishedCulling;
                public userContext: number;
            }

            class BatchRendererGroup implements System.IDisposable {
                protected [__keep_incompatibility]: never;
                public static get BufferTarget(): UnityEngine.Rendering.BatchBufferTarget;
                constructor($cullingCallback: UnityEngine.Rendering.BatchRendererGroup.OnPerformCulling, $userContext: number);
                constructor($info: UnityEngine.Rendering.BatchRendererGroupCreateInfo);
                public Dispose(): void;
                public GetThreadedBatchContext(): UnityEngine.Rendering.ThreadedBatchContext;
                public AddBatch($batchMetadata: Unity.Collections.NativeArray$1<UnityEngine.Rendering.MetadataValue>, $buffer: UnityEngine.GraphicsBufferHandle): UnityEngine.Rendering.BatchID;
                public AddBatch($batchMetadata: Unity.Collections.NativeArray$1<UnityEngine.Rendering.MetadataValue>, $buffer: UnityEngine.GraphicsBufferHandle, $bufferOffset: number, $windowSize: number): UnityEngine.Rendering.BatchID;
                public RemoveBatch($batchID: UnityEngine.Rendering.BatchID): void;
                public SetBatchBuffer($batchID: UnityEngine.Rendering.BatchID, $buffer: UnityEngine.GraphicsBufferHandle): void;
                public RegisterMaterial($material: UnityEngine.Material): UnityEngine.Rendering.BatchMaterialID;
                public UnregisterMaterial($material: UnityEngine.Rendering.BatchMaterialID): void;
                public GetRegisteredMaterial($material: UnityEngine.Rendering.BatchMaterialID): UnityEngine.Material;
                public RegisterMesh($mesh: UnityEngine.Mesh): UnityEngine.Rendering.BatchMeshID;
                public UnregisterMesh($mesh: UnityEngine.Rendering.BatchMeshID): void;
                public GetRegisteredMesh($mesh: UnityEngine.Rendering.BatchMeshID): UnityEngine.Mesh;
                public SetGlobalBounds($bounds: UnityEngine.Bounds): void;
                public SetPickingMaterial($material: UnityEngine.Material): void;
                public SetErrorMaterial($material: UnityEngine.Material): void;
                public SetLoadingMaterial($material: UnityEngine.Material): void;
                public SetEnabledViewTypes($viewTypes: System.Array$1<UnityEngine.Rendering.BatchCullingViewType>): void;
                public static GetConstantBufferMaxWindowSize(): number;
                public static GetConstantBufferOffsetAlignment(): number;
            }
            namespace BatchRendererGroup {
                interface OnPerformCulling {
                    ($rendererGroup: UnityEngine.Rendering.BatchRendererGroup, $cullingContext: UnityEngine.Rendering.BatchCullingContext, $cullingOutput: UnityEngine.Rendering.BatchCullingOutput, $userContext: number): Unity.Jobs.JobHandle;
                    Invoke?: ($rendererGroup: UnityEngine.Rendering.BatchRendererGroup, $cullingContext: UnityEngine.Rendering.BatchCullingContext, $cullingOutput: UnityEngine.Rendering.BatchCullingOutput, $userContext: number) => Unity.Jobs.JobHandle;
                }
                var OnPerformCulling: { new (func: ($rendererGroup: UnityEngine.Rendering.BatchRendererGroup, $cullingContext: UnityEngine.Rendering.BatchCullingContext, $cullingOutput: UnityEngine.Rendering.BatchCullingOutput, $userContext: number) => Unity.Jobs.JobHandle): OnPerformCulling; };

                interface OnFinishedCulling {
                    ($customCullingResult: number): void;
                    Invoke?: ($customCullingResult: number) => void;
                }
                var OnFinishedCulling: { new (func: ($customCullingResult: number) => void): OnFinishedCulling; };

            }

            class AttachmentDescriptor implements System.IEquatable$1<UnityEngine.Rendering.AttachmentDescriptor> {
                protected [__keep_incompatibility]: never;
                public loadAction: UnityEngine.Rendering.RenderBufferLoadAction;
                public storeAction: UnityEngine.Rendering.RenderBufferStoreAction;
                public graphicsFormat: UnityEngine.Experimental.Rendering.GraphicsFormat;
                public format: UnityEngine.RenderTextureFormat;
                public loadStoreTarget: UnityEngine.Rendering.RenderTargetIdentifier;
                public resolveTarget: UnityEngine.Rendering.RenderTargetIdentifier;
                public clearColor: UnityEngine.Color;
                public clearDepth: number;
                public clearStencil: number;
                constructor($format: UnityEngine.Experimental.Rendering.GraphicsFormat);
                constructor($format: UnityEngine.RenderTextureFormat);
                constructor($format: UnityEngine.RenderTextureFormat, $target: UnityEngine.Rendering.RenderTargetIdentifier, $loadExistingContents?: boolean, $storeResults?: boolean, $resolve?: boolean);
                public ConfigureTarget($target: UnityEngine.Rendering.RenderTargetIdentifier, $loadExistingContents: boolean, $storeResults: boolean): void;
                public ConfigureResolveTarget($target: UnityEngine.Rendering.RenderTargetIdentifier): void;
                public ConfigureClear($clearColor: UnityEngine.Color, $clearDepth?: number, $clearStencil?: number): void;
                public Equals($other: UnityEngine.Rendering.AttachmentDescriptor): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            enum SubPassFlags {
                None = 0,
                ReadOnlyDepth = 2,
                ReadOnlyStencil = 4,
                ReadOnlyDepthStencil = 6,
                UseShadingRateImage = 8,
                TileProperties = 16,
                MultiviewRenderRegionsCompatible = 32
            }

            class AttachmentIndexArray {
                protected [__keep_incompatibility]: never;
                public static Emtpy: UnityEngine.Rendering.AttachmentIndexArray;
                public static readonly MaxAttachments: number;
                public get Length(): number;
                constructor($numAttachments: number);
                constructor($attachments: System.Array$1<number>);
                constructor($attachments: Unity.Collections.NativeArray$1<number>);
                public get_Item($index: number): number;
                public set_Item($index: number, value: number): void;
            }

            class SubPassDescriptor {
                protected [__keep_incompatibility]: never;
                public inputs: UnityEngine.Rendering.AttachmentIndexArray;
                public colorOutputs: UnityEngine.Rendering.AttachmentIndexArray;
                public flags: UnityEngine.Rendering.SubPassFlags;
            }

            class BlendState implements System.IEquatable$1<UnityEngine.Rendering.BlendState> {
                protected [__keep_incompatibility]: never;
                public static get defaultValue(): UnityEngine.Rendering.BlendState;
                public separateMRTBlendStates: boolean;
                public alphaToMask: boolean;
                public blendState0: UnityEngine.Rendering.RenderTargetBlendState;
                public blendState1: UnityEngine.Rendering.RenderTargetBlendState;
                public blendState2: UnityEngine.Rendering.RenderTargetBlendState;
                public blendState3: UnityEngine.Rendering.RenderTargetBlendState;
                public blendState4: UnityEngine.Rendering.RenderTargetBlendState;
                public blendState5: UnityEngine.Rendering.RenderTargetBlendState;
                public blendState6: UnityEngine.Rendering.RenderTargetBlendState;
                public blendState7: UnityEngine.Rendering.RenderTargetBlendState;
                constructor($separateMRTBlend?: boolean, $alphaToMask?: boolean);
                public Equals($other: UnityEngine.Rendering.BlendState): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class CameraProperties implements System.IEquatable$1<UnityEngine.Rendering.CameraProperties> {
                protected [__keep_incompatibility]: never;
                public GetShadowCullingPlane($index: number): UnityEngine.Plane;
                public SetShadowCullingPlane($index: number, $plane: UnityEngine.Plane): void;
                public GetCameraCullingPlane($index: number): UnityEngine.Plane;
                public SetCameraCullingPlane($index: number, $plane: UnityEngine.Plane): void;
                public Equals($other: UnityEngine.Rendering.CameraProperties): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            enum CullingOptions {
                None = 0,
                ForceEvenIfCameraIsNotActive = 1,
                OcclusionCull = 2,
                NeedsLighting = 4,
                NeedsReflectionProbes = 8,
                Stereo = 16,
                DisablePerObjectCulling = 32,
                ShadowCasters = 64
            }

            class ScriptableCullingParameters implements System.IEquatable$1<UnityEngine.Rendering.ScriptableCullingParameters> {
                protected [__keep_incompatibility]: never;
                public static readonly maximumCullingPlaneCount: number;
                public static readonly layerCount: number;
                public maximumVisibleLights: number;
                public conservativeEnclosingSphere: boolean;
                public numIterationsEnclosingSphere: number;
                public cullingPlaneCount: number;
                public isOrthographic: boolean;
                public lodParameters: UnityEngine.Rendering.LODParameters;
                public cullingMask: number;
                public cullingMatrix: UnityEngine.Matrix4x4;
                public origin: UnityEngine.Vector3;
                public shadowDistance: number;
                public shadowNearPlaneOffset: number;
                public cullingOptions: UnityEngine.Rendering.CullingOptions;
                public reflectionProbeSortingCriteria: UnityEngine.Rendering.ReflectionProbeSortingCriteria;
                public cameraProperties: UnityEngine.Rendering.CameraProperties;
                public stereoViewMatrix: UnityEngine.Matrix4x4;
                public stereoProjectionMatrix: UnityEngine.Matrix4x4;
                public stereoSeparationDistance: number;
                public accurateOcclusionThreshold: number;
                public maximumPortalCullingJobs: number;
                public static get cullingJobsLowerLimit(): number;
                public static get cullingJobsUpperLimit(): number;
                public GetLayerCullingDistance($layerIndex: number): number;
                public SetLayerCullingDistance($layerIndex: number, $distance: number): void;
                public GetCullingPlane($index: number): UnityEngine.Plane;
                public SetCullingPlane($index: number, $plane: UnityEngine.Plane): void;
                public Equals($other: UnityEngine.Rendering.ScriptableCullingParameters): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class LightShadowCasterCullingInfo {
                protected [__keep_incompatibility]: never;
                public splitRange: UnityEngine.RangeInt;
                public projectionType: UnityEngine.Rendering.BatchCullingProjectionType;
                public splitExclusionMask: number;
            }

            class ShadowCastersCullingInfos {
                protected [__keep_incompatibility]: never;
                public splitBuffer: Unity.Collections.NativeArray$1<UnityEngine.Rendering.ShadowSplitData>;
                public perLightInfos: Unity.Collections.NativeArray$1<UnityEngine.Rendering.LightShadowCasterCullingInfo>;
            }

            class CullingResults implements System.IEquatable$1<UnityEngine.Rendering.CullingResults> {
                protected [__keep_incompatibility]: never;
                public get visibleLights(): Unity.Collections.NativeArray$1<UnityEngine.Rendering.VisibleLight>;
                public get visibleOffscreenVertexLights(): Unity.Collections.NativeArray$1<UnityEngine.Rendering.VisibleLight>;
                public get visibleReflectionProbes(): Unity.Collections.NativeArray$1<UnityEngine.Rendering.VisibleReflectionProbe>;
                public get lightIndexCount(): number;
                public get reflectionProbeIndexCount(): number;
                public get lightAndReflectionProbeIndexCount(): number;
                public FillLightAndReflectionProbeIndices($computeBuffer: UnityEngine.ComputeBuffer): void;
                public FillLightAndReflectionProbeIndices($buffer: UnityEngine.GraphicsBuffer): void;
                public GetLightIndexMap($allocator: Unity.Collections.Allocator): Unity.Collections.NativeArray$1<number>;
                public SetLightIndexMap($lightIndexMap: Unity.Collections.NativeArray$1<number>): void;
                public GetReflectionProbeIndexMap($allocator: Unity.Collections.Allocator): Unity.Collections.NativeArray$1<number>;
                public SetReflectionProbeIndexMap($lightIndexMap: Unity.Collections.NativeArray$1<number>): void;
                public GetShadowCasterBounds($lightIndex: number, $outBounds: $Out<UnityEngine.Bounds>): boolean;
                public ComputeSpotShadowMatricesAndCullingPrimitives($activeLightIndex: number, $viewMatrix: $Out<UnityEngine.Matrix4x4>, $projMatrix: $Out<UnityEngine.Matrix4x4>, $shadowSplitData: $Out<UnityEngine.Rendering.ShadowSplitData>): boolean;
                public ComputePointShadowMatricesAndCullingPrimitives($activeLightIndex: number, $cubemapFace: UnityEngine.CubemapFace, $fovBias: number, $viewMatrix: $Out<UnityEngine.Matrix4x4>, $projMatrix: $Out<UnityEngine.Matrix4x4>, $shadowSplitData: $Out<UnityEngine.Rendering.ShadowSplitData>): boolean;
                public ComputeDirectionalShadowMatricesAndCullingPrimitives($activeLightIndex: number, $splitIndex: number, $splitCount: number, $splitRatio: UnityEngine.Vector3, $shadowResolution: number, $shadowNearPlaneOffset: number, $viewMatrix: $Out<UnityEngine.Matrix4x4>, $projMatrix: $Out<UnityEngine.Matrix4x4>, $shadowSplitData: $Out<UnityEngine.Rendering.ShadowSplitData>): boolean;
                public Equals($other: UnityEngine.Rendering.CullingResults): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class DepthState implements System.IEquatable$1<UnityEngine.Rendering.DepthState> {
                protected [__keep_incompatibility]: never;
                public static get defaultValue(): UnityEngine.Rendering.DepthState;
                public writeEnabled: boolean;
                public compareFunction: UnityEngine.Rendering.CompareFunction;
                constructor($writeEnabled?: boolean, $compareFunction?: UnityEngine.Rendering.CompareFunction);
                public Equals($other: UnityEngine.Rendering.DepthState): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class DrawingSettings implements System.IEquatable$1<UnityEngine.Rendering.DrawingSettings> {
                protected [__keep_incompatibility]: never;
                public static readonly maxShaderPasses: number;
                public sortingSettings: UnityEngine.Rendering.SortingSettings;
                public perObjectData: UnityEngine.Rendering.PerObjectData;
                public enableDynamicBatching: boolean;
                public enableInstancing: boolean;
                public overrideMaterial: UnityEngine.Material;
                public overrideShader: UnityEngine.Shader;
                public overrideMaterialPassIndex: number;
                public overrideShaderPassIndex: number;
                public fallbackMaterial: UnityEngine.Material;
                public mainLightIndex: number;
                public lodCrossFadeStencilMask: number;
                constructor($shaderPassName: UnityEngine.Rendering.ShaderTagId, $sortingSettings: UnityEngine.Rendering.SortingSettings);
                public GetShaderPassName($index: number): UnityEngine.Rendering.ShaderTagId;
                public SetShaderPassName($index: number, $shaderPassName: UnityEngine.Rendering.ShaderTagId): void;
                public Equals($other: UnityEngine.Rendering.DrawingSettings): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class FilteringSettings implements System.IEquatable$1<UnityEngine.Rendering.FilteringSettings> {
                protected [__keep_incompatibility]: never;
                public static get defaultValue(): UnityEngine.Rendering.FilteringSettings;
                public renderQueueRange: UnityEngine.Rendering.RenderQueueRange;
                public layerMask: number;
                public renderingLayerMask: number;
                public batchLayerMask: number;
                public excludeMotionVectorObjects: boolean;
                public forceAllMotionVectorObjects: boolean;
                public sortingLayerRange: UnityEngine.Rendering.SortingLayerRange;
                constructor($renderQueueRange?: UnityEngine.Rendering.RenderQueueRange | null, $layerMask?: number, $renderingLayerMask?: number, $excludeMotionVectorObjects?: number);
                public Equals($other: UnityEngine.Rendering.FilteringSettings): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            enum GizmoSubset {
                PreImageEffects = 0,
                PostImageEffects = 1
            }

            class InvalidImportException extends System.Exception {
                protected [__keep_incompatibility]: never;
                constructor($message: string);
            }

            class LODParameters implements System.IEquatable$1<UnityEngine.Rendering.LODParameters> {
                protected [__keep_incompatibility]: never;
                public isOrthographic: boolean;
                public cameraPosition: UnityEngine.Vector3;
                public fieldOfView: number;
                public orthoSize: number;
                public cameraPixelHeight: number;
                public Equals($other: UnityEngine.Rendering.LODParameters): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class ObjectIdRequest {
                protected [__keep_incompatibility]: never;
                public destination: UnityEngine.RenderTexture;
                public mipLevel: number;
                public face: UnityEngine.CubemapFace;
                public slice: number;
                public get result(): UnityEngine.Rendering.ObjectIdResult;
                constructor($destination: UnityEngine.RenderTexture, $mipLevel?: number, $face?: UnityEngine.CubemapFace, $slice?: number);
            }

            class ObjectIdResult {
                protected [__keep_incompatibility]: never;
                public get idToObjectMapping(): System.Array$1<UnityEngine.Object>;
                public static DecodeIdFromColor($color: UnityEngine.Color): number;
            }

            enum PerObjectData {
                None = 0,
                LightProbe = 1,
                ReflectionProbes = 2,
                LightProbeProxyVolume = 4,
                Lightmaps = 8,
                LightData = 16,
                MotionVectors = 32,
                LightIndices = 64,
                ReflectionProbeData = 128,
                OcclusionProbe = 256,
                OcclusionProbeProxyVolume = 512,
                ShadowMask = 1024
            }

            class RasterState implements System.IEquatable$1<UnityEngine.Rendering.RasterState> {
                protected [__keep_incompatibility]: never;
                public static readonly defaultValue: UnityEngine.Rendering.RasterState;
                public cullingMode: UnityEngine.Rendering.CullMode;
                public depthClip: boolean;
                public conservative: boolean;
                public offsetUnits: number;
                public offsetFactor: number;
                constructor($cullingMode?: UnityEngine.Rendering.CullMode, $offsetUnits?: number, $offsetFactor?: number, $depthClip?: boolean);
                public Equals($other: UnityEngine.Rendering.RasterState): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            enum ReflectionProbeSortingCriteria {
                None = 0,
                Importance = 1,
                Size = 2,
                ImportanceThenSize = 3
            }

            class RendererList {
                protected [__keep_incompatibility]: never;
                public static readonly nullRendererList: UnityEngine.Rendering.RendererList;
                public get isValid(): boolean;
            }

            enum RendererListStatus {
                kRendererListEmpty = 0,
                kRendererListPopulated = 1,
                kRendererListInvalid = -2,
                kRendererListProcessing = -1
            }

            class RendererListParams implements System.IEquatable$1<UnityEngine.Rendering.RendererListParams> {
                protected [__keep_incompatibility]: never;
                public static readonly Invalid: UnityEngine.Rendering.RendererListParams;
                public cullingResults: UnityEngine.Rendering.CullingResults;
                public drawSettings: UnityEngine.Rendering.DrawingSettings;
                public filteringSettings: UnityEngine.Rendering.FilteringSettings;
                public tagName: UnityEngine.Rendering.ShaderTagId;
                public isPassTagName: boolean;
                public tagValues: Unity.Collections.NativeArray$1<UnityEngine.Rendering.ShaderTagId> | null;
                public stateBlocks: Unity.Collections.NativeArray$1<UnityEngine.Rendering.RenderStateBlock> | null;
                constructor($cullingResults: UnityEngine.Rendering.CullingResults, $drawSettings: UnityEngine.Rendering.DrawingSettings, $filteringSettings: UnityEngine.Rendering.FilteringSettings);
                public Equals($other: UnityEngine.Rendering.RendererListParams): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class RenderPipeline {
                protected [__keep_incompatibility]: never;
                public get disposed(): boolean;
                public get defaultSettings(): UnityEngine.Rendering.RenderPipelineGlobalSettings;
                public static SupportsRenderRequest<RequestData>($camera: UnityEngine.Camera, $data: RequestData): boolean;
                public static SubmitRenderRequest<RequestData>($camera: UnityEngine.Camera, $data: RequestData): void;
            }
            namespace RenderPipeline {
                class StandardRequest {
                    protected [__keep_incompatibility]: never;
                    public destination: UnityEngine.RenderTexture;
                    public mipLevel: number;
                    public face: UnityEngine.CubemapFace;
                    public slice: number;
                    constructor();
                }

            }

            class RenderPipelineAsset extends UnityEngine.ScriptableObject {
                protected [__keep_incompatibility]: never;
                public get terrainBrushPassIndex(): number;
                public get defaultMaterial(): UnityEngine.Material;
                public get autodeskInteractiveShader(): UnityEngine.Shader;
                public get autodeskInteractiveTransparentShader(): UnityEngine.Shader;
                public get autodeskInteractiveMaskedShader(): UnityEngine.Shader;
                public get terrainDetailLitShader(): UnityEngine.Shader;
                public get terrainDetailGrassShader(): UnityEngine.Shader;
                public get terrainDetailGrassBillboardShader(): UnityEngine.Shader;
                public get defaultParticleMaterial(): UnityEngine.Material;
                public get defaultLineMaterial(): UnityEngine.Material;
                public get defaultTerrainMaterial(): UnityEngine.Material;
                public get defaultUIMaterial(): UnityEngine.Material;
                public get defaultUIOverdrawMaterial(): UnityEngine.Material;
                public get defaultUIETC1SupportedMaterial(): UnityEngine.Material;
                public get default2DMaterial(): UnityEngine.Material;
                public get default2DMaskMaterial(): UnityEngine.Material;
                public get defaultShader(): UnityEngine.Shader;
                public get defaultSpeedTree7Shader(): UnityEngine.Shader;
                public get defaultSpeedTree8Shader(): UnityEngine.Shader;
                public get defaultSpeedTree9Shader(): UnityEngine.Shader;
                public get renderPipelineShaderTag(): string;
                public get pipelineType(): System.Type;
                public get renderingLayerMaskNames(): System.Array$1<string>;
                public get prefixedRenderingLayerMaskNames(): System.Array$1<string>;
            }

            class RenderPipelineAsset<TRenderPipeline extends UnityEngine.Rendering.RenderPipeline> extends UnityEngine.Rendering.RenderPipelineAsset {
                protected [__keep_incompatibility]: never;
                public get pipelineType(): System.Type;
                public get renderPipelineShaderTag(): string;
            }

            class RenderPipelineGlobalSettings extends UnityEngine.ScriptableObject implements UnityEngine.ISerializationCallbackReceiver {
                protected [__keep_incompatibility]: never;
                public Initialize($source?: UnityEngine.Rendering.RenderPipelineGlobalSettings): void;
                public OnBeforeSerialize(): void;
                public OnAfterDeserialize(): void;
            }

            class RenderPipelineManager {
                protected [__keep_incompatibility]: never;
                public static get currentPipeline(): UnityEngine.Rendering.RenderPipeline;
                public static get pipelineSwitchCompleted(): boolean;
                public static add_beginContextRendering(handler: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Collections.Generic.List$1<UnityEngine.Camera>>): void;
                public static remove_beginContextRendering(handler: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Collections.Generic.List$1<UnityEngine.Camera>>): void;
                public static add_endContextRendering(handler: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Collections.Generic.List$1<UnityEngine.Camera>>): void;
                public static remove_endContextRendering(handler: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Collections.Generic.List$1<UnityEngine.Camera>>): void;
                public static add_beginCameraRendering(handler: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, UnityEngine.Camera>): void;
                public static remove_beginCameraRendering(handler: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, UnityEngine.Camera>): void;
                public static add_endCameraRendering(handler: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, UnityEngine.Camera>): void;
                public static remove_endCameraRendering(handler: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, UnityEngine.Camera>): void;
                public static add_activeRenderPipelineTypeChanged(handler: System.Action): void;
                public static remove_activeRenderPipelineTypeChanged(handler: System.Action): void;
                public static add_activeRenderPipelineAssetChanged(handler: System.Action$2<UnityEngine.Rendering.RenderPipelineAsset, UnityEngine.Rendering.RenderPipelineAsset>): void;
                public static remove_activeRenderPipelineAssetChanged(handler: System.Action$2<UnityEngine.Rendering.RenderPipelineAsset, UnityEngine.Rendering.RenderPipelineAsset>): void;
                public static add_activeRenderPipelineCreated(handler: System.Action): void;
                public static remove_activeRenderPipelineCreated(handler: System.Action): void;
                public static add_activeRenderPipelineDisposed(handler: System.Action): void;
                public static remove_activeRenderPipelineDisposed(handler: System.Action): void;
                public static add_beginFrameRendering(handler: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Array$1<UnityEngine.Camera>>): void;
                public static remove_beginFrameRendering(handler: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Array$1<UnityEngine.Camera>>): void;
                public static add_endFrameRendering(handler: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Array$1<UnityEngine.Camera>>): void;
                public static remove_endFrameRendering(handler: System.Action$2<UnityEngine.Rendering.ScriptableRenderContext, System.Array$1<UnityEngine.Camera>>): void;
            }

            class RenderQueueRange implements System.IEquatable$1<UnityEngine.Rendering.RenderQueueRange> {
                protected [__keep_incompatibility]: never;
                public static readonly minimumBound: number;
                public static readonly maximumBound: number;
                public static get all(): UnityEngine.Rendering.RenderQueueRange;
                public static get opaque(): UnityEngine.Rendering.RenderQueueRange;
                public static get transparent(): UnityEngine.Rendering.RenderQueueRange;
                public lowerBound: number;
                public upperBound: number;
                constructor($lowerBound: number, $upperBound: number);
                public Equals($other: UnityEngine.Rendering.RenderQueueRange): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class RenderStateBlock implements System.IEquatable$1<UnityEngine.Rendering.RenderStateBlock> {
                protected [__keep_incompatibility]: never;
                public blendState: UnityEngine.Rendering.BlendState;
                public rasterState: UnityEngine.Rendering.RasterState;
                public depthState: UnityEngine.Rendering.DepthState;
                public stencilState: UnityEngine.Rendering.StencilState;
                public stencilReference: number;
                public mask: UnityEngine.Rendering.RenderStateMask;
                constructor($mask: UnityEngine.Rendering.RenderStateMask);
                public Equals($other: UnityEngine.Rendering.RenderStateBlock): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            enum RenderStateMask {
                Nothing = 0,
                Blend = 1,
                Raster = 2,
                Depth = 4,
                Stencil = 8,
                Everything = 15
            }

            class RenderTargetBlendState implements System.IEquatable$1<UnityEngine.Rendering.RenderTargetBlendState> {
                protected [__keep_incompatibility]: never;
                public static get defaultValue(): UnityEngine.Rendering.RenderTargetBlendState;
                public writeMask: UnityEngine.Rendering.ColorWriteMask;
                public sourceColorBlendMode: UnityEngine.Rendering.BlendMode;
                public destinationColorBlendMode: UnityEngine.Rendering.BlendMode;
                public sourceAlphaBlendMode: UnityEngine.Rendering.BlendMode;
                public destinationAlphaBlendMode: UnityEngine.Rendering.BlendMode;
                public colorBlendOperation: UnityEngine.Rendering.BlendOp;
                public alphaBlendOperation: UnityEngine.Rendering.BlendOp;
                constructor($writeMask?: UnityEngine.Rendering.ColorWriteMask, $sourceColorBlendMode?: UnityEngine.Rendering.BlendMode, $destinationColorBlendMode?: UnityEngine.Rendering.BlendMode, $sourceAlphaBlendMode?: UnityEngine.Rendering.BlendMode, $destinationAlphaBlendMode?: UnityEngine.Rendering.BlendMode, $colorBlendOperation?: UnityEngine.Rendering.BlendOp, $alphaBlendOperation?: UnityEngine.Rendering.BlendOp);
                public Equals($other: UnityEngine.Rendering.RenderTargetBlendState): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class ScopedRenderPass implements System.IDisposable {
                protected [__keep_incompatibility]: never;
                public Dispose(): void;
            }

            class ScopedSubPass implements System.IDisposable {
                protected [__keep_incompatibility]: never;
                public Dispose(): void;
            }

            class ScriptableRenderContext implements System.IEquatable$1<UnityEngine.Rendering.ScriptableRenderContext> {
                protected [__keep_incompatibility]: never;
                public static PushDisableApiRenderers(): void;
                public static PopDisableApiRenderers(): void;
                public static EmitWorldGeometryForSceneView($cullingCamera: UnityEngine.Camera): void;
                public static EmitGeometryForCamera($camera: UnityEngine.Camera): void;
                public BeginRenderPass($width: number, $height: number, $volumeDepth: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex: number, $shadingRateImageAttachmentIndex: number): void;
                public BeginRenderPass($width: number, $height: number, $volumeDepth: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex?: number): void;
                public BeginRenderPass($width: number, $height: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex: number, $shadingRateImageAttachmentIndex: number): void;
                public BeginRenderPass($width: number, $height: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex?: number): void;
                public BeginScopedRenderPass($width: number, $height: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex: number, $shadingRateImageAttachmentIndex: number): UnityEngine.Rendering.ScopedRenderPass;
                public BeginScopedRenderPass($width: number, $height: number, $samples: number, $attachments: Unity.Collections.NativeArray$1<UnityEngine.Rendering.AttachmentDescriptor>, $depthAttachmentIndex?: number): UnityEngine.Rendering.ScopedRenderPass;
                public BeginSubPass($colors: Unity.Collections.NativeArray$1<number>, $inputs: Unity.Collections.NativeArray$1<number>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean): void;
                public BeginSubPass($colors: Unity.Collections.NativeArray$1<number>, $inputs: Unity.Collections.NativeArray$1<number>, $isDepthStencilReadOnly?: boolean): void;
                public BeginSubPass($colors: Unity.Collections.NativeArray$1<number>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean): void;
                public BeginSubPass($colors: Unity.Collections.NativeArray$1<number>, $isDepthStencilReadOnly?: boolean): void;
                public BeginScopedSubPass($colors: Unity.Collections.NativeArray$1<number>, $inputs: Unity.Collections.NativeArray$1<number>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean): UnityEngine.Rendering.ScopedSubPass;
                public BeginScopedSubPass($colors: Unity.Collections.NativeArray$1<number>, $inputs: Unity.Collections.NativeArray$1<number>, $isDepthStencilReadOnly?: boolean): UnityEngine.Rendering.ScopedSubPass;
                public BeginScopedSubPass($colors: Unity.Collections.NativeArray$1<number>, $isDepthReadOnly: boolean, $isStencilReadOnly: boolean): UnityEngine.Rendering.ScopedSubPass;
                public BeginScopedSubPass($colors: Unity.Collections.NativeArray$1<number>, $isDepthStencilReadOnly?: boolean): UnityEngine.Rendering.ScopedSubPass;
                public EndSubPass(): void;
                public EndRenderPass(): void;
                public Submit(): void;
                public SubmitForRenderPassValidation(): boolean;
                public HasInvokeOnRenderObjectCallbacks(): boolean;
                public DrawRenderers($cullingResults: UnityEngine.Rendering.CullingResults, $drawingSettings: $Ref<UnityEngine.Rendering.DrawingSettings>, $filteringSettings: $Ref<UnityEngine.Rendering.FilteringSettings>): void;
                public DrawRenderers($cullingResults: UnityEngine.Rendering.CullingResults, $drawingSettings: $Ref<UnityEngine.Rendering.DrawingSettings>, $filteringSettings: $Ref<UnityEngine.Rendering.FilteringSettings>, $stateBlock: $Ref<UnityEngine.Rendering.RenderStateBlock>): void;
                public DrawRenderers($cullingResults: UnityEngine.Rendering.CullingResults, $drawingSettings: $Ref<UnityEngine.Rendering.DrawingSettings>, $filteringSettings: $Ref<UnityEngine.Rendering.FilteringSettings>, $renderTypes: Unity.Collections.NativeArray$1<UnityEngine.Rendering.ShaderTagId>, $stateBlocks: Unity.Collections.NativeArray$1<UnityEngine.Rendering.RenderStateBlock>): void;
                public DrawRenderers($cullingResults: UnityEngine.Rendering.CullingResults, $drawingSettings: $Ref<UnityEngine.Rendering.DrawingSettings>, $filteringSettings: $Ref<UnityEngine.Rendering.FilteringSettings>, $tagName: UnityEngine.Rendering.ShaderTagId, $isPassTagName: boolean, $tagValues: Unity.Collections.NativeArray$1<UnityEngine.Rendering.ShaderTagId>, $stateBlocks: Unity.Collections.NativeArray$1<UnityEngine.Rendering.RenderStateBlock>): void;
                public DrawShadows($settings: $Ref<UnityEngine.Rendering.ShadowDrawingSettings>): void;
                public ExecuteCommandBuffer($commandBuffer: UnityEngine.Rendering.CommandBuffer): void;
                public ExecuteCommandBufferAsync($commandBuffer: UnityEngine.Rendering.CommandBuffer, $queueType: UnityEngine.Rendering.ComputeQueueType): void;
                public SetupCameraProperties($camera: UnityEngine.Camera, $stereoSetup?: boolean): void;
                public SetupCameraProperties($camera: UnityEngine.Camera, $stereoSetup: boolean, $eye: number): void;
                public StereoEndRender($camera: UnityEngine.Camera): void;
                public StereoEndRender($camera: UnityEngine.Camera, $eye: number): void;
                public StereoEndRender($camera: UnityEngine.Camera, $eye: number, $isFinalPass: boolean): void;
                public StartMultiEye($camera: UnityEngine.Camera): void;
                public StartMultiEye($camera: UnityEngine.Camera, $eye: number): void;
                public StopMultiEye($camera: UnityEngine.Camera): void;
                public DrawSkybox($camera: UnityEngine.Camera): void;
                public InvokeOnRenderObjectCallback(): void;
                public DrawGizmos($camera: UnityEngine.Camera, $gizmoSubset: UnityEngine.Rendering.GizmoSubset): void;
                public DrawWireOverlay($camera: UnityEngine.Camera): void;
                public DrawUIOverlay($camera: UnityEngine.Camera): void;
                public Cull($parameters: $Ref<UnityEngine.Rendering.ScriptableCullingParameters>): UnityEngine.Rendering.CullingResults;
                public CullShadowCasters($cullingResults: UnityEngine.Rendering.CullingResults, $infos: UnityEngine.Rendering.ShadowCastersCullingInfos): void;
                public Equals($other: UnityEngine.Rendering.ScriptableRenderContext): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
                public CreateRendererList($desc: UnityEngine.Rendering.RendererUtils.RendererListDesc): UnityEngine.Rendering.RendererList;
                public CreateRendererList($param: $Ref<UnityEngine.Rendering.RendererListParams>): UnityEngine.Rendering.RendererList;
                public CreateShadowRendererList($settings: $Ref<UnityEngine.Rendering.ShadowDrawingSettings>): UnityEngine.Rendering.RendererList;
                public CreateSkyboxRendererList($camera: UnityEngine.Camera, $projectionMatrixL: UnityEngine.Matrix4x4, $viewMatrixL: UnityEngine.Matrix4x4, $projectionMatrixR: UnityEngine.Matrix4x4, $viewMatrixR: UnityEngine.Matrix4x4): UnityEngine.Rendering.RendererList;
                public CreateSkyboxRendererList($camera: UnityEngine.Camera, $projectionMatrix: UnityEngine.Matrix4x4, $viewMatrix: UnityEngine.Matrix4x4): UnityEngine.Rendering.RendererList;
                public CreateSkyboxRendererList($camera: UnityEngine.Camera): UnityEngine.Rendering.RendererList;
                public CreateGizmoRendererList($camera: UnityEngine.Camera, $gizmoSubset: UnityEngine.Rendering.GizmoSubset): UnityEngine.Rendering.RendererList;
                public CreateUIOverlayRendererList($camera: UnityEngine.Camera): UnityEngine.Rendering.RendererList;
                public CreateUIOverlayRendererList($camera: UnityEngine.Camera, $uiSubset: UnityEngine.Rendering.UISubset): UnityEngine.Rendering.RendererList;
                public CreateWireOverlayRendererList($camera: UnityEngine.Camera): UnityEngine.Rendering.RendererList;
                public PrepareRendererListsAsync($rendererLists: System.Collections.Generic.List$1<UnityEngine.Rendering.RendererList>): void;
                public QueryRendererListStatus($rendererList: UnityEngine.Rendering.RendererList): UnityEngine.Rendering.RendererListStatus;
            }

            class ShaderTagId implements System.IEquatable$1<UnityEngine.Rendering.ShaderTagId> {
                protected [__keep_incompatibility]: never;
                public static readonly none: UnityEngine.Rendering.ShaderTagId;
                public get name(): string;
                constructor($name: string);
                public Equals($obj: any): boolean;
                public Equals($other: UnityEngine.Rendering.ShaderTagId): boolean;
                public GetHashCode(): number;
            }

            class ShadowDrawingSettings implements System.IEquatable$1<UnityEngine.Rendering.ShadowDrawingSettings> {
                protected [__keep_incompatibility]: never;
                public cullingResults: UnityEngine.Rendering.CullingResults;
                public lightIndex: number;
                public splitIndex: number;
                public useRenderingLayerMaskTest: boolean;
                public batchLayerMask: number;
                public splitData: UnityEngine.Rendering.ShadowSplitData;
                public objectsFilter: UnityEngine.ShadowObjectsFilter;
                public projectionType: UnityEngine.Rendering.BatchCullingProjectionType;
                constructor($cullingResults: UnityEngine.Rendering.CullingResults, $lightIndex: number);
                constructor($cullingResults: UnityEngine.Rendering.CullingResults, $lightIndex: number, $projectionType: UnityEngine.Rendering.BatchCullingProjectionType);
                public Equals($other: UnityEngine.Rendering.ShadowDrawingSettings): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class ShadowSplitData implements System.IEquatable$1<UnityEngine.Rendering.ShadowSplitData> {
                protected [__keep_incompatibility]: never;
                public static readonly maximumCullingPlaneCount: number;
                public cullingPlaneCount: number;
                public cullingSphere: UnityEngine.Vector4;
                public cullingMatrix: UnityEngine.Matrix4x4;
                public cullingNearPlane: number;
                public shadowCascadeBlendCullingFactor: number;
                public GetCullingPlane($index: number): UnityEngine.Plane;
                public SetCullingPlane($index: number, $plane: UnityEngine.Plane): void;
                public Equals($other: UnityEngine.Rendering.ShadowSplitData): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            enum SortingCriteria {
                None = 0,
                SortingLayer = 1,
                RenderQueue = 2,
                BackToFront = 4,
                QuantizedFrontToBack = 8,
                OptimizeStateChanges = 16,
                CommonTransparent = 23,
                CanvasOrder = 32,
                CommonOpaque = 59,
                RendererPriority = 64
            }

            class SortingLayerRange implements System.IEquatable$1<UnityEngine.Rendering.SortingLayerRange> {
                protected [__keep_incompatibility]: never;
                public lowerBound: number;
                public upperBound: number;
                public static get all(): UnityEngine.Rendering.SortingLayerRange;
                constructor($lowerBound: number, $upperBound: number);
                public Equals($other: UnityEngine.Rendering.SortingLayerRange): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            enum DistanceMetric {
                Perspective = 0,
                Orthographic = 1,
                CustomAxis = 2
            }

            class SortingSettings implements System.IEquatable$1<UnityEngine.Rendering.SortingSettings> {
                protected [__keep_incompatibility]: never;
                public worldToCameraMatrix: UnityEngine.Matrix4x4;
                public cameraPosition: UnityEngine.Vector3;
                public customAxis: UnityEngine.Vector3;
                public criteria: UnityEngine.Rendering.SortingCriteria;
                public distanceMetric: UnityEngine.Rendering.DistanceMetric;
                constructor($camera: UnityEngine.Camera);
                public Equals($other: UnityEngine.Rendering.SortingSettings): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class StencilState implements System.IEquatable$1<UnityEngine.Rendering.StencilState> {
                protected [__keep_incompatibility]: never;
                public static get defaultValue(): UnityEngine.Rendering.StencilState;
                public enabled: boolean;
                public readMask: number;
                public writeMask: number;
                public compareFunctionFront: UnityEngine.Rendering.CompareFunction;
                public passOperationFront: UnityEngine.Rendering.StencilOp;
                public failOperationFront: UnityEngine.Rendering.StencilOp;
                public zFailOperationFront: UnityEngine.Rendering.StencilOp;
                public compareFunctionBack: UnityEngine.Rendering.CompareFunction;
                public passOperationBack: UnityEngine.Rendering.StencilOp;
                public failOperationBack: UnityEngine.Rendering.StencilOp;
                public zFailOperationBack: UnityEngine.Rendering.StencilOp;
                constructor($enabled?: boolean, $readMask?: number, $writeMask?: number, $compareFunction?: UnityEngine.Rendering.CompareFunction, $passOperation?: UnityEngine.Rendering.StencilOp, $failOperation?: UnityEngine.Rendering.StencilOp, $zFailOperation?: UnityEngine.Rendering.StencilOp);
                constructor($enabled: boolean, $readMask: number, $writeMask: number, $compareFunctionFront: UnityEngine.Rendering.CompareFunction, $passOperationFront: UnityEngine.Rendering.StencilOp, $failOperationFront: UnityEngine.Rendering.StencilOp, $zFailOperationFront: UnityEngine.Rendering.StencilOp, $compareFunctionBack: UnityEngine.Rendering.CompareFunction, $passOperationBack: UnityEngine.Rendering.StencilOp, $failOperationBack: UnityEngine.Rendering.StencilOp, $zFailOperationBack: UnityEngine.Rendering.StencilOp);
                public SetCompareFunction($value: UnityEngine.Rendering.CompareFunction): void;
                public SetPassOperation($value: UnityEngine.Rendering.StencilOp): void;
                public SetFailOperation($value: UnityEngine.Rendering.StencilOp): void;
                public SetZFailOperation($value: UnityEngine.Rendering.StencilOp): void;
                public Equals($other: UnityEngine.Rendering.StencilState): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class SupportedRenderingFeatures {
                protected [__keep_incompatibility]: never;
                public static active: UnityEngine.Rendering.SupportedRenderingFeatures;
                public reflectionProbeModes: UnityEngine.Rendering.SupportedRenderingFeatures.ReflectionProbeModes;
                public defaultMixedLightingModes: UnityEngine.Rendering.SupportedRenderingFeatures.LightmapMixedBakeModes;
                public mixedLightingModes: UnityEngine.Rendering.SupportedRenderingFeatures.LightmapMixedBakeModes;
                public lightmapBakeTypes: UnityEngine.LightmapBakeType;
                public lightmapsModes: UnityEngine.LightmapsMode;
                public enlighten: boolean;
                public skyOcclusion: boolean;
                public lightProbeProxyVolumes: boolean;
                public motionVectors: boolean;
                public receiveShadows: boolean;
                public reflectionProbes: boolean;
                public reflectionProbesBlendDistance: boolean;
                public rendererPriority: boolean;
                public rendersUIOverlay: boolean;
                public overridesEnvironmentLighting: boolean;
                public overridesFog: boolean;
                public overridesRealtimeReflectionProbes: boolean;
                public overridesOtherLightingSettings: boolean;
                public editableMaterialRenderQueue: boolean;
                public overridesLODBias: boolean;
                public overridesMaximumLODLevel: boolean;
                public overridesEnableLODCrossFade: boolean;
                public rendererProbes: boolean;
                public particleSystemInstancing: boolean;
                public autoAmbientProbeBaking: boolean;
                public autoDefaultReflectionProbeBaking: boolean;
                public ambientProbeBaking: boolean;
                public defaultReflectionProbeBaking: boolean;
                public overridesShadowmask: boolean;
                public overridesLightProbeSystem: boolean;
                public supportsHDR: boolean;
                public supportsClouds: boolean;
                public overridesLightProbeSystemWarningMessage: string;
                public terrainDetailUnsupported: boolean;
                constructor();
            }
            namespace SupportedRenderingFeatures {
                enum ReflectionProbeModes {
                    None = 0,
                    Rotation = 1
                }

                enum LightmapMixedBakeModes {
                    None = 0,
                    IndirectOnly = 1,
                    Subtractive = 2,
                    Shadowmask = 4
                }

            }

            enum UISubset {
                UIToolkit_UGUI = 1,
                LowLevel = 2,
                All = -1
            }

            class VisibleLight implements System.IEquatable$1<UnityEngine.Rendering.VisibleLight> {
                protected [__keep_incompatibility]: never;
                public get light(): UnityEngine.Light;
                public lightType: UnityEngine.LightType;
                public finalColor: UnityEngine.Color;
                public screenRect: UnityEngine.Rect;
                public localToWorldMatrix: UnityEngine.Matrix4x4;
                public range: number;
                public spotAngle: number;
                public innerSpotAngle: number;
                public areaSize: UnityEngine.Vector2;
                public intersectsNearPlane: boolean;
                public intersectsFarPlane: boolean;
                public get forcedVisible(): boolean;
                public Equals($other: UnityEngine.Rendering.VisibleLight): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class VisibleReflectionProbe implements System.IEquatable$1<UnityEngine.Rendering.VisibleReflectionProbe> {
                protected [__keep_incompatibility]: never;
                public get texture(): UnityEngine.Texture;
                public get reflectionProbe(): UnityEngine.ReflectionProbe;
                public bounds: UnityEngine.Bounds;
                public localToWorldMatrix: UnityEngine.Matrix4x4;
                public hdrData: UnityEngine.Vector4;
                public center: UnityEngine.Vector3;
                public blendDistance: number;
                public importance: number;
                public isBoxProjection: boolean;
                public Equals($other: UnityEngine.Rendering.VisibleReflectionProbe): boolean;
                public Equals($obj: any): boolean;
                public GetHashCode(): number;
            }

            class GlobalKeyword {
                protected [__keep_incompatibility]: never;
                public get name(): string;
                constructor($name: string);
                public static Create($name: string): UnityEngine.Rendering.GlobalKeyword;
                public ToString(): string;
            }

            class LocalKeyword implements System.IEquatable$1<UnityEngine.Rendering.LocalKeyword> {
                protected [__keep_incompatibility]: never;
                public get name(): string;
                public get isDynamic(): boolean;
                public get isOverridable(): boolean;
                public get isValid(): boolean;
                public get type(): UnityEngine.Rendering.ShaderKeywordType;
                constructor($shader: UnityEngine.Shader, $name: string);
                constructor($shader: UnityEngine.ComputeShader, $name: string);
                constructor($shader: UnityEngine.Rendering.RayTracingShader, $name: string);
                public ToString(): string;
                public Equals($o: any): boolean;
                public Equals($rhs: UnityEngine.Rendering.LocalKeyword): boolean;
                public GetHashCode(): number;
            }

            class LocalKeywordSpace implements System.IEquatable$1<UnityEngine.Rendering.LocalKeywordSpace> {
                protected [__keep_incompatibility]: never;
                public get keywords(): System.Array$1<UnityEngine.Rendering.LocalKeyword>;
                public get keywordNames(): System.Array$1<string>;
                public get keywordCount(): number;
                public FindKeyword($name: string): UnityEngine.Rendering.LocalKeyword;
                public Equals($o: any): boolean;
                public Equals($rhs: UnityEngine.Rendering.LocalKeywordSpace): boolean;
                public GetHashCode(): number;
            }

            class PassIdentifier implements System.IEquatable$1<UnityEngine.Rendering.PassIdentifier> {
                protected [__keep_incompatibility]: never;
                public get SubshaderIndex(): number;
                public get PassIndex(): number;
                constructor($subshaderIndex: number, $passIndex: number);
                public Equals($o: any): boolean;
                public Equals($rhs: UnityEngine.Rendering.PassIdentifier): boolean;
                public GetHashCode(): number;
            }

            class PlatformKeywordSet {
                protected [__keep_incompatibility]: never;
                public IsEnabled($define: UnityEngine.Rendering.BuiltinShaderDefine): boolean;
                public Enable($define: UnityEngine.Rendering.BuiltinShaderDefine): void;
                public Disable($define: UnityEngine.Rendering.BuiltinShaderDefine): void;
            }

            class RayTracingShader extends UnityEngine.Object {
                protected [__keep_incompatibility]: never;
                public get maxRecursionDepth(): number;
                public get keywordSpace(): UnityEngine.Rendering.LocalKeywordSpace;
                public shaderKeywords: System.Array$1<string>;
                public enabledKeywords: System.Array$1<UnityEngine.Rendering.LocalKeyword>;
                public SetFloat($nameID: number, $val: number): void;
                public SetInt($nameID: number, $val: number): void;
                public SetVector($nameID: number, $val: UnityEngine.Vector4): void;
                public SetMatrix($nameID: number, $val: UnityEngine.Matrix4x4): void;
                public SetVectorArray($nameID: number, $values: System.Array$1<UnityEngine.Vector4>): void;
                public SetMatrixArray($nameID: number, $values: System.Array$1<UnityEngine.Matrix4x4>): void;
                public SetTexture($nameID: number, $texture: UnityEngine.Texture): void;
                public SetBuffer($nameID: number, $buffer: UnityEngine.ComputeBuffer): void;
                public SetAccelerationStructure($nameID: number, $accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure): void;
                public SetShaderPass($passName: string): void;
                public SetTextureFromGlobal($nameID: number, $globalTextureNameID: number): void;
                public Dispatch($rayGenFunctionName: string, $width: number, $height: number, $depth: number, $camera?: UnityEngine.Camera): void;
                public DispatchIndirect($rayGenFunctionName: string, $argsBuffer: UnityEngine.GraphicsBuffer, $argsOffset?: number, $camera?: UnityEngine.Camera): void;
                public SetBuffer($nameID: number, $buffer: UnityEngine.GraphicsBuffer): void;
                public SetBuffer($nameID: number, $bufferHandle: UnityEngine.GraphicsBufferHandle): void;
                public EnableKeyword($keyword: string): void;
                public DisableKeyword($keyword: string): void;
                public IsKeywordEnabled($keyword: string): boolean;
                public EnableKeyword($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): void;
                public DisableKeyword($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): void;
                public SetKeyword($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>, $value: boolean): void;
                public IsKeywordEnabled($keyword: $Ref<UnityEngine.Rendering.LocalKeyword>): boolean;
                public SetFloat($name: string, $val: number): void;
                public SetInt($name: string, $val: number): void;
                public SetVector($name: string, $val: UnityEngine.Vector4): void;
                public SetMatrix($name: string, $val: UnityEngine.Matrix4x4): void;
                public SetVectorArray($name: string, $values: System.Array$1<UnityEngine.Vector4>): void;
                public SetMatrixArray($name: string, $values: System.Array$1<UnityEngine.Matrix4x4>): void;
                public SetFloats($name: string, ...values: number[]): void;
                public SetFloats($nameID: number, ...values: number[]): void;
                public SetInts($name: string, ...values: number[]): void;
                public SetInts($nameID: number, ...values: number[]): void;
                public SetBool($name: string, $val: boolean): void;
                public SetBool($nameID: number, $val: boolean): void;
                public SetTexture($name: string, $texture: UnityEngine.Texture): void;
                public SetBuffer($name: string, $buffer: UnityEngine.ComputeBuffer): void;
                public SetBuffer($name: string, $buffer: UnityEngine.GraphicsBuffer): void;
                public SetBuffer($name: string, $bufferHandle: UnityEngine.GraphicsBufferHandle): void;
                public SetConstantBuffer($nameID: number, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number): void;
                public SetConstantBuffer($name: string, $buffer: UnityEngine.ComputeBuffer, $offset: number, $size: number): void;
                public SetConstantBuffer($nameID: number, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number): void;
                public SetConstantBuffer($name: string, $buffer: UnityEngine.GraphicsBuffer, $offset: number, $size: number): void;
                public SetAccelerationStructure($name: string, $accelerationStructure: UnityEngine.Rendering.RayTracingAccelerationStructure): void;
                public SetTextureFromGlobal($name: string, $globalTextureName: string): void;
            }

            enum ShaderKeywordType {
                None = 0,
                BuiltinDefault = 2,
                BuiltinExtra = 6,
                BuiltinAutoStripped = 10,
                UserDefined = 16,
                Plugin = 32
            }

            class ShaderKeyword {
                protected [__keep_incompatibility]: never;
                public get name(): string;
                public get index(): number;
                constructor($keywordName: string);
                constructor($shader: UnityEngine.Shader, $keywordName: string);
                constructor($shader: UnityEngine.ComputeShader, $keywordName: string);
                public static GetGlobalKeywordType($index: UnityEngine.Rendering.ShaderKeyword): UnityEngine.Rendering.ShaderKeywordType;
                public static IsKeywordLocal($keyword: UnityEngine.Rendering.ShaderKeyword): boolean;
                public IsValid(): boolean;
                public IsValid($shader: UnityEngine.ComputeShader): boolean;
                public IsValid($shader: UnityEngine.Shader): boolean;
                public ToString(): string;
                public static GetKeywordType($shader: UnityEngine.Shader, $index: UnityEngine.Rendering.ShaderKeyword): UnityEngine.Rendering.ShaderKeywordType;
                public static GetKeywordType($shader: UnityEngine.ComputeShader, $index: UnityEngine.Rendering.ShaderKeyword): UnityEngine.Rendering.ShaderKeywordType;
            }

            class ShaderKeywordSet {
                protected [__keep_incompatibility]: never;
                public IsEnabled($keyword: UnityEngine.Rendering.ShaderKeyword): boolean;
                public IsEnabled($keyword: UnityEngine.Rendering.GlobalKeyword): boolean;
                public IsEnabled($keyword: UnityEngine.Rendering.LocalKeyword): boolean;
                public Enable($keyword: UnityEngine.Rendering.ShaderKeyword): void;
                public Disable($keyword: UnityEngine.Rendering.ShaderKeyword): void;
                public GetShaderKeywords(): System.Array$1<UnityEngine.Rendering.ShaderKeyword>;
                public ToString(): string;
            }

            enum ShaderPropertyType {
                Color = 0,
                Vector = 1,
                Float = 2,
                Range = 3,
                Texture = 4,
                Int = 5
            }

            enum ShaderPropertyFlags {
                None = 0,
                HideInInspector = 1,
                PerRendererData = 2,
                NoScaleOffset = 4,
                Normal = 8,
                HDR = 16,
                Gamma = 32,
                NonModifiableTextureData = 64,
                MainTexture = 128,
                MainColor = 256,
                Vector2 = 512,
                Vector3 = 1024
            }

        }
    }
    namespace UnityEngine {
        namespace Rendering {
            namespace RendererUtils {
                class RendererListDesc {
                    protected [__keep_incompatibility]: never;
                    public sortingCriteria: UnityEngine.Rendering.SortingCriteria;
                    public rendererConfiguration: UnityEngine.Rendering.PerObjectData;
                    public renderQueueRange: UnityEngine.Rendering.RenderQueueRange;
                    public stateBlock: UnityEngine.Rendering.RenderStateBlock | null;
                    public overrideShader: UnityEngine.Shader;
                    public overrideMaterial: UnityEngine.Material;
                    public excludeObjectMotionVectors: boolean;
                    public layerMask: number;
                    public renderingLayerMask: number;
                    public overrideMaterialPassIndex: number;
                    public overrideShaderPassIndex: number;
                    public batchLayerMask: number;
                    constructor($passName: UnityEngine.Rendering.ShaderTagId, $cullingResult: UnityEngine.Rendering.CullingResults, $camera: UnityEngine.Camera);
                    constructor($passNames: System.Array$1<UnityEngine.Rendering.ShaderTagId>, $cullingResult: UnityEngine.Rendering.CullingResults, $camera: UnityEngine.Camera);
                    public IsValid(): boolean;
                    public static ConvertToParameters($desc: $Ref<UnityEngine.Rendering.RendererUtils.RendererListDesc>): UnityEngine.Rendering.RendererListParams;
                }

            }
        }
    }
    namespace UnityEngine {
        namespace SceneManagement {
            class Scene {
                protected [__keep_incompatibility]: never;
                public get handle(): UnityEngine.SceneManagement.SceneHandle;
                public get path(): string;
                public name: string;
                public get isLoaded(): boolean;
                public get buildIndex(): number;
                public get isDirty(): boolean;
                public get rootCount(): number;
                public isSubScene: boolean;
                public IsValid(): boolean;
                public GetRootGameObjects(): System.Array$1<UnityEngine.GameObject>;
                public GetRootGameObjects($rootGameObjects: System.Collections.Generic.List$1<UnityEngine.GameObject>): void;
                public GetHashCode(): number;
                public Equals($other: any): boolean;
            }

            class SceneHandle implements System.IEquatable$1<UnityEngine.SceneManagement.SceneHandle> {
                protected [__keep_incompatibility]: never;
                public static get None(): UnityEngine.SceneManagement.SceneHandle;
                public Equals($obj: any): boolean;
                public Equals($other: UnityEngine.SceneManagement.SceneHandle): boolean;
                public GetHashCode(): number;
                public ToString(): string;
                public ToString($format: string): string;
            }

            class SceneManagerAPI {
                protected [__keep_incompatibility]: never;
                public static overrideAPI: UnityEngine.SceneManagement.SceneManagerAPI;
            }

            class SceneManager {
                protected [__keep_incompatibility]: never;
                public static get sceneCount(): number;
                public static get loadedSceneCount(): number;
                public static get sceneCountInBuildSettings(): number;
                constructor();
                public static GetActiveScene(): UnityEngine.SceneManagement.Scene;
                public static SetActiveScene($scene: UnityEngine.SceneManagement.Scene): boolean;
                public static GetSceneByPath($scenePath: string): UnityEngine.SceneManagement.Scene;
                public static GetSceneByName($name: string): UnityEngine.SceneManagement.Scene;
                public static GetSceneByBuildIndex($buildIndex: number): UnityEngine.SceneManagement.Scene;
                public static GetSceneAt($index: number): UnityEngine.SceneManagement.Scene;
                public static CreateScene($sceneName: string, $parameters: UnityEngine.SceneManagement.CreateSceneParameters): UnityEngine.SceneManagement.Scene;
                public static MergeScenes($sourceScene: UnityEngine.SceneManagement.Scene, $destinationScene: UnityEngine.SceneManagement.Scene): void;
                public static MoveGameObjectToScene($go: UnityEngine.GameObject, $scene: UnityEngine.SceneManagement.Scene): void;
                public static MoveGameObjectsToScene($instanceIDs: Unity.Collections.NativeArray$1<number>, $scene: UnityEngine.SceneManagement.Scene): void;
                public static MoveGameObjectsToScene($entityIds: Unity.Collections.NativeArray$1<UnityEngine.EntityId>, $scene: UnityEngine.SceneManagement.Scene): void;
                public static GetAllScenes(): System.Array$1<UnityEngine.SceneManagement.Scene>;
                public static CreateScene($sceneName: string): UnityEngine.SceneManagement.Scene;
                public static LoadScene($sceneName: string, $mode: UnityEngine.SceneManagement.LoadSceneMode): void;
                public static LoadScene($sceneName: string): void;
                public static LoadScene($sceneName: string, $parameters: UnityEngine.SceneManagement.LoadSceneParameters): UnityEngine.SceneManagement.Scene;
                public static LoadScene($sceneBuildIndex: number, $mode: UnityEngine.SceneManagement.LoadSceneMode): void;
                public static LoadScene($sceneBuildIndex: number): void;
                public static LoadScene($sceneBuildIndex: number, $parameters: UnityEngine.SceneManagement.LoadSceneParameters): UnityEngine.SceneManagement.Scene;
                public static LoadSceneAsync($sceneBuildIndex: number, $mode: UnityEngine.SceneManagement.LoadSceneMode): UnityEngine.AsyncOperation;
                public static LoadSceneAsync($sceneBuildIndex: number): UnityEngine.AsyncOperation;
                public static LoadSceneAsync($sceneBuildIndex: number, $parameters: UnityEngine.SceneManagement.LoadSceneParameters): UnityEngine.AsyncOperation;
                public static LoadSceneAsync($sceneName: string, $mode: UnityEngine.SceneManagement.LoadSceneMode): UnityEngine.AsyncOperation;
                public static LoadSceneAsync($sceneName: string): UnityEngine.AsyncOperation;
                public static LoadSceneAsync($sceneName: string, $parameters: UnityEngine.SceneManagement.LoadSceneParameters): UnityEngine.AsyncOperation;
                public static UnloadScene($scene: UnityEngine.SceneManagement.Scene): boolean;
                public static UnloadScene($sceneBuildIndex: number): boolean;
                public static UnloadScene($sceneName: string): boolean;
                public static UnloadSceneAsync($sceneBuildIndex: number): UnityEngine.AsyncOperation;
                public static UnloadSceneAsync($sceneName: string): UnityEngine.AsyncOperation;
                public static UnloadSceneAsync($scene: UnityEngine.SceneManagement.Scene): UnityEngine.AsyncOperation;
                public static UnloadSceneAsync($sceneBuildIndex: number, $options: UnityEngine.SceneManagement.UnloadSceneOptions): UnityEngine.AsyncOperation;
                public static UnloadSceneAsync($sceneName: string, $options: UnityEngine.SceneManagement.UnloadSceneOptions): UnityEngine.AsyncOperation;
                public static UnloadSceneAsync($scene: UnityEngine.SceneManagement.Scene, $options: UnityEngine.SceneManagement.UnloadSceneOptions): UnityEngine.AsyncOperation;
                public static add_sceneLoaded(handler: UnityEngine.Events.UnityAction$2<UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.LoadSceneMode>): void;
                public static remove_sceneLoaded(handler: UnityEngine.Events.UnityAction$2<UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.LoadSceneMode>): void;
                public static add_sceneUnloaded(handler: UnityEngine.Events.UnityAction$1<UnityEngine.SceneManagement.Scene>): void;
                public static remove_sceneUnloaded(handler: UnityEngine.Events.UnityAction$1<UnityEngine.SceneManagement.Scene>): void;
                public static add_activeSceneChanged(handler: UnityEngine.Events.UnityAction$2<UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.Scene>): void;
                public static remove_activeSceneChanged(handler: UnityEngine.Events.UnityAction$2<UnityEngine.SceneManagement.Scene, UnityEngine.SceneManagement.Scene>): void;
            }

            enum LoadSceneMode {
                Single = 0,
                Additive = 1
            }

            enum LocalPhysicsMode {
                None = 0,
                Physics2D = 1,
                Physics3D = 2
            }

            class LoadSceneParameters {
                protected [__keep_incompatibility]: never;
                public loadSceneMode: UnityEngine.SceneManagement.LoadSceneMode;
                public localPhysicsMode: UnityEngine.SceneManagement.LocalPhysicsMode;
                constructor($mode: UnityEngine.SceneManagement.LoadSceneMode);
                constructor($mode: UnityEngine.SceneManagement.LoadSceneMode, $physicsMode: UnityEngine.SceneManagement.LocalPhysicsMode);
            }

            class CreateSceneParameters {
                protected [__keep_incompatibility]: never;
                public localPhysicsMode: UnityEngine.SceneManagement.LocalPhysicsMode;
                constructor($physicsMode: UnityEngine.SceneManagement.LocalPhysicsMode);
            }

            enum UnloadSceneOptions {
                None = 0,
                UnloadAllEmbeddedSceneObjects = 1
            }

            class SceneUtility {
                protected [__keep_incompatibility]: never;
                public static GetScenePathByBuildIndex($buildIndex: number): string;
                public static GetBuildIndexByScenePath($scenePath: string): number;
            }

        }
    }
    namespace UnityEngine {
        namespace Scripting {
            class AlwaysLinkAssemblyAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class GarbageCollector {
                protected [__keep_incompatibility]: never;
                public static GCMode: UnityEngine.Scripting.GarbageCollector.Mode;
                public static get isIncremental(): boolean;
                public static incrementalTimeSliceNanoseconds: bigint;
                public static CollectIncremental($nanoseconds?: bigint): boolean;
                public static add_GCModeChanged(handler: System.Action$1<UnityEngine.Scripting.GarbageCollector.Mode>): void;
                public static remove_GCModeChanged(handler: System.Action$1<UnityEngine.Scripting.GarbageCollector.Mode>): void;
            }
            namespace GarbageCollector {
                enum Mode {
                    Disabled = 0,
                    Enabled = 1,
                    Manual = 2
                }

            }

            class PreserveAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class RequireAttributeUsagesAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class RequireDerivedAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class RequiredInterfaceAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor($interfaceType: System.Type);
            }

            class RequiredMemberAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class RequireImplementorsAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

        }
    }
    namespace UnityEngine {
        namespace Scripting {
            namespace APIUpdating {
                class MovedFromAttribute extends System.Attribute {
                    protected [__keep_incompatibility]: never;
                    public get IsInDifferentAssembly(): boolean;
                    constructor($autoUpdateAPI: boolean, $sourceNamespace?: string, $sourceAssembly?: string, $sourceClassName?: string);
                    constructor($sourceNamespace: string);
                }

            }
        }
    }
    namespace UnityEngine {
        namespace Search {
            enum SearchViewFlags {
                None = 0,
                Debug = 16,
                NoIndexing = 32,
                Packages = 256,
                OpenLeftSidePanel = 2048,
                OpenInspectorPreview = 4096,
                Centered = 8192,
                HideSearchBar = 16384,
                CompactView = 32768,
                ListView = 65536,
                GridView = 131072,
                TableView = 262144,
                EnableSearchQuery = 524288,
                DisableInspectorPreview = 1048576,
                DisableSavedSearchQuery = 2097152,
                OpenInBuilderMode = 4194304,
                OpenInTextMode = 8388608,
                DisableBuilderModeToggle = 16777216,
                Borderless = 33554432,
                ContextSwitchPreservedMask = 33560576,
                DisableQueryHelpers = 67108864,
                DisableNoResultTips = 134217728,
                IgnoreSavedSearches = 268435456,
                ObjectPicker = 536870912,
                ObjectPickerAdvancedUI = 1073741824
            }

            class SearchContextAttribute extends UnityEngine.PropertyAttribute {
                protected [__keep_incompatibility]: never;
                public get query(): string;
                public get providerIds(): System.Array$1<string>;
                public get instantiableProviders(): System.Array$1<System.Type>;
                public get flags(): UnityEngine.Search.SearchViewFlags;
                constructor($query: string);
                constructor($query: string, $flags: UnityEngine.Search.SearchViewFlags);
                constructor($query: string, $providerIdsCommaSeparated: string);
                constructor($query: string, $providerIdsCommaSeparated: string, $flags: UnityEngine.Search.SearchViewFlags);
                constructor($query: string, ...instantiableProviders: System.Type[]);
                constructor($query: string, $flags: UnityEngine.Search.SearchViewFlags, ...instantiableProviders: System.Type[]);
                constructor($query: string, $flags: UnityEngine.Search.SearchViewFlags, $providerIdsCommaSeparated: string, ...instantiableProviders: System.Type[]);
            }

        }
    }
    namespace UnityEngine {
        namespace SearchService {
            class ObjectSelectorHandlerWithLabelsAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get labels(): System.Array$1<string>;
                public get matchAll(): boolean;
                constructor(...labels: string[]);
                constructor($matchAll: boolean, ...labels: string[]);
            }

            class ObjectSelectorHandlerWithTagsAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get tags(): System.Array$1<string>;
                constructor(...tags: string[]);
            }

        }
    }
    namespace UnityEngine {
        namespace Serialization {
            class FormerlySerializedAsAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                public get oldName(): string;
                constructor($oldName: string);
            }

            class ManagedReferenceUtility {
                protected [__keep_incompatibility]: never;
                public static readonly RefIdUnknown: bigint;
                public static readonly RefIdNull: bigint;
                constructor();
                public static SetManagedReferenceIdForObject($obj: UnityEngine.Object, $scriptObj: any, $refId: bigint): boolean;
                public static GetManagedReferenceIdForObject($obj: UnityEngine.Object, $scriptObj: any): bigint;
                public static GetManagedReference($obj: UnityEngine.Object, $id: bigint): any;
                public static GetManagedReferenceIds($obj: UnityEngine.Object): System.Array$1<bigint>;
            }

            class UnitySurrogateSelector implements System.Runtime.Serialization.ISurrogateSelector {
                protected [__keep_incompatibility]: never;
                constructor();
                public GetSurrogate($type: System.Type, $context: System.Runtime.Serialization.StreamingContext, $selector: $Out<System.Runtime.Serialization.ISurrogateSelector>): System.Runtime.Serialization.ISerializationSurrogate;
                public ChainSelector($selector: System.Runtime.Serialization.ISurrogateSelector): void;
                public GetNextSelector(): System.Runtime.Serialization.ISurrogateSelector;
            }

        }
    }
    namespace UnityEngine {
        namespace Sprites {
            class DataUtility {
                protected [__keep_incompatibility]: never;
                constructor();
                public static GetInnerUV($sprite: UnityEngine.Sprite): UnityEngine.Vector4;
                public static GetOuterUV($sprite: UnityEngine.Sprite): UnityEngine.Vector4;
                public static GetPadding($sprite: UnityEngine.Sprite): UnityEngine.Vector4;
                public static GetMinSize($sprite: UnityEngine.Sprite): UnityEngine.Vector2;
            }

        }
    }
    namespace UnityEngine {
        namespace TestTools {
            class ExcludeFromCoverageAttribute extends System.Attribute {
                protected [__keep_incompatibility]: never;
                constructor();
            }

            class CoveredSequencePoint {
                protected [__keep_incompatibility]: never;
                public method: System.Reflection.MethodBase;
                public ilOffset: number;
                public hitCount: number;
                public filename: string;
                public line: number;
                public column: number;
            }

            class CoveredMethodStats {
                protected [__keep_incompatibility]: never;
                public method: System.Reflection.MethodBase;
                public totalSequencePoints: number;
                public uncoveredSequencePoints: number;
                public ToString(): string;
            }

            class Coverage {
                protected [__keep_incompatibility]: never;
                public static enabled: boolean;
                public static GetSequencePointsFor($method: System.Reflection.MethodBase): System.Array$1<UnityEngine.TestTools.CoveredSequencePoint>;
                public static GetStatsFor($method: System.Reflection.MethodBase): UnityEngine.TestTools.CoveredMethodStats;
                public static GetStatsFor($methods: System.Array$1<System.Reflection.MethodBase>): System.Array$1<UnityEngine.TestTools.CoveredMethodStats>;
                public static GetStatsFor($type: System.Type): System.Array$1<UnityEngine.TestTools.CoveredMethodStats>;
                public static GetStatsForAllCoveredMethods(): System.Array$1<UnityEngine.TestTools.CoveredMethodStats>;
                public static ResetFor($method: System.Reflection.MethodBase): void;
                public static ResetAll(): void;
            }

        }
    }
    namespace UnityEngine {
        namespace tvOS {
            class Remote {
                protected [__keep_incompatibility]: never;
                public static allowExitToHome: boolean;
                public static allowRemoteRotation: boolean;
                public static reportAbsoluteDpadValues: boolean;
                public static touchesEnabled: boolean;
                constructor();
            }

            enum DeviceGeneration {
                Unknown = 0,
                AppleTV1Gen = 1001,
                AppleTVHD = 1001,
                AppleTV2Gen = 1002,
                AppleTV4K = 1002,
                AppleTV4K2Gen = 1003,
                AppleTV4K3Gen = 1004
            }

            class Device {
                protected [__keep_incompatibility]: never;
                public static get systemVersion(): string;
                public static get generation(): UnityEngine.tvOS.DeviceGeneration;
                public static get vendorIdentifier(): string;
                public static get advertisingTrackingEnabled(): boolean;
                public static get advertisingIdentifier(): string;
                public static get runsOnSimulator(): boolean;
                constructor();
                public static SetNoBackupFlag($path: string): void;
                public static ResetNoBackupFlag($path: string): void;
            }

        }
    }
    namespace UnityEngine {
        namespace U2D {
            class Light2DBase extends UnityEngine.MonoBehaviour {
                protected [__keep_incompatibility]: never;
            }

            class PixelPerfectRendering {
                protected [__keep_incompatibility]: never;
                public static pixelSnapSpacing: number;
            }

            class SpriteBone {
                protected [__keep_incompatibility]: never;
                public name: string;
                public guid: string;
                public position: UnityEngine.Vector3;
                public rotation: UnityEngine.Quaternion;
                public length: number;
                public parentId: number;
                public color: UnityEngine.Color32;
            }

            class SpriteDataAccessExtensions {
                protected [__keep_incompatibility]: never;
                public static GetVertexAttribute<T>($channel: UnityEngine.Rendering.VertexAttribute): Unity.Collections.NativeSlice$1<T>;
                public static SetVertexAttribute<T>($channel: UnityEngine.Rendering.VertexAttribute, $src: Unity.Collections.NativeArray$1<T>): void;
                public static GetBindPoses(): Unity.Collections.NativeArray$1<UnityEngine.Matrix4x4>;
                public static SetBindPoses($src: Unity.Collections.NativeArray$1<UnityEngine.Matrix4x4>): void;
                public static GetIndices(): Unity.Collections.NativeArray$1<number>;
                public static SetIndices($src: Unity.Collections.NativeArray$1<number>): void;
                public static GetBones(): System.Array$1<UnityEngine.U2D.SpriteBone>;
                public static SetBones($src: System.Array$1<UnityEngine.U2D.SpriteBone>): void;
                public static HasVertexAttribute($channel: UnityEngine.Rendering.VertexAttribute): boolean;
                public static SetVertexCount($count: number): void;
                public static GetVertexCount(): number;
            }

            class SpriteRendererDataAccessExtensions {
                protected [__keep_incompatibility]: never;
                public static DeactivateDeformableBuffer(): void;
            }

            class SpriteAtlasManager {
                protected [__keep_incompatibility]: never;
                constructor();
                public static add_atlasRequested(handler: System.Action$2<string, System.Action$1<UnityEngine.U2D.SpriteAtlas>>): void;
                public static remove_atlasRequested(handler: System.Action$2<string, System.Action$1<UnityEngine.U2D.SpriteAtlas>>): void;
                public static add_atlasRegistered(handler: System.Action$1<UnityEngine.U2D.SpriteAtlas>): void;
                public static remove_atlasRegistered(handler: System.Action$1<UnityEngine.U2D.SpriteAtlas>): void;
            }

            class SpriteAtlas extends UnityEngine.Object {
                protected [__keep_incompatibility]: never;
                public get isVariant(): boolean;
                public get tag(): string;
                public get spriteCount(): number;
                constructor();
                public CanBindTo($sprite: UnityEngine.Sprite): boolean;
                public GetSprite($name: string): UnityEngine.Sprite;
                public GetSprites($sprites: System.Array$1<UnityEngine.Sprite>): number;
                public GetSprites($sprites: System.Array$1<UnityEngine.Sprite>, $name: string): number;
            }

        }
    }
    namespace UnityEngine {
        namespace Windows {
            class LicenseInformation {
                protected [__keep_incompatibility]: never;
                public static get isOnAppTrial(): boolean;
                public static PurchaseApp(): string;
            }

            class CrashReporting {
                protected [__keep_incompatibility]: never;
                public static get crashReportFolder(): string;
            }

            class Crypto {
                protected [__keep_incompatibility]: never;
                public static ComputeMD5Hash($buffer: System.Array$1<number>): System.Array$1<number>;
                public static ComputeSHA1Hash($buffer: System.Array$1<number>): System.Array$1<number>;
            }

            class Directory {
                protected [__keep_incompatibility]: never;
                public static get temporaryFolder(): string;
                public static get localFolder(): string;
                public static get roamingFolder(): string;
                public static CreateDirectory($path: string): void;
                public static Exists($path: string): boolean;
                public static Delete($path: string): void;
            }

            class File {
                protected [__keep_incompatibility]: never;
                public static ReadAllBytes($path: string): System.Array$1<number>;
                public static WriteAllBytes($path: string, $bytes: System.Array$1<number>): void;
                public static Exists($path: string): boolean;
                public static Delete($path: string): void;
            }

            class Input {
                protected [__keep_incompatibility]: never;
                public static ForwardRawInput($rawInputHeaderIndices: number, $rawInputDataIndices: number, $indicesCount: number, $rawInputData: number, $rawInputDataSize: number): void;
            }

        }
    }
    namespace UnityEngine {
        namespace Windows {
            namespace Speech {
                class PhraseRecognitionSystem {
                    protected [__keep_incompatibility]: never;
                    public static get isSupported(): boolean;
                    public static get Status(): UnityEngine.Windows.Speech.SpeechSystemStatus;
                    public static Restart(): void;
                    public static Shutdown(): void;
                    public static add_OnError(handler: UnityEngine.Windows.Speech.PhraseRecognitionSystem.ErrorDelegate): void;
                    public static remove_OnError(handler: UnityEngine.Windows.Speech.PhraseRecognitionSystem.ErrorDelegate): void;
                    public static add_OnStatusChanged(handler: UnityEngine.Windows.Speech.PhraseRecognitionSystem.StatusDelegate): void;
                    public static remove_OnStatusChanged(handler: UnityEngine.Windows.Speech.PhraseRecognitionSystem.StatusDelegate): void;
                }
                namespace PhraseRecognitionSystem {
                    interface ErrorDelegate {
                        ($errorCode: UnityEngine.Windows.Speech.SpeechError): void;
                        Invoke?: ($errorCode: UnityEngine.Windows.Speech.SpeechError) => void;
                    }
                    var ErrorDelegate: { new (func: ($errorCode: UnityEngine.Windows.Speech.SpeechError) => void): ErrorDelegate; };

                    interface StatusDelegate {
                        ($status: UnityEngine.Windows.Speech.SpeechSystemStatus): void;
                        Invoke?: ($status: UnityEngine.Windows.Speech.SpeechSystemStatus) => void;
                    }
                    var StatusDelegate: { new (func: ($status: UnityEngine.Windows.Speech.SpeechSystemStatus) => void): StatusDelegate; };

                }

                class PhraseRecognizer implements System.IDisposable {
                    protected [__keep_incompatibility]: never;
                    public get IsRunning(): boolean;
                    public Start(): void;
                    public Stop(): void;
                    public Dispose(): void;
                    public add_OnPhraseRecognized(handler: UnityEngine.Windows.Speech.PhraseRecognizer.PhraseRecognizedDelegate): void;
                    public remove_OnPhraseRecognized(handler: UnityEngine.Windows.Speech.PhraseRecognizer.PhraseRecognizedDelegate): void;
                }
                namespace PhraseRecognizer {
                    interface PhraseRecognizedDelegate {
                        ($args: UnityEngine.Windows.Speech.PhraseRecognizedEventArgs): void;
                        Invoke?: ($args: UnityEngine.Windows.Speech.PhraseRecognizedEventArgs) => void;
                    }
                    var PhraseRecognizedDelegate: { new (func: ($args: UnityEngine.Windows.Speech.PhraseRecognizedEventArgs) => void): PhraseRecognizedDelegate; };

                }

                class DictationRecognizer implements System.IDisposable {
                    protected [__keep_incompatibility]: never;
                    public get Status(): UnityEngine.Windows.Speech.SpeechSystemStatus;
                    public AutoSilenceTimeoutSeconds: number;
                    public InitialSilenceTimeoutSeconds: number;
                    constructor();
                    constructor($confidenceLevel: UnityEngine.Windows.Speech.ConfidenceLevel);
                    constructor($topic: UnityEngine.Windows.Speech.DictationTopicConstraint);
                    constructor($minimumConfidence: UnityEngine.Windows.Speech.ConfidenceLevel, $topic: UnityEngine.Windows.Speech.DictationTopicConstraint);
                    public Start(): void;
                    public Stop(): void;
                    public Dispose(): void;
                    public add_DictationHypothesis(handler: UnityEngine.Windows.Speech.DictationRecognizer.DictationHypothesisDelegate): void;
                    public remove_DictationHypothesis(handler: UnityEngine.Windows.Speech.DictationRecognizer.DictationHypothesisDelegate): void;
                    public add_DictationResult(handler: UnityEngine.Windows.Speech.DictationRecognizer.DictationResultDelegate): void;
                    public remove_DictationResult(handler: UnityEngine.Windows.Speech.DictationRecognizer.DictationResultDelegate): void;
                    public add_DictationComplete(handler: UnityEngine.Windows.Speech.DictationRecognizer.DictationCompletedDelegate): void;
                    public remove_DictationComplete(handler: UnityEngine.Windows.Speech.DictationRecognizer.DictationCompletedDelegate): void;
                    public add_DictationError(handler: UnityEngine.Windows.Speech.DictationRecognizer.DictationErrorHandler): void;
                    public remove_DictationError(handler: UnityEngine.Windows.Speech.DictationRecognizer.DictationErrorHandler): void;
                }
                namespace DictationRecognizer {
                    interface DictationHypothesisDelegate {
                        ($text: string): void;
                        Invoke?: ($text: string) => void;
                    }
                    var DictationHypothesisDelegate: { new (func: ($text: string) => void): DictationHypothesisDelegate; };

                    interface DictationResultDelegate {
                        ($text: string, $confidence: UnityEngine.Windows.Speech.ConfidenceLevel): void;
                        Invoke?: ($text: string, $confidence: UnityEngine.Windows.Speech.ConfidenceLevel) => void;
                    }
                    var DictationResultDelegate: { new (func: ($text: string, $confidence: UnityEngine.Windows.Speech.ConfidenceLevel) => void): DictationResultDelegate; };

                    interface DictationCompletedDelegate {
                        ($cause: UnityEngine.Windows.Speech.DictationCompletionCause): void;
                        Invoke?: ($cause: UnityEngine.Windows.Speech.DictationCompletionCause) => void;
                    }
                    var DictationCompletedDelegate: { new (func: ($cause: UnityEngine.Windows.Speech.DictationCompletionCause) => void): DictationCompletedDelegate; };

                    interface DictationErrorHandler {
                        ($error: string, $hresult: number): void;
                        Invoke?: ($error: string, $hresult: number) => void;
                    }
                    var DictationErrorHandler: { new (func: ($error: string, $hresult: number) => void): DictationErrorHandler; };

                }

                enum ConfidenceLevel {
                    High = 0,
                    Medium = 1,
                    Low = 2,
                    Rejected = 3
                }

                enum SpeechSystemStatus {
                    Stopped = 0,
                    Running = 1,
                    Failed = 2
                }

                enum SpeechError {
                    NoError = 0,
                    TopicLanguageNotSupported = 1,
                    GrammarLanguageMismatch = 2,
                    GrammarCompilationFailure = 3,
                    AudioQualityFailure = 4,
                    PauseLimitExceeded = 5,
                    TimeoutExceeded = 6,
                    NetworkFailure = 7,
                    MicrophoneUnavailable = 8,
                    UnknownError = 9
                }

                enum DictationTopicConstraint {
                    WebSearch = 0,
                    Form = 1,
                    Dictation = 2
                }

                enum DictationCompletionCause {
                    Complete = 0,
                    AudioQualityFailure = 1,
                    Canceled = 2,
                    TimeoutExceeded = 3,
                    PauseLimitExceeded = 4,
                    NetworkFailure = 5,
                    MicrophoneUnavailable = 6,
                    UnknownError = 7
                }

                class SemanticMeaning {
                    protected [__keep_incompatibility]: never;
                    public key: string;
                    public values: System.Array$1<string>;
                }

                class PhraseRecognizedEventArgs {
                    protected [__keep_incompatibility]: never;
                    public readonly confidence: UnityEngine.Windows.Speech.ConfidenceLevel;
                    public readonly semanticMeanings: System.Array$1<UnityEngine.Windows.Speech.SemanticMeaning>;
                    public readonly text: string;
                    public readonly phraseStartTime: System.DateTime;
                    public readonly phraseDuration: System.TimeSpan;
                }

                class KeywordRecognizer extends UnityEngine.Windows.Speech.PhraseRecognizer {
                    protected [__keep_incompatibility]: never;
                    public get Keywords(): System.Collections.Generic.IEnumerable$1<string>;
                    constructor($keywords: System.Array$1<string>);
                    constructor($keywords: System.Array$1<string>, $minimumConfidence: UnityEngine.Windows.Speech.ConfidenceLevel);
                }

                class GrammarRecognizer extends UnityEngine.Windows.Speech.PhraseRecognizer {
                    protected [__keep_incompatibility]: never;
                    public get GrammarFilePath(): string;
                    constructor($grammarFilePath: string);
                    constructor($grammarFilePath: string, $minimumConfidence: UnityEngine.Windows.Speech.ConfidenceLevel);
                }

            }
        }
    }
    namespace UnityEngine {
        namespace Windows {
            namespace WebCam {
                enum PhotoCaptureFileOutputFormat {
                    PNG = 0,
                    JPG = 1
                }

                class PhotoCapture implements System.IDisposable {
                    protected [__keep_incompatibility]: never;
                    public static get SupportedResolutions(): System.Collections.Generic.IEnumerable$1<UnityEngine.Resolution>;
                    public static CreateAsync($showHolograms: boolean, $onCreatedCallback: UnityEngine.Windows.WebCam.PhotoCapture.OnCaptureResourceCreatedCallback): void;
                    public static CreateAsync($onCreatedCallback: UnityEngine.Windows.WebCam.PhotoCapture.OnCaptureResourceCreatedCallback): void;
                    public StartPhotoModeAsync($setupParams: UnityEngine.Windows.WebCam.CameraParameters, $onPhotoModeStartedCallback: UnityEngine.Windows.WebCam.PhotoCapture.OnPhotoModeStartedCallback): void;
                    public StopPhotoModeAsync($onPhotoModeStoppedCallback: UnityEngine.Windows.WebCam.PhotoCapture.OnPhotoModeStoppedCallback): void;
                    public TakePhotoAsync($filename: string, $fileOutputFormat: UnityEngine.Windows.WebCam.PhotoCaptureFileOutputFormat, $onCapturedPhotoToDiskCallback: UnityEngine.Windows.WebCam.PhotoCapture.OnCapturedToDiskCallback): void;
                    public TakePhotoAsync($onCapturedPhotoToMemoryCallback: UnityEngine.Windows.WebCam.PhotoCapture.OnCapturedToMemoryCallback): void;
                    public GetUnsafePointerToVideoDeviceController(): number;
                    public Dispose(): void;
                }
                namespace PhotoCapture {
                    enum CaptureResultType {
                        Success = 0,
                        UnknownError = 1
                    }

                    class PhotoCaptureResult {
                        protected [__keep_incompatibility]: never;
                        public resultType: UnityEngine.Windows.WebCam.PhotoCapture.CaptureResultType;
                        public hResult: bigint;
                        public get success(): boolean;
                    }

                    interface OnCaptureResourceCreatedCallback {
                        ($captureObject: UnityEngine.Windows.WebCam.PhotoCapture): void;
                        Invoke?: ($captureObject: UnityEngine.Windows.WebCam.PhotoCapture) => void;
                    }
                    var OnCaptureResourceCreatedCallback: { new (func: ($captureObject: UnityEngine.Windows.WebCam.PhotoCapture) => void): OnCaptureResourceCreatedCallback; };

                    interface OnPhotoModeStartedCallback {
                        ($result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult): void;
                        Invoke?: ($result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) => void;
                    }
                    var OnPhotoModeStartedCallback: { new (func: ($result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) => void): OnPhotoModeStartedCallback; };

                    interface OnPhotoModeStoppedCallback {
                        ($result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult): void;
                        Invoke?: ($result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) => void;
                    }
                    var OnPhotoModeStoppedCallback: { new (func: ($result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) => void): OnPhotoModeStoppedCallback; };

                    interface OnCapturedToDiskCallback {
                        ($result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult): void;
                        Invoke?: ($result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) => void;
                    }
                    var OnCapturedToDiskCallback: { new (func: ($result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult) => void): OnCapturedToDiskCallback; };

                    interface OnCapturedToMemoryCallback {
                        ($result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult, $photoCaptureFrame: UnityEngine.Windows.WebCam.PhotoCaptureFrame): void;
                        Invoke?: ($result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult, $photoCaptureFrame: UnityEngine.Windows.WebCam.PhotoCaptureFrame) => void;
                    }
                    var OnCapturedToMemoryCallback: { new (func: ($result: UnityEngine.Windows.WebCam.PhotoCapture.PhotoCaptureResult, $photoCaptureFrame: UnityEngine.Windows.WebCam.PhotoCaptureFrame) => void): OnCapturedToMemoryCallback; };

                }

                class PhotoCaptureFrame implements System.IDisposable {
                    protected [__keep_incompatibility]: never;
                    public get dataLength(): number;
                    public get hasLocationData(): boolean;
                    public get pixelFormat(): UnityEngine.Windows.WebCam.CapturePixelFormat;
                    public TryGetCameraToWorldMatrix($cameraToWorldMatrix: $Out<UnityEngine.Matrix4x4>): boolean;
                    public TryGetProjectionMatrix($projectionMatrix: $Out<UnityEngine.Matrix4x4>): boolean;
                    public TryGetProjectionMatrix($nearClipPlane: number, $farClipPlane: number, $projectionMatrix: $Out<UnityEngine.Matrix4x4>): boolean;
                    public UploadImageDataToTexture($targetTexture: UnityEngine.Texture2D): void;
                    public GetUnsafePointerToBuffer(): number;
                    public CopyRawImageDataIntoBuffer($byteBuffer: System.Collections.Generic.List$1<number>): void;
                    public Dispose(): void;
                }

                class VideoCapture implements System.IDisposable {
                    protected [__keep_incompatibility]: never;
                    public static get SupportedResolutions(): System.Collections.Generic.IEnumerable$1<UnityEngine.Resolution>;
                    public get IsRecording(): boolean;
                    public static GetSupportedFrameRatesForResolution($resolution: UnityEngine.Resolution): System.Collections.Generic.IEnumerable$1<number>;
                    public static CreateAsync($showHolograms: boolean, $onCreatedCallback: UnityEngine.Windows.WebCam.VideoCapture.OnVideoCaptureResourceCreatedCallback): void;
                    public static CreateAsync($onCreatedCallback: UnityEngine.Windows.WebCam.VideoCapture.OnVideoCaptureResourceCreatedCallback): void;
                    public StartVideoModeAsync($setupParams: UnityEngine.Windows.WebCam.CameraParameters, $audioState: UnityEngine.Windows.WebCam.VideoCapture.AudioState, $onVideoModeStartedCallback: UnityEngine.Windows.WebCam.VideoCapture.OnVideoModeStartedCallback): void;
                    public StopVideoModeAsync($onVideoModeStoppedCallback: UnityEngine.Windows.WebCam.VideoCapture.OnVideoModeStoppedCallback): void;
                    public StartRecordingAsync($filename: string, $onStartedRecordingVideoCallback: UnityEngine.Windows.WebCam.VideoCapture.OnStartedRecordingVideoCallback): void;
                    public StopRecordingAsync($onStoppedRecordingVideoCallback: UnityEngine.Windows.WebCam.VideoCapture.OnStoppedRecordingVideoCallback): void;
                    public GetUnsafePointerToVideoDeviceController(): number;
                    public Dispose(): void;
                }
                namespace VideoCapture {
                    enum CaptureResultType {
                        Success = 0,
                        UnknownError = 1
                    }

                    enum AudioState {
                        MicAudio = 0,
                        ApplicationAudio = 1,
                        ApplicationAndMicAudio = 2,
                        None = 3
                    }

                    class VideoCaptureResult {
                        protected [__keep_incompatibility]: never;
                        public resultType: UnityEngine.Windows.WebCam.VideoCapture.CaptureResultType;
                        public hResult: bigint;
                        public get success(): boolean;
                    }

                    interface OnVideoCaptureResourceCreatedCallback {
                        ($captureObject: UnityEngine.Windows.WebCam.VideoCapture): void;
                        Invoke?: ($captureObject: UnityEngine.Windows.WebCam.VideoCapture) => void;
                    }
                    var OnVideoCaptureResourceCreatedCallback: { new (func: ($captureObject: UnityEngine.Windows.WebCam.VideoCapture) => void): OnVideoCaptureResourceCreatedCallback; };

                    interface OnVideoModeStartedCallback {
                        ($result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult): void;
                        Invoke?: ($result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void;
                    }
                    var OnVideoModeStartedCallback: { new (func: ($result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void): OnVideoModeStartedCallback; };

                    interface OnVideoModeStoppedCallback {
                        ($result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult): void;
                        Invoke?: ($result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void;
                    }
                    var OnVideoModeStoppedCallback: { new (func: ($result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void): OnVideoModeStoppedCallback; };

                    interface OnStartedRecordingVideoCallback {
                        ($result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult): void;
                        Invoke?: ($result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void;
                    }
                    var OnStartedRecordingVideoCallback: { new (func: ($result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void): OnStartedRecordingVideoCallback; };

                    interface OnStoppedRecordingVideoCallback {
                        ($result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult): void;
                        Invoke?: ($result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void;
                    }
                    var OnStoppedRecordingVideoCallback: { new (func: ($result: UnityEngine.Windows.WebCam.VideoCapture.VideoCaptureResult) => void): OnStoppedRecordingVideoCallback; };

                }

                enum CapturePixelFormat {
                    BGRA32 = 0,
                    NV12 = 1,
                    JPEG = 2,
                    PNG = 3
                }

                enum WebCamMode {
                    None = 0,
                    PhotoMode = 1,
                    VideoMode = 2
                }

                class WebCam {
                    protected [__keep_incompatibility]: never;
                    public static get Mode(): UnityEngine.Windows.WebCam.WebCamMode;
                    constructor();
                }

                class CameraParameters {
                    protected [__keep_incompatibility]: never;
                    public hologramOpacity: number;
                    public frameRate: number;
                    public cameraResolutionWidth: number;
                    public cameraResolutionHeight: number;
                    public pixelFormat: UnityEngine.Windows.WebCam.CapturePixelFormat;
                    constructor($webCamMode: UnityEngine.Windows.WebCam.WebCamMode);
                }

            }
        }
    }
    namespace UnityEngine {
        namespace WSA {
            interface AppCallbackItem {
                (): void;
                Invoke?: () => void;
            }
            var AppCallbackItem: { new (func: () => void): AppCallbackItem; };

            interface WindowSizeChanged {
                ($width: number, $height: number): void;
                Invoke?: ($width: number, $height: number) => void;
            }
            var WindowSizeChanged: { new (func: ($width: number, $height: number) => void): WindowSizeChanged; };

            enum WindowActivationState {
                CodeActivated = 0,
                Deactivated = 1,
                PointerActivated = 2
            }

            interface WindowActivated {
                ($state: UnityEngine.WSA.WindowActivationState): void;
                Invoke?: ($state: UnityEngine.WSA.WindowActivationState) => void;
            }
            var WindowActivated: { new (func: ($state: UnityEngine.WSA.WindowActivationState) => void): WindowActivated; };

            class Application {
                protected [__keep_incompatibility]: never;
                public static get arguments(): string;
                public static get advertisingIdentifier(): string;
                constructor();
                public static InvokeOnAppThread($item: UnityEngine.WSA.AppCallbackItem, $waitUntilDone: boolean): void;
                public static InvokeOnUIThread($item: UnityEngine.WSA.AppCallbackItem, $waitUntilDone: boolean): void;
                public static RunningOnAppThread(): boolean;
                public static RunningOnUIThread(): boolean;
                public static add_windowSizeChanged(handler: UnityEngine.WSA.WindowSizeChanged): void;
                public static remove_windowSizeChanged(handler: UnityEngine.WSA.WindowSizeChanged): void;
                public static add_windowActivated(handler: UnityEngine.WSA.WindowActivated): void;
                public static remove_windowActivated(handler: UnityEngine.WSA.WindowActivated): void;
            }

            class Cursor {
                protected [__keep_incompatibility]: never;
                public static SetCustomCursor($id: number): void;
            }

            enum Folder {
                Installation = 0,
                Temporary = 1,
                Local = 2,
                Roaming = 3,
                CameraRoll = 4,
                DocumentsLibrary = 5,
                HomeGroup = 6,
                MediaServerDevices = 7,
                MusicLibrary = 8,
                PicturesLibrary = 9,
                Playlists = 10,
                RemovableDevices = 11,
                SavedPictures = 12,
                VideosLibrary = 13
            }

            class Launcher {
                protected [__keep_incompatibility]: never;
                constructor();
                public static LaunchFile($folder: UnityEngine.WSA.Folder, $relativeFilePath: string, $showWarning: boolean): void;
                public static LaunchFileWithPicker($fileExtension: string): void;
                public static LaunchUri($uri: string, $showWarning: boolean): void;
            }

            enum TileTemplate {
                TileSquare150x150Image = 0,
                TileSquare150x150Block = 1,
                TileSquare150x150Text01 = 2,
                TileSquare150x150Text02 = 3,
                TileSquare150x150Text03 = 4,
                TileSquare150x150Text04 = 5,
                TileSquare150x150PeekImageAndText01 = 6,
                TileSquare150x150PeekImageAndText02 = 7,
                TileSquare150x150PeekImageAndText03 = 8,
                TileSquare150x150PeekImageAndText04 = 9,
                TileWide310x150Image = 10,
                TileWide310x150ImageCollection = 11,
                TileWide310x150ImageAndText01 = 12,
                TileWide310x150ImageAndText02 = 13,
                TileWide310x150BlockAndText01 = 14,
                TileWide310x150BlockAndText02 = 15,
                TileWide310x150PeekImageCollection01 = 16,
                TileWide310x150PeekImageCollection02 = 17,
                TileWide310x150PeekImageCollection03 = 18,
                TileWide310x150PeekImageCollection04 = 19,
                TileWide310x150PeekImageCollection05 = 20,
                TileWide310x150PeekImageCollection06 = 21,
                TileWide310x150PeekImageAndText01 = 22,
                TileWide310x150PeekImageAndText02 = 23,
                TileWide310x150PeekImage01 = 24,
                TileWide310x150PeekImage02 = 25,
                TileWide310x150PeekImage03 = 26,
                TileWide310x150PeekImage04 = 27,
                TileWide310x150PeekImage05 = 28,
                TileWide310x150PeekImage06 = 29,
                TileWide310x150SmallImageAndText01 = 30,
                TileWide310x150SmallImageAndText02 = 31,
                TileWide310x150SmallImageAndText03 = 32,
                TileWide310x150SmallImageAndText04 = 33,
                TileWide310x150SmallImageAndText05 = 34,
                TileWide310x150Text01 = 35,
                TileWide310x150Text02 = 36,
                TileWide310x150Text03 = 37,
                TileWide310x150Text04 = 38,
                TileWide310x150Text05 = 39,
                TileWide310x150Text06 = 40,
                TileWide310x150Text07 = 41,
                TileWide310x150Text08 = 42,
                TileWide310x150Text09 = 43,
                TileWide310x150Text10 = 44,
                TileWide310x150Text11 = 45,
                TileSquare310x310BlockAndText01 = 46,
                TileSquare310x310BlockAndText02 = 47,
                TileSquare310x310Image = 48,
                TileSquare310x310ImageAndText01 = 49,
                TileSquare310x310ImageAndText02 = 50,
                TileSquare310x310ImageAndTextOverlay01 = 51,
                TileSquare310x310ImageAndTextOverlay02 = 52,
                TileSquare310x310ImageAndTextOverlay03 = 53,
                TileSquare310x310ImageCollectionAndText01 = 54,
                TileSquare310x310ImageCollectionAndText02 = 55,
                TileSquare310x310ImageCollection = 56,
                TileSquare310x310SmallImagesAndTextList01 = 57,
                TileSquare310x310SmallImagesAndTextList02 = 58,
                TileSquare310x310SmallImagesAndTextList03 = 59,
                TileSquare310x310SmallImagesAndTextList04 = 60,
                TileSquare310x310Text01 = 61,
                TileSquare310x310Text02 = 62,
                TileSquare310x310Text03 = 63,
                TileSquare310x310Text04 = 64,
                TileSquare310x310Text05 = 65,
                TileSquare310x310Text06 = 66,
                TileSquare310x310Text07 = 67,
                TileSquare310x310Text08 = 68,
                TileSquare310x310TextList01 = 69,
                TileSquare310x310TextList02 = 70,
                TileSquare310x310TextList03 = 71,
                TileSquare310x310SmallImageAndText01 = 72,
                TileSquare310x310SmallImagesAndTextList05 = 73,
                TileSquare310x310Text09 = 74,
                TileSquare71x71IconWithBadge = 75,
                TileSquare150x150IconWithBadge = 76,
                TileWide310x150IconWithBadgeAndText = 77,
                TileSquare71x71Image = 78,
                TileTall150x310Image = 79,
                TileSquare99x99IconWithBadge = 1000,
                TileSquare210x210IconWithBadge = 1001,
                TileWide432x210IconWithBadgeAndText = 1002
            }

            enum ToastTemplate {
                ToastImageAndText01 = 0,
                ToastImageAndText02 = 1,
                ToastImageAndText03 = 2,
                ToastImageAndText04 = 3,
                ToastText01 = 4,
                ToastText02 = 5,
                ToastText03 = 6,
                ToastText04 = 7
            }

            enum TileForegroundText {
                Dark = 0,
                Light = 1,
                Default = -1
            }

            class SecondaryTileData {
                protected [__keep_incompatibility]: never;
                public arguments: string;
                public backgroundColorSet: boolean;
                public displayName: string;
                public foregroundText: UnityEngine.WSA.TileForegroundText;
                public lockScreenBadgeLogo: string;
                public lockScreenDisplayBadgeAndTileText: boolean;
                public phoneticName: string;
                public roamingEnabled: boolean;
                public showNameOnSquare150x150Logo: boolean;
                public showNameOnSquare310x310Logo: boolean;
                public showNameOnWide310x150Logo: boolean;
                public square150x150Logo: string;
                public square30x30Logo: string;
                public square310x310Logo: string;
                public square70x70Logo: string;
                public tileId: string;
                public wide310x150Logo: string;
                public backgroundColor: UnityEngine.Color32;
                constructor($id: string, $displayName: string);
            }

            class Tile {
                protected [__keep_incompatibility]: never;
                public static get main(): UnityEngine.WSA.Tile;
                public get id(): string;
                public get hasUserConsent(): boolean;
                public get exists(): boolean;
                public static GetTemplate($templ: UnityEngine.WSA.TileTemplate): string;
                public Update($xml: string): void;
                public Update($medium: string, $wide: string, $large: string, $text: string): void;
                public PeriodicUpdate($uri: string, $interval: number): void;
                public StopPeriodicUpdate(): void;
                public UpdateBadgeImage($image: string): void;
                public UpdateBadgeNumber($number: number): void;
                public RemoveBadge(): void;
                public PeriodicBadgeUpdate($uri: string, $interval: number): void;
                public StopPeriodicBadgeUpdate(): void;
                public static Exists($tileId: string): boolean;
                public static CreateOrUpdateSecondary($data: UnityEngine.WSA.SecondaryTileData): UnityEngine.WSA.Tile;
                public static CreateOrUpdateSecondary($data: UnityEngine.WSA.SecondaryTileData, $pos: UnityEngine.Vector2): UnityEngine.WSA.Tile;
                public static CreateOrUpdateSecondary($data: UnityEngine.WSA.SecondaryTileData, $area: UnityEngine.Rect): UnityEngine.WSA.Tile;
                public static GetSecondary($tileId: string): UnityEngine.WSA.Tile;
                public static GetSecondaries(): System.Array$1<UnityEngine.WSA.Tile>;
                public Delete(): void;
                public static DeleteSecondary($tileId: string): void;
                public Delete($pos: UnityEngine.Vector2): void;
                public static DeleteSecondary($tileId: string, $pos: UnityEngine.Vector2): void;
                public Delete($area: UnityEngine.Rect): void;
                public static DeleteSecondary($tileId: string, $area: UnityEngine.Rect): void;
            }

            class Toast {
                protected [__keep_incompatibility]: never;
                public arguments: string;
                public get activated(): boolean;
                public get dismissed(): boolean;
                public get dismissedByUser(): boolean;
                public static GetTemplate($templ: UnityEngine.WSA.ToastTemplate): string;
                public static Create($xml: string): UnityEngine.WSA.Toast;
                public static Create($image: string, $text: string): UnityEngine.WSA.Toast;
                public Show(): void;
                public Hide(): void;
            }

        }
    }
    namespace UnityEngineInternal {
        enum GITextureType {
            Charting = 0,
            Albedo = 1,
            Emissive = 2,
            Irradiance = 3,
            Directionality = 4,
            Baked = 5,
            BakedDirectional = 6,
            InputWorkspace = 7,
            BakedShadowMask = 8,
            BakedAlbedo = 9,
            BakedEmissive = 10,
            BakedCharting = 11,
            BakedTexelValidity = 12,
            BakedUVOverlap = 13,
            BakedLightmapCulling = 14
        }

        class GIDebugVisualisation {
            protected [__keep_incompatibility]: never;
            public static get cycleMode(): boolean;
            public static get pauseCycleMode(): boolean;
            public static texType: UnityEngineInternal.GITextureType;
            public static ResetRuntimeInputTextures(): void;
            public static PlayCycleMode(): void;
            public static PauseCycleMode(): void;
            public static StopCycleMode(): void;
            public static CycleSkipSystems($skip: number): void;
            public static CycleSkipInstances($skip: number): void;
        }

        enum MemorylessMode {
            Unused = 0,
            Forced = 1,
            Automatic = 2
        }

        class MemorylessManager {
            protected [__keep_incompatibility]: never;
            public static depthMemorylessMode: UnityEngineInternal.MemorylessMode;
            constructor();
        }

        class MathfInternal {
            protected [__keep_incompatibility]: never;
            public static FloatMinNormal: number;
            public static FloatMinDenormal: number;
            public static IsFlushToZeroEnabled: boolean;
        }

        class APIUpdaterRuntimeServices {
            protected [__keep_incompatibility]: never;
            constructor();
            public static AddComponent($go: UnityEngine.GameObject, $sourceInfo: string, $name: string): UnityEngine.Component;
        }

        enum TypeInferenceRules {
            TypeReferencedByFirstArgument = 0,
            TypeReferencedBySecondArgument = 1,
            ArrayOfTypeReferencedByFirstArgument = 2,
            TypeOfFirstArgument = 3
        }

        class TypeInferenceRuleAttribute extends System.Attribute {
            protected [__keep_incompatibility]: never;
            constructor($rule: UnityEngineInternal.TypeInferenceRules);
            constructor($rule: string);
            public ToString(): string;
        }

        class GenericStack extends System.Collections.Stack {
            protected [__keep_incompatibility]: never;
            constructor();
        }

    }
}
